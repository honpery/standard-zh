(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{365:function(e,n,t){"use strict";t.r(n);var o=t(42),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[e._v("#")]),e._v(" WebSocket")]),e._v(" "),t("blockquote",[t("p",[e._v("The WebSocket Protocol "),t("a",{attrs:{href:"https://tools.ietf.org/html/rfc6455",target:"_blank",rel:"noopener noreferrer"}},[e._v("原文链接"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"摘要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[e._v("#")]),e._v(" 摘要")]),e._v(" "),t("p",[e._v("WebSocket协议允许在受控环境中运行不受信任代码的客户端与已选择从该代码进行通信的远程主机之间进行双向通信。为此使用的安全模型是Web浏览器通常使用的基于源的安全模型。该协议包括一个开放的握手，随后是基本消息帧，并在TCP上分层。该技术的目标是为需要与不依赖于打开多个HTTP连接的服务器进行双向通信的基于浏览器的应用程序提供一种机制（例如，使用XMLHttpRequest或< iframe>和长轮询）。\n")]),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[t("p"),e._v("\n"),t("p",[e._v("Abstract")]),e._v("\n"),t("p",[e._v("The WebSocket Protocol enables two-way communication between a client\nrunning untrusted code in a controlled environment to a remote host\nthat has opted-in to communications from that code.  The security\nmodel used for this is the origin-based security model commonly used\nby web browsers.  The protocol consists of an opening handshake\nfollowed by basic message framing, layered over TCP.  The goal of\nthis technology is to provide a mechanism for browser-based\napplications that need two-way communication with servers that does\nnot rely on opening multiple HTTP connections (e.g., using\nXMLHttpRequest or < iframe >s and long polling).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h3",{attrs:{id:"备忘录状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#备忘录状态"}},[e._v("#")]),e._v(" 备忘录状态")]),e._v(" "),t("p",[e._v("这是Internet标准跟踪文档。")]),e._v(" "),t("p",[e._v("本文档是Internet工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被Internet工程指导小组（IESG）批准发布。有关Internet标准的更多信息，请参见RFC 5741的第2节。")]),e._v(" "),t("p",[e._v("有关本文档当前状态，任何勘误以及如何提供反馈的信息，请访问"),t("a",{attrs:{href:"http://www.rfc-editor.org/info/rfc7230",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.rfc-editor.org/info/rfc7230"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("Status of This Memo")]),e._v("\n"),t("p",[e._v("This is an Internet Standards Track document.")]),e._v("\n"),t("p",[e._v("This document is a product of the Internet Engineering Task Force\n(IETF).  It represents the consensus of the IETF community.  It has\nreceived public review and has been approved for publication by the\nInternet Engineering Steering Group (IESG).  Further information on\nInternet Standards is available in Section 2 of RFC 5741.")]),e._v("\n"),t("p",[e._v("Information about the current status of this document, any errata,\nand how to provide feedback on it may be obtained at\nhttp://www.rfc-editor.org/info/rfc6455.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h3",{attrs:{id:"版权声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#版权声明"}},[e._v("#")]),e._v(" 版权声明")]),e._v(" "),t("p",[e._v("2011 IETF Trust和确定为文档作者的人员。版权所有。")]),e._v(" "),t("p",[e._v("本文档受"),t("a",{attrs:{href:"https://tools.ietf.org/html/bcp78",target:"_blank",rel:"noopener noreferrer"}},[e._v("BCP 78"),t("OutboundLink")],1),e._v("和IETF Trust关于IETF文档的法律规定（"),t("a",{attrs:{href:"http://trustee.ietf.org/license-info",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://trustee.ietf.org/license-info"),t("OutboundLink")],1),e._v("）的约束，自本文档发布之日起生效。请仔细阅读这些文档，因为它们描述了您对本文档的权利和限制。从本文档中摘录的代码组件必须包含《信托法律条款》第4.e节中所述的BSD简化许可证文本，并且如BSD简化许可证中所述，提供的内容不附带任何保证。")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("Copyright Notice")]),e._v("\n"),t("p",[e._v("Copyright (c) 2011 IETF Trust and the persons identified as the\ndocument authors.  All rights reserved.")]),e._v("\n"),t("p",[e._v("This document is subject to BCP 78 and the IETF Trust's Legal\nProvisions Relating to IETF Documents\n(http://trustee.ietf.org/license-info) in effect on the date of\npublication of this document.  Please review these documents\ncarefully, as they describe your rights and restrictions with respect\nto this document.  Code Components extracted from this document must\ninclude Simplified BSD License text as described in Section 4.e of\nthe Trust Legal Provisions and are provided without warranty as\ndescribed in the Simplified BSD License.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h3",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[e._v("#")]),e._v(" 目录")]),e._v(" "),t("p",[e._v(".")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("Table of Contents")]),e._v("\n"),t("ol",[e._v("\n"),t("li",[e._v("Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n1.1.  Background . . . . . . . . . . . . . . . . . . . . . . . .  4\n1.2.  Protocol Overview  . . . . . . . . . . . . . . . . . . . .  5\n1.3.  Opening Handshake  . . . . . . . . . . . . . . . . . . . .  6\n1.4.  Closing Handshake  . . . . . . . . . . . . . . . . . . . .  9\n1.5.  Design Philosophy  . . . . . . . . . . . . . . . . . . . .  9\n1.6.  Security Model . . . . . . . . . . . . . . . . . . . . . . 10\n1.7.  Relationship to TCP and HTTP . . . . . . . . . . . . . . . 11\n1.8.  Establishing a Connection  . . . . . . . . . . . . . . . . 11\n1.9.  Subprotocols Using the WebSocket Protocol  . . . . . . . . 12")]),e._v("\n"),t("li",[e._v("Conformance Requirements . . . . . . . . . . . . . . . . . . . 12\n2.1.  Terminology and Other Conventions  . . . . . . . . . . . . 13")]),e._v("\n"),t("li",[e._v("WebSocket URIs . . . . . . . . . . . . . . . . . . . . . . . . 14")]),e._v("\n"),t("li",[e._v("Opening Handshake  . . . . . . . . . . . . . . . . . . . . . . 14\n4.1.  Client Requirements  . . . . . . . . . . . . . . . . . . . 14\n4.2.  Server-Side Requirements . . . . . . . . . . . . . . . . . 20\n4.2.1.  Reading the Client's Opening Handshake . . . . . . . . 21\n4.2.2.  Sending the Server's Opening Handshake . . . . . . . . 22\n4.3.  Collected ABNF for New Header Fields Used in Handshake . . 25\n4.4.  Supporting Multiple Versions of WebSocket Protocol . . . . 26")]),e._v("\n"),t("li",[e._v("Data Framing . . . . . . . . . . . . . . . . . . . . . . . . . 27\n5.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . 27\n5.2.  Base Framing Protocol  . . . . . . . . . . . . . . . . . . 28\n5.3.  Client-to-Server Masking . . . . . . . . . . . . . . . . . 32\n5.4.  Fragmentation  . . . . . . . . . . . . . . . . . . . . . . 33\n5.5.  Control Frames . . . . . . . . . . . . . . . . . . . . . . 36\n5.5.1.  Close  . . . . . . . . . . . . . . . . . . . . . . . . 36\n5.5.2.  Ping . . . . . . . . . . . . . . . . . . . . . . . . . 37\n5.5.3.  Pong . . . . . . . . . . . . . . . . . . . . . . . . . 37\n5.6.  Data Frames  . . . . . . . . . . . . . . . . . . . . . . . 38\n5.7.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . 38\n5.8.  Extensibility  . . . . . . . . . . . . . . . . . . . . . . 39")]),e._v("\n"),t("li",[e._v("Sending and Receiving Data . . . . . . . . . . . . . . . . . . 39\n6.1.  Sending Data . . . . . . . . . . . . . . . . . . . . . . . 39\n6.2.  Receiving Data . . . . . . . . . . . . . . . . . . . . . . 40")]),e._v("\n"),t("li",[e._v("Closing the Connection . . . . . . . . . . . . . . . . . . . . 41\n7.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . . 41\n7.1.1.  Close the WebSocket Connection . . . . . . . . . . . . 41\n7.1.2.  Start the WebSocket Closing Handshake  . . . . . . . . 42\n7.1.3.  The WebSocket Closing Handshake is Started . . . . . . 42\n7.1.4.  The WebSocket Connection is Closed . . . . . . . . . . 42\n7.1.5.  The WebSocket Connection Close Code  . . . . . . . . . 42\n7.1.6.  The WebSocket Connection Close Reason  . . . . . . . . 43\n7.1.7.  Fail the WebSocket Connection  . . . . . . . . . . . . 43\n7.2.  Abnormal Closures  . . . . . . . . . . . . . . . . . . . . 44\n7.2.1.  Client-Initiated Closure . . . . . . . . . . . . . . . 44\n7.2.2.  Server-Initiated Closure . . . . . . . . . . . . . . . 44\n7.2.3.  Recovering from Abnormal Closure . . . . . . . . . . . 44\n7.3.  Normal Closure of Connections  . . . . . . . . . . . . . . 45\n7.4.  Status Codes . . . . . . . . . . . . . . . . . . . . . . . 45\n7.4.1.  Defined Status Codes . . . . . . . . . . . . . . . . . 45\n7.4.2.  Reserved Status Code Ranges  . . . . . . . . . . . . . 47")]),e._v("\n"),t("li",[e._v("Error Handling . . . . . . . . . . . . . . . . . . . . . . . . 48\n8.1.  Handling Errors in UTF-8-Encoded Data  . . . . . . . . . . 48")]),e._v("\n"),t("li",[e._v("Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n9.1.  Negotiating Extensions . . . . . . . . . . . . . . . . . . 48\n9.2.  Known Extensions . . . . . . . . . . . . . . . . . . . . . 50")]),e._v("\n"),t("li",[e._v("Security Considerations  . . . . . . . . . . . . . . . . . . . 50\n10.1. Non-Browser Clients  . . . . . . . . . . . . . . . . . . . 50\n10.2. Origin Considerations  . . . . . . . . . . . . . . . . . . 50\n10.3. Attacks On Infrastructure (Masking)  . . . . . . . . . . . 51\n10.4. Implementation-Specific Limits . . . . . . . . . . . . . . 52\n10.5. WebSocket Client Authentication  . . . . . . . . . . . . . 53\n10.6. Connection Confidentiality and Integrity . . . . . . . . . 53\n10.7. Handling of Invalid Data . . . . . . . . . . . . . . . . . 53\n10.8. Use of SHA-1 by the WebSocket Handshake  . . . . . . . . . 54")]),e._v("\n"),t("li",[e._v('IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 54\n11.1. Registration of New URI Schemes  . . . . . . . . . . . . . 54\n11.1.1. Registration of "ws" Scheme  . . . . . . . . . . . . . 54\n11.1.2. Registration of "wss" Scheme . . . . . . . . . . . . . 55\n11.2. Registration of the "WebSocket" HTTP Upgrade Keyword . . . 56\n11.3. Registration of New HTTP Header Fields . . . . . . . . . . 57\n11.3.1. Sec-WebSocket-Key  . . . . . . . . . . . . . . . . . . 57\n11.3.2. Sec-WebSocket-Extensions . . . . . . . . . . . . . . . 58\n11.3.3. Sec-WebSocket-Accept . . . . . . . . . . . . . . . . . 58\n11.3.4. Sec-WebSocket-Protocol . . . . . . . . . . . . . . . . 59\n11.3.5. Sec-WebSocket-Version  . . . . . . . . . . . . . . . . 60\n11.4. WebSocket Extension Name Registry  . . . . . . . . . . . . 61\n11.5. WebSocket Subprotocol Name Registry  . . . . . . . . . . . 61\n11.6. WebSocket Version Number Registry  . . . . . . . . . . . . 62\n11.7. WebSocket Close Code Number Registry . . . . . . . . . . . 64\n11.8. WebSocket Opcode Registry  . . . . . . . . . . . . . . . . 65\n11.9. WebSocket Framing Header Bits Registry . . . . . . . . . . 66')]),e._v("\n"),t("li",[e._v("Using the WebSocket Protocol from Other Specifications . . . . 66")]),e._v("\n"),t("li",[e._v("Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 67")]),e._v("\n"),t("li",[e._v("References . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n14.1. Normative References . . . . . . . . . . . . . . . . . . . 68\n14.2. Informative References . . . . . . . . . . . . . . . . . . 69")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_1-引言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-引言"}},[e._v("#")]),e._v(" 1. 引言")]),e._v(" "),t("h3",{attrs:{id:"_1-1-背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-背景"}},[e._v("#")]),e._v(" 1.1 背景")]),e._v(" "),t("p",[e._v("本部分非规范性协议。")]),e._v(" "),t("p",[e._v("从历史上看，创建需要在客户端和服务器之间进行双向通信的Web应用程序（例如，即时消息传递和游戏应用程序）需要滥用HTTP来轮询服务器以获取更新，同时以不同的HTTP调用的形式发送上游通知[RFC6202]。")]),e._v(" "),t("p",[e._v("这就导致了各种各样的问题：")]),e._v(" "),t("ol",[t("li",[e._v("服务器被迫为每个客户端使用许多不同的基础TCP连接：一个用于向客户端发送信息，而为每个传入消息使用新的TCP连接。")]),e._v(" "),t("li",[e._v("有线协议的开销很高，每个客户端到服务器的消息都有一个HTTP头。")]),e._v(" "),t("li",[e._v("客户端脚本被强制维护从传出连接到传入连接的映射以跟踪答复。")])]),e._v(" "),t("p",[e._v("一个更简单的解决方案是将单个TCP连接用于双向通信。这就是WebSocket协议所提供的。与WebSocket API [WSAPI]结合使用，它提供了HTTP轮询的替代方法，用于从网页到远程服务器的双向通信。")]),e._v(" "),t("p",[e._v("相同的技术可以用于多种Web应用程序：游戏，股票报价器，具有同时编辑功能的多用户应用程序，实时显示服务器端服务的用户界面等。")]),e._v(" "),t("p",[e._v("WebSocket协议旨在取代使用HTTP作为传输层的现有双向通信技术，以从现有基础结构（代理，过滤，身份验证）中受益。之所以实现这些技术，是因为要在效率和可靠性之间进行权衡，因为HTTP最初并不适合用于双向通信（有关更多讨论，请参见[RFC6202]）。 WebSocket协议尝试在现有HTTP基础结构的上下文中解决现有双向HTTP技术的目标；这样，即使这意味着当前环境特有的复杂性，它也可以在HTTP端口80和443上工作并支持HTTP代理和中介。但是，该设计并不将WebSocket限制为HTTP，并且将来的实现可以在专用端口上使用更简单的握手，而无需重新发明整个协议。最后一点很重要，因为交互式消息的流量模式与标准HTTP流量不完全匹配，并且可能在某些组件上引起异常负载。")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",[e._v("\n"),t("li",[e._v("Introduction")]),e._v("\n")]),e._v("\n"),t("p",[e._v("1.1.  Background")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("Historically, creating web applications that need bidirectional\ncommunication between a client and a server (e.g., instant messaging\nand gaming applications) has required an abuse of HTTP to poll the\nserver for updates while sending upstream notifications as distinct\nHTTP calls [RFC6202].")]),e._v("\n"),t("p",[e._v("This results in a variety of problems:")]),e._v("\n"),t("p",[e._v("o  The server is forced to use a number of different underlying TCP\nconnections for each client: one for sending information to the\nclient and a new one for each incoming message.")]),e._v("\n"),t("p",[e._v("o  The wire protocol has a high overhead, with each client-to-server\nmessage having an HTTP header.")]),e._v("\n"),t("p",[e._v("o  The client-side script is forced to maintain a mapping from the\noutgoing connections to the incoming connection to track replies.")]),e._v("\n"),t("p",[e._v("A simpler solution would be to use a single TCP connection for\ntraffic in both directions.  This is what the WebSocket Protocol\nprovides.  Combined with the WebSocket API [WSAPI], it provides an\nalternative to HTTP polling for two-way communication from a web page\nto a remote server.")]),e._v("\n"),t("p",[e._v("The same technique can be used for a variety of web applications:\ngames, stock tickers, multiuser applications with simultaneous\nediting, user interfaces exposing server-side services in real time,\netc.")]),e._v("\n"),t("p",[e._v("The WebSocket Protocol is designed to supersede existing\nbidirectional communication technologies that use HTTP as a transport\nlayer to benefit from existing infrastructure (proxies, filtering,\nauthentication).  Such technologies were implemented as trade-offs\nbetween efficiency and reliability because HTTP was not initially\nmeant to be used for bidirectional communication (see [RFC6202] for\nfurther discussion).  The WebSocket Protocol attempts to address the\ngoals of existing bidirectional HTTP technologies in the context of\nthe existing HTTP infrastructure; as such, it is designed to work\nover HTTP ports 80 and 443 as well as to support HTTP proxies and\nintermediaries, even if this implies some complexity specific to the\ncurrent environment.  However, the design does not limit WebSocket to\nHTTP, and future implementations could use a simpler handshake over a\ndedicated port without reinventing the entire protocol.  This last\npoint is important because the traffic patterns of interactive\nmessaging do not closely match standard HTTP traffic and can induce\nunusual loads on some components.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h3",{attrs:{id:"_1-2-协议概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-协议概述"}},[e._v("#")]),e._v(" 1.2 协议概述")]),e._v(" "),t("p",[e._v("本部分非规范性协议。")]),e._v(" "),t("p",[e._v("协议分为两部分：握手和数据传输。")]),e._v(" "),t("p",[e._v("与客户端握手如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("        GET /chat HTTP/1.1\n        Host: server.example.com\n        Upgrade: websocket\n        Connection: Upgrade\n        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n        Origin: http://example.com\n        Sec-WebSocket-Protocol: chat, superchat\n        Sec-WebSocket-Version: 13\n")])])]),t("p",[e._v("与服务器的握手如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("        HTTP/1.1 101 Switching Protocols\n        Upgrade: websocket\n        Connection: Upgrade\n        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n        Sec-WebSocket-Protocol: chat\n")])])]),t("p",[e._v("来自客户端的引导线遵循请求线格式，来自服务器的引导线遵循状态线格式。请求行和状态行的产生在[RFC2616]中定义。")]),e._v(" "),t("p",[e._v("在这两种情况下，无序的头字段都位于最前面。这些头字段的含义在本文档的第4节中指定。也可能存在其他头字段，例如cookie [RFC6265]。标头的格式和解析如[RFC2616]中所定义。")]),e._v(" "),t("p",[e._v("一旦客户端和服务器都发送了握手，并且握手成功，则数据传输部分开始。这是双向通信通道，双方可以独立地任意发送数据。")]),e._v(" "),t("p",[e._v("成功的握手之后，客户端和服务器以在本规范中称为“消息”的概念单元来回传输数据。在线上，一条消息由一个或多个帧组成。 WebSocket消息不一定与特定的网络层成帧相对应，因为零碎的消息可能会被中介处理或拆分。")]),e._v(" "),t("p",[e._v("帧具有关联的类型。属于相同消息的每个帧都包含相同类型的数据。广义上讲，有文本数据（解释为UTF-8 [RFC3629]文本），二进制数据（解释权留给应用程序）和控制帧（不打算为应用程序携带数据，而是为应用程序提供）的类型。协议级别的指令，例如表示应关闭连接）。该协议的版本定义了六种帧类型，保留了十个以供将来使用。")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.2.  Protocol Overview")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("The protocol has two parts: a handshake and the data transfer.")]),e._v("\n"),t("p",[e._v("The handshake from the client looks as follows:")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    GET /chat HTTP/1.1\n    Host: server.example.com\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n    Origin: http://example.com\n    Sec-WebSocket-Protocol: chat, superchat\n    Sec-WebSocket-Version: 13\n")])])]),t("p",[e._v("The handshake from the server looks as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n    Sec-WebSocket-Protocol: chat\n")])])]),t("p",[e._v("The leading line from the client follows the Request-Line format.\nThe leading line from the server follows the Status-Line format.  The\nRequest-Line and Status-Line productions are defined in [RFC2616].")]),e._v(" "),t("p",[e._v("An unordered set of header fields comes after the leading line in\nboth cases.  The meaning of these header fields is specified in\nSection 4 of this document.  Additional header fields may also be\npresent, such as cookies [RFC6265].  The format and parsing of\nheaders is as defined in [RFC2616].")]),e._v(" "),t("p",[e._v("Once the client and server have both sent their handshakes, and if\nthe handshake was successful, then the data transfer part starts.\nThis is a two-way communication channel where each side can,\nindependently from the other, send data at will.")]),e._v(" "),t("p",[e._v('After a successful handshake, clients and servers transfer data back\nand forth in conceptual units referred to in this specification as\n"messages".  On the wire, a message is composed of one or more\nframes.  The WebSocket message does not necessarily correspond to a\nparticular network layer framing, as a fragmented message may be\ncoalesced or split by an intermediary.')]),e._v(" "),t("p",[e._v("A frame has an associated type.  Each frame belonging to the same\nmessage contains the same type of data.  Broadly speaking, there are\ntypes for textual data (which is interpreted as UTF-8 [RFC3629]\ntext), binary data (whose interpretation is left up to the\napplication), and control frames (which are not intended to carry\ndata for the application but instead for protocol-level signaling,\nsuch as to signal that the connection should be closed).  This\nversion of the protocol defines six frame types and leaves ten\nreserved for future use.")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.3.  Opening Handshake")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("The opening handshake is intended to be compatible with HTTP-based\nserver-side software and intermediaries, so that a single port can be\nused by both HTTP clients talking to that server and WebSocket\nclients talking to that server.  To this end, the WebSocket client's\nhandshake is an HTTP Upgrade request:")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    GET /chat HTTP/1.1\n    Host: server.example.com\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n    Origin: http://example.com\n    Sec-WebSocket-Protocol: chat, superchat\n    Sec-WebSocket-Version: 13\n")])])]),t("p",[e._v("In compliance with [RFC2616], header fields in the handshake may be\nsent by the client in any order, so the order in which different\nheader fields are received is not significant.")]),e._v(" "),t("p",[e._v('The "Request-URI" of the GET method [RFC2616] is used to identify the\nendpoint of the WebSocket connection, both to allow multiple domains\nto be served from one IP address and to allow multiple WebSocket\nendpoints to be served by a single server.')]),e._v(" "),t("p",[e._v("The client includes the hostname in the |Host| header field of its\nhandshake as per [RFC2616], so that both the client and the server\ncan verify that they agree on which host is in use.")]),e._v(" "),t("p",[e._v("Additional header fields are used to select options in the WebSocket\nProtocol.  Typical options available in this version are the\nsubprotocol selector (|Sec-WebSocket-Protocol|), list of extensions\nsupport by the client (|Sec-WebSocket-Extensions|), |Origin| header\nfield, etc.  The |Sec-WebSocket-Protocol| request-header field can be\nused to indicate what subprotocols (application-level protocols\nlayered over the WebSocket Protocol) are acceptable to the client.\nThe server selects one or none of the acceptable protocols and echoes\nthat value in its handshake to indicate that it has selected that\nprotocol.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    Sec-WebSocket-Protocol: chat\n")])])]),t("p",[e._v("The |Origin| header field [RFC6454] is used to protect against\nunauthorized cross-origin use of a WebSocket server by scripts using\nthe WebSocket API in a web browser.  The server is informed of the\nscript origin generating the WebSocket connection request.  If the\nserver does not wish to accept connections from this origin, it can\nchoose to reject the connection by sending an appropriate HTTP error\ncode.  This header field is sent by browser clients; for non-browser\nclients, this header field may be sent if it makes sense in the\ncontext of those clients.")]),e._v(" "),t("p",[e._v("Finally, the server has to prove to the client that it received the\nclient's WebSocket handshake, so that the server doesn't accept\nconnections that are not WebSocket connections.  This prevents an\nattacker from tricking a WebSocket server by sending it carefully\ncrafted packets using XMLHttpRequest [XMLHttpRequest] or a form\nsubmission.")]),e._v(" "),t("p",[e._v("To prove that the handshake was received, the server has to take two\npieces of information and combine them to form a response.  The first\npiece of information comes from the |Sec-WebSocket-Key| header field\nin the client handshake:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n")])])]),t("p",[e._v('For this header field, the server has to take the value (as present\nin the header field, e.g., the base64-encoded [RFC4648] version minus\nany leading and trailing whitespace) and concatenate this with the\nGlobally Unique Identifier (GUID, [RFC4122]) "258EAFA5-E914-47DA-\n95CA-C5AB0DC85B11" in string form, which is unlikely to be used by\nnetwork endpoints that do not understand the WebSocket Protocol.  A\nSHA-1 hash (160 bits) [FIPS.180-3], base64-encoded (see Section 4 of\n[RFC4648]), of this concatenation is then returned in the server\'s\nhandshake.')]),e._v(" "),t("p",[e._v('Concretely, if as in the example above, the |Sec-WebSocket-Key|\nheader field had the value "dGhlIHNhbXBsZSBub25jZQ==", the server\nwould concatenate the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"\nto form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-\nC5AB0DC85B11".  The server would then take the SHA-1 hash of this,\ngiving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6\n0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea.  This value is\nthen base64-encoded (see Section 4 of [RFC4648]), to give the value\n"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=".  This value would then be echoed in\nthe |Sec-WebSocket-Accept| header field.')]),e._v(" "),t("p",[e._v("The handshake from the server is much simpler than the client\nhandshake.  The first line is an HTTP Status-Line, with the status\ncode 101:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    HTTP/1.1 101 Switching Protocols\n")])])]),t("p",[e._v("Any status code other than 101 indicates that the WebSocket handshake\nhas not completed and that the semantics of HTTP still apply.  The\nheaders follow the status code.")]),e._v(" "),t("p",[e._v("The |Connection| and |Upgrade| header fields complete the HTTP\nUpgrade.  The |Sec-WebSocket-Accept| header field indicates whether\nthe server is willing to accept the connection.  If present, this\nheader field must include a hash of the client's nonce sent in\n|Sec-WebSocket-Key| along with a predefined GUID.  Any other value\nmust not be interpreted as an acceptance of the connection by the\nserver.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n")])])]),t("p",[e._v("These fields are checked by the WebSocket client for scripted pages.\nIf the |Sec-WebSocket-Accept| value does not match the expected\nvalue, if the header field is missing, or if the HTTP status code is\nnot 101, the connection will not be established, and WebSocket frames\nwill not be sent.")]),e._v(" "),t("p",[e._v("Option fields can also be included.  In this version of the protocol,\nthe main option field is |Sec-WebSocket-Protocol|, which indicates\nthe subprotocol that the server has selected.  WebSocket clients\nverify that the server included one of the values that was specified\nin the WebSocket client's handshake.  A server that speaks multiple\nsubprotocols has to make sure it selects one based on the client's\nhandshake and specifies it in its handshake.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    Sec-WebSocket-Protocol: chat\n")])])]),t("p",[e._v("The server can also set cookie-related option fields to "),t("em",[e._v("set")]),e._v("\ncookies, as described in [RFC6265].")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.4.  Closing Handshake")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("The closing handshake is far simpler than the opening handshake.")]),e._v("\n"),t("p",[e._v("Either peer can send a control frame with data containing a specified\ncontrol sequence to begin the closing handshake (detailed in\nSection 5.5.1).  Upon receiving such a frame, the other peer sends a\nClose frame in response, if it hasn't already sent one.  Upon\nreceiving "),t("em",[e._v("that")]),e._v(" control frame, the first peer then closes the\nconnection, safe in the knowledge that no further data is\nforthcoming.")]),e._v("\n"),t("p",[e._v("After sending a control frame indicating the connection should be\nclosed, a peer does not send any further data; after receiving a\ncontrol frame indicating the connection should be closed, a peer\ndiscards any further data received.")]),e._v("\n"),t("p",[e._v("It is safe for both peers to initiate this handshake simultaneously.")]),e._v("\n"),t("p",[e._v("The closing handshake is intended to complement the TCP closing\nhandshake (FIN/ACK), on the basis that the TCP closing handshake is\nnot always reliable end-to-end, especially in the presence of\nintercepting proxies and other intermediaries.")]),e._v("\n"),t("p",[e._v("By sending a Close frame and waiting for a Close frame in response,\ncertain cases are avoided where data may be unnecessarily lost.  For\ninstance, on some platforms, if a socket is closed with data in the\nreceive queue, a RST packet is sent, which will then cause recv() to\nfail for the party that received the RST, even if there was data\nwaiting to be read.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.5.  Design Philosophy")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("The WebSocket Protocol is designed on the principle that there should\nbe minimal framing (the only framing that exists is to make the\nprotocol frame-based instead of stream-based and to support a\ndistinction between Unicode text and binary frames).  It is expected\nthat metadata would be layered on top of WebSocket by the application\nlayer, in the same way that metadata is layered on top of TCP by the\napplication layer (e.g., HTTP).")]),e._v("\n"),t("p",[e._v("Conceptually, WebSocket is really just a layer on top of TCP that\ndoes the following:")]),e._v("\n"),t("p",[e._v("o  adds a web origin-based security model for browsers")]),e._v("\n"),t("p",[e._v("o  adds an addressing and protocol naming mechanism to support\nmultiple services on one port and multiple host names on one IP\naddress")]),e._v("\n"),t("p",[e._v("o  layers a framing mechanism on top of TCP to get back to the IP\npacket mechanism that TCP is built on, but without length limits")]),e._v("\n"),t("p",[e._v("o  includes an additional closing handshake in-band that is designed\nto work in the presence of proxies and other intermediaries")]),e._v("\n"),t("p",[e._v("Other than that, WebSocket adds nothing.  Basically it is intended to\nbe as close to just exposing raw TCP to script as possible given the\nconstraints of the Web.  It's also designed in such a way that its\nservers can share a port with HTTP servers, by having its handshake\nbe a valid HTTP Upgrade request.  One could conceptually use other\nprotocols to establish client-server messaging, but the intent of\nWebSockets is to provide a relatively simple protocol that can\ncoexist with HTTP and deployed HTTP infrastructure (such as proxies)\nand that is as close to TCP as is safe for use with such\ninfrastructure given security considerations, with targeted additions\nto simplify usage and keep simple things simple (such as the addition\nof message semantics).")]),e._v("\n"),t("p",[e._v("The protocol is intended to be extensible; future versions will\nlikely introduce additional concepts such as multiplexing.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.6.  Security Model")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("The WebSocket Protocol uses the origin model used by web browsers to\nrestrict which web pages can contact a WebSocket server when the\nWebSocket Protocol is used from a web page.  Naturally, when the\nWebSocket Protocol is used by a dedicated client directly (i.e., not\nfrom a web page through a web browser), the origin model is not\nuseful, as the client can provide any arbitrary origin string.")]),e._v("\n"),t("p",[e._v("This protocol is intended to fail to establish a connection with\nservers of pre-existing protocols like SMTP [RFC5321] and HTTP, while\nallowing HTTP servers to opt-in to supporting this protocol if\ndesired.  This is achieved by having a strict and elaborate handshake\nand by limiting the data that can be inserted into the connection\nbefore the handshake is finished (thus limiting how much the server\ncan be influenced).")]),e._v("\n"),t("p",[e._v('It is similarly intended to fail to establish a connection when data\nfrom other protocols, especially HTTP, is sent to a WebSocket server,\nfor example, as might happen if an HTML "form" were submitted to a\nWebSocket server.  This is primarily achieved by requiring that the\nserver prove that it read the handshake, which it can only do if the\nhandshake contains the appropriate parts, which can only be sent by a\nWebSocket client.  In particular, at the time of writing of this\nspecification, fields starting with |Sec-| cannot be set by an\nattacker from a web browser using only HTML and JavaScript APIs such\nas XMLHttpRequest [XMLHttpRequest].')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.7.  Relationship to TCP and HTTP")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("The WebSocket Protocol is an independent TCP-based protocol.  Its\nonly relationship to HTTP is that its handshake is interpreted by\nHTTP servers as an Upgrade request.")]),e._v("\n"),t("p",[e._v("By default, the WebSocket Protocol uses port 80 for regular WebSocket\nconnections and port 443 for WebSocket connections tunneled over\nTransport Layer Security (TLS) [RFC2818].")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.8.  Establishing a Connection")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("When a connection is to be made to a port that is shared by an HTTP\nserver (a situation that is quite likely to occur with traffic to\nports 80 and 443), the connection will appear to the HTTP server to\nbe a regular GET request with an Upgrade offer.  In relatively simple\nsetups with just one IP address and a single server for all traffic\nto a single hostname, this might allow a practical way for systems\nbased on the WebSocket Protocol to be deployed.  In more elaborate\nsetups (e.g., with load balancers and multiple servers), a dedicated\nset of hosts for WebSocket connections separate from the HTTP servers\nis probably easier to manage.  At the time of writing of this\nspecification, it should be noted that connections on ports 80 and\n443 have significantly different success rates, with connections on\nport 443 being significantly more likely to succeed, though this may\nchange with time.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("1.9.  Subprotocols Using the WebSocket Protocol")]),e._v("\n"),t("p",[t("em",[e._v("This section is non-normative.")])]),e._v("\n"),t("p",[e._v("The client can request that the server use a specific subprotocol by\nincluding the |Sec-WebSocket-Protocol| field in its handshake.  If it\nis specified, the server needs to include the same field and one of\nthe selected subprotocol values in its response for the connection to\nbe established.")]),e._v("\n"),t("p",[e._v('These subprotocol names should be registered as per Section 11.5.  To\navoid potential collisions, it is recommended to use names that\ncontain the ASCII version of the domain name of the subprotocol\'s\noriginator.  For example, if Example Corporation were to create a\nChat subprotocol to be implemented by many servers around the Web,\nthey could name it "chat.example.com".  If the Example Organization\ncalled their competing subprotocol "chat.example.org", then the two\nsubprotocols could be implemented by servers simultaneously, with the\nserver dynamically selecting which subprotocol to use based on the\nvalue sent by the client.')]),e._v("\n"),t("p",[e._v('Subprotocols can be versioned in backward-incompatible ways by\nchanging the subprotocol name, e.g., going from\n"bookings.example.net" to "v2.bookings.example.net".  These\nsubprotocols would be considered completely separate by WebSocket\nclients.  Backward-compatible versioning can be implemented by\nreusing the same subprotocol string but carefully designing the\nactual subprotocol to support this kind of extensibility.')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_2-一致性要求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-一致性要求"}},[e._v("#")]),e._v(" 2. 一致性要求")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"2"}},[e._v("\n"),t("li",[e._v("Conformance Requirements")]),e._v("\n")]),e._v("\n"),t("p",[e._v("All diagrams, examples, and notes in this specification are non-\nnormative, as are all sections explicitly marked non-normative.\nEverything else in this specification is normative.")]),e._v("\n"),t("p",[e._v('The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this\ndocument are to be interpreted as described in [RFC2119].')]),e._v("\n"),t("p",[e._v('Requirements phrased in the imperative as part of algorithms (such as\n"strip any leading space characters" or "return false and abort these\nsteps") are to be interpreted with the meaning of the key word\n("MUST", "SHOULD", "MAY", etc.) used in introducing the algorithm.')]),e._v("\n"),t("p",[e._v("Conformance requirements phrased as algorithms or specific steps MAY\nbe implemented in any manner, so long as the end result is\nequivalent.  (In particular, the algorithms defined in this\nspecification are intended to be easy to follow and not intended to\nbe performant.)")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("2.1.  Terminology and Other Conventions")]),e._v("\n"),t("p",[t("em",[e._v("ASCII")]),e._v(" shall mean the character-encoding scheme defined in\n[ANSI.X3-4.1986].")]),e._v("\n"),t("p",[e._v("This document makes reference to UTF-8 values and uses UTF-8\nnotational formats as defined in STD 63 [RFC3629].")]),e._v("\n"),t("p",[e._v("Key terms such as named algorithms or definitions are indicated like\n"),t("em",[e._v("this")]),e._v(".")]),e._v("\n"),t("p",[e._v("Names of header fields or variables are indicated like |this|.")]),e._v("\n"),t("p",[e._v("Variable values are indicated like /this/.")]),e._v("\n"),t("p",[e._v("This document references the procedure to "),t("em",[e._v("Fail the WebSocket\nConnection")]),e._v(".  This procedure is defined in Section 7.1.7.")]),e._v("\n"),t("p",[t("em",[e._v("Converting a string to ASCII lowercase")]),e._v(" means replacing all\ncharacters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER\nA to LATIN CAPITAL LETTER Z) with the corresponding characters in the\nrange U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL\nLETTER Z).")]),e._v("\n"),t("p",[e._v("Comparing two strings in an "),t("em",[e._v("ASCII case-insensitive")]),e._v(" manner means\ncomparing them exactly, code point for code point, except that the\ncharacters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER\nA to LATIN CAPITAL LETTER Z) and the corresponding characters in the\nrange U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL\nLETTER Z) are considered to also match.")]),e._v("\n"),t("p",[e._v('The term "URI" is used in this document as defined in [RFC3986].')]),e._v("\n"),t("p",[e._v("When an implementation is required to "),t("em",[e._v("send")]),e._v(" data as part of the\nWebSocket Protocol, the implementation MAY delay the actual\ntransmission arbitrarily, e.g., buffering data so as to send fewer IP\npackets.")]),e._v("\n"),t("p",[e._v("Note that this document uses both [RFC5234] and [RFC2616] variants of\nABNF in different sections.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_3-websocket-uris"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-websocket-uris"}},[e._v("#")]),e._v(" 3.  WebSocket URIs")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"3"}},[e._v("\n"),t("li",[e._v("WebSocket URIs")]),e._v("\n")]),e._v("\n"),t("p",[e._v("This specification defines two URI schemes, using the ABNF syntax\ndefined in RFC 5234 [RFC5234], and terminology and ABNF productions\ndefined by the URI specification RFC 3986 [RFC3986].")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('      ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]\n      wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]\n\n      host = <host, defined in [RFC3986], Section 3.2.2>\n      port = <port, defined in [RFC3986], Section 3.2.3>\n      path = <path-abempty, defined in [RFC3986], Section 3.3>\n      query = <query, defined in [RFC3986], Section 3.4>\n')])])]),t("p",[e._v('The port component is OPTIONAL; the default for "ws" is port 80,\nwhile the default for "wss" is port 443.')]),e._v(" "),t("p",[e._v('The URI is called "secure" (and it is said that "the secure flag is\nset") if the scheme component matches "wss" case-insensitively.')]),e._v(" "),t("p",[e._v('The "resource-name" (also known as /resource name/ in Section 4.1)\ncan be constructed by concatenating the following:')]),e._v(" "),t("p",[e._v('o  "/" if the path component is empty')]),e._v(" "),t("p",[e._v("o  the path component")]),e._v(" "),t("p",[e._v('o  "?" if the query component is non-empty')]),e._v(" "),t("p",[e._v("o  the query component")]),e._v(" "),t("p",[e._v('Fragment identifiers are meaningless in the context of WebSocket URIs\nand MUST NOT be used on these URIs.  As with any URI scheme, the\ncharacter "#", when not indicating the start of a fragment, MUST be\nescaped as %23.')])])])]),e._v(" "),t("h2",{attrs:{id:"_4-开启握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-开启握手"}},[e._v("#")]),e._v(" 4. 开启握手")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"4"}},[e._v("\n"),t("li",[e._v("Opening Handshake")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("4.1.  Client Requirements")]),e._v("\n"),t("p",[e._v("To "),t("em",[e._v("Establish a WebSocket Connection")]),e._v(", a client opens a connection\nand sends a handshake as defined in this section.  A connection is\ndefined to initially be in a CONNECTING state.  A client will need to\nsupply a /host/, /port/, /resource name/, and a /secure/ flag, which\nare the components of a WebSocket URI as discussed in Section 3,\nalong with a list of /protocols/ and /extensions/ to be used.\nAdditionally, if the client is a web browser, it supplies /origin/.")]),e._v("\n"),t("p",[e._v("Clients running in controlled environments, e.g., browsers on mobile\nhandsets tied to specific carriers, MAY offload the management of the\nconnection to another agent on the network.  In such a situation, the\nclient for the purposes of this specification is considered to\ninclude both the handset software and any such agents.")]),e._v("\n"),t("p",[e._v("When the client is to "),t("em",[e._v("Establish a WebSocket Connection")]),e._v(' given a set\nof (/host/, /port/, /resource name/, and /secure/ flag), along with a\nlist of /protocols/ and /extensions/ to be used, and an /origin/ in\nthe case of web browsers, it MUST open a connection, send an opening\nhandshake, and read the server\'s handshake in response.  The exact\nrequirements of how the connection should be opened, what should be\nsent in the opening handshake, and how the server\'s response should\nbe interpreted are as follows in this section.  In the following\ntext, we will use terms from Section 3, such as "/host/" and\n"/secure/ flag" as defined in that section.')]),e._v("\n"),t("ol",[e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("The components of the WebSocket URI passed into this algorithm\n(/host/, /port/, /resource name/, and /secure/ flag) MUST be\nvalid according to the specification of WebSocket URIs specified\nin Section 3.  If any of the components are invalid, the client\nMUST "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(" and abort these steps.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("If the client already has a WebSocket connection to the remote\nhost (IP address) identified by /host/ and port /port/ pair, even\nif the remote host is known by another name, the client MUST wait\nuntil that connection has been established or for that connection\nto have failed.  There MUST be no more than one connection in a\nCONNECTING state.  If multiple connections to the same IP address\nare attempted simultaneously, the client MUST serialize them so\nthat there is no more than one connection at a time running\nthrough the following steps.")]),e._v("\n"),t("p",[e._v("If the client cannot determine the IP address of the remote host\n(for example, because all communication is being done through a\nproxy server that performs DNS queries itself), then the client\nMUST assume for the purposes of this step that each host name\nrefers to a distinct remote host, and instead the client SHOULD\nlimit the total number of simultaneous pending connections to a\nreasonably low number (e.g., the client might allow simultaneous\npending connections to a.example.com and b.example.com, but if\nthirty simultaneous connections to a single host are requested,\nthat may not be allowed).  For example, in a web browser context,\nthe client needs to consider the number of tabs the user has open\nin setting a limit to the number of simultaneous pending\nconnections.")]),e._v("\n"),t("p",[e._v("NOTE: This makes it harder for a script to perform a denial-of-\nservice attack by just opening a large number of WebSocket\nconnections to a remote host.  A server can further reduce the\nload on itself when attacked by pausing before closing the\nconnection, as that will reduce the rate at which the client\nreconnects.")]),e._v("\n"),t("p",[e._v("NOTE: There is no limit to the number of established WebSocket\nconnections a client can have with a single remote host.  Servers\ncan refuse to accept connections from hosts/IP addresses with an\nexcessive number of existing connections or disconnect resource-\nhogging connections when suffering high load.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[t("em",[e._v("Proxy Usage")]),e._v(": If the client is configured to use a proxy when\nusing the WebSocket Protocol to connect to host /host/ and port\n/port/, then the client SHOULD connect to that proxy and ask it\nto open a TCP connection to the host given by /host/ and the port\ngiven by /port/.")]),e._v("\n"),t("p",[e._v("EXAMPLE: For example, if the client uses an HTTP proxy for all\ntraffic, then if it was to try to connect to port 80 on server\nexample.com, it might send the following lines to the proxy\nserver:")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("   CONNECT example.com:80 HTTP/1.1\n   Host: example.com\n")])])]),t("p",[e._v("If there was a password, the connection might look like:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("   CONNECT example.com:80 HTTP/1.1\n   Host: example.com\n   Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=\n")])])]),t("p",[e._v("If the client is not configured to use a proxy, then a direct TCP\nconnection SHOULD be opened to the host given by /host/ and the\nport given by /port/.")]),e._v(" "),t("p",[e._v("NOTE: Implementations that do not expose explicit UI for\nselecting a proxy for WebSocket connections separate from other\nproxies are encouraged to use a SOCKS5 [RFC1928] proxy for\nWebSocket connections, if available, or failing that, to prefer\nthe proxy configured for HTTPS connections over the proxy\nconfigured for HTTP connections.")]),e._v(" "),t("p",[e._v("For the purpose of proxy autoconfiguration scripts, the URI to\npass the function MUST be constructed from /host/, /port/,\n/resource name/, and the /secure/ flag using the definition of a\nWebSocket URI as given in Section 3.")]),e._v(" "),t("p",[e._v('NOTE: The WebSocket Protocol can be identified in proxy\nautoconfiguration scripts from the scheme ("ws" for unencrypted\nconnections and "wss" for encrypted connections).')])]),e._v(" "),t("li",[t("p",[e._v("If the connection could not be opened, either because a direct\nconnection failed or because any proxy used returned an error,\nthen the client MUST "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(" and abort\nthe connection attempt.")])]),e._v(" "),t("li",[t("p",[e._v("If /secure/ is true, the client MUST perform a TLS handshake over\nthe connection after opening the connection and before sending\nthe handshake data [RFC2818].  If this fails (e.g., the server's\ncertificate could not be verified), then the client MUST "),t("em",[e._v("Fail\nthe WebSocket Connection")]),e._v(" and abort the connection.  Otherwise,\nall further communication on this channel MUST run through the\nencrypted tunnel [RFC5246].")]),e._v(" "),t("p",[e._v("Clients MUST use the Server Name Indication extension in the TLS\nhandshake [RFC6066].")])])]),e._v(" "),t("p",[e._v("Once a connection to the server has been established (including a\nconnection via a proxy or over a TLS-encrypted tunnel), the client\nMUST send an opening handshake to the server.  The handshake consists\nof an HTTP Upgrade request, along with a list of required and\noptional header fields.  The requirements for this handshake are as\nfollows.")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("The handshake MUST be a valid HTTP request as specified by\n[RFC2616].")])]),e._v(" "),t("li",[t("p",[e._v("The method of the request MUST be GET, and the HTTP version MUST\nbe at least 1.1.")]),e._v(" "),t("p",[e._v('For example, if the WebSocket URI is "ws://example.com/chat",\nthe first line sent should be "GET /chat HTTP/1.1".')])]),e._v(" "),t("li",[t("p",[e._v('The "Request-URI" part of the request MUST match the /resource\nname/ defined in Section 3 (a relative URI) or be an absolute\nhttp/https URI that, when parsed, has a /resource name/, /host/,\nand /port/ that match the corresponding ws/wss URI.')])]),e._v(" "),t("li",[t("p",[e._v('The request MUST contain a |Host| header field whose value\ncontains /host/ plus optionally ":" followed by /port/ (when not\nusing the default port).')])]),e._v(" "),t("li",[t("p",[e._v('The request MUST contain an |Upgrade| header field whose value\nMUST include the "websocket" keyword.')])]),e._v(" "),t("li",[t("p",[e._v('The request MUST contain a |Connection| header field whose value\nMUST include the "Upgrade" token.')])]),e._v(" "),t("li",[t("p",[e._v("The request MUST include a header field with the name\n|Sec-WebSocket-Key|.  The value of this header field MUST be a\nnonce consisting of a randomly selected 16-byte value that has\nbeen base64-encoded (see Section 4 of [RFC4648]).  The nonce\nMUST be selected randomly for each connection.")]),e._v(" "),t("p",[e._v('NOTE: As an example, if the randomly selected value was the\nsequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09\n0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header\nfield would be "AQIDBAUGBwgJCgsMDQ4PEC=="')])]),e._v(" "),t("li",[t("p",[e._v("The request MUST include a header field with the name |Origin|\n[RFC6454] if the request is coming from a browser client.  If\nthe connection is from a non-browser client, the request MAY\ninclude this header field if the semantics of that client match\nthe use-case described here for browser clients.  The value of\nthis header field is the ASCII serialization of origin of the\ncontext in which the code establishing the connection is\nrunning.  See [RFC6454] for the details of how this header field\nvalue is constructed.")]),e._v(" "),t("p",[e._v('As an example, if code downloaded from www.example.com attempts\nto establish a connection to ww2.example.com, the value of the\nheader field would be "http://www.example.com".')])]),e._v(" "),t("li",[t("p",[e._v("The request MUST include a header field with the name\n|Sec-WebSocket-Version|.  The value of this header field MUST be\n13.")]),e._v(" "),t("p",[e._v("NOTE: Although draft versions of this document (-09, -10, -11,\nand -12) were posted (they were mostly comprised of editorial\nchanges and clarifications and not changes to the wire\nprotocol), values 9, 10, 11, and 12 were not used as valid\nvalues for Sec-WebSocket-Version.  These values were reserved in\nthe IANA registry but were not and will not be used.")])]),e._v(" "),t("li",[t("p",[e._v("The request MAY include a header field with the name\n|Sec-WebSocket-Protocol|.  If present, this value indicates one\nor more comma-separated subprotocol the client wishes to speak,\nordered by preference.  The elements that comprise this value\nMUST be non-empty strings with characters in the range U+0021 to\nU+007E not including separator characters as defined in\n[RFC2616] and MUST all be unique strings.  The ABNF for the\nvalue of this header field is 1#token, where the definitions of\nconstructs and rules are as given in [RFC2616].")])]),e._v(" "),t("li",[t("p",[e._v("The request MAY include a header field with the name\n|Sec-WebSocket-Extensions|.  If present, this value indicates\nthe protocol-level extension(s) the client wishes to speak.  The\ninterpretation and format of this header field is described in\nSection 9.1.")])]),e._v(" "),t("li",[t("p",[e._v("The request MAY include any other header fields, for example,\ncookies [RFC6265] and/or authentication-related header fields\nsuch as the |Authorization| header field [RFC2616], which are\nprocessed according to documents that define them.")])])]),e._v(" "),t("p",[e._v("Once the client's opening handshake has been sent, the client MUST\nwait for a response from the server before sending any further data.\nThe client MUST validate the server's response as follows:")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("If the status code received from the server is not 101, the\nclient handles the response per HTTP [RFC2616] procedures.  In\nparticular, the client might perform authentication if it\nreceives a 401 status code; the server might redirect the client\nusing a 3xx status code (but clients are not required to follow\nthem), etc.  Otherwise, proceed as follows.")])]),e._v(" "),t("li",[t("p",[e._v('If the response lacks an |Upgrade| header field or the |Upgrade|\nheader field contains a value that is not an ASCII case-\ninsensitive match for the value "websocket", the client MUST\n'),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".")])]),e._v(" "),t("li",[t("p",[e._v('If the response lacks a |Connection| header field or the\n|Connection| header field doesn\'t contain a token that is an\nASCII case-insensitive match for the value "Upgrade", the client\nMUST '),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".")])]),e._v(" "),t("li",[t("p",[e._v('If the response lacks a |Sec-WebSocket-Accept| header field or\nthe |Sec-WebSocket-Accept| contains a value other than the\nbase64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\nKey| (as a string, not base64-decoded) with the string "258EAFA5-\nE914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and\ntrailing whitespace, the client MUST '),t("em",[e._v("Fail the WebSocket\nConnection")]),e._v(".")])]),e._v(" "),t("li",[t("p",[e._v("If the response includes a |Sec-WebSocket-Extensions| header\nfield and this header field indicates the use of an extension\nthat was not present in the client's handshake (the server has\nindicated an extension not requested by the client), the client\nMUST "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".  (The parsing of this\nheader field to determine which extensions are requested is\ndiscussed in Section 9.1.)")])]),e._v(" "),t("li",[t("p",[e._v("If the response includes a |Sec-WebSocket-Protocol| header field\nand this header field indicates the use of a subprotocol that was\nnot present in the client's handshake (the server has indicated a\nsubprotocol not requested by the client), the client MUST "),t("em",[e._v("Fail\nthe WebSocket Connection")]),e._v(".")])])]),e._v(" "),t("p",[e._v("If the server's response does not conform to the requirements for the\nserver's handshake as defined in this section and in Section 4.2.2,\nthe client MUST "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".")]),e._v(" "),t("p",[e._v("Please note that according to [RFC2616], all header field names in\nboth HTTP requests and HTTP responses are case-insensitive.")]),e._v(" "),t("p",[e._v("If the server's response is validated as provided for above, it is\nsaid that "),t("em",[e._v("The WebSocket Connection is Established")]),e._v(" and that the\nWebSocket Connection is in the OPEN state.  The "),t("em",[e._v("Extensions In Use")]),e._v("\nis defined to be a (possibly empty) string, the value of which is\nequal to the value of the |Sec-WebSocket-Extensions| header field\nsupplied by the server's handshake or the null value if that header\nfield was not present in the server's handshake.  The "),t("em",[e._v("Subprotocol In\nUse")]),e._v(" is defined to be the value of the |Sec-WebSocket-Protocol|\nheader field in the server's handshake or the null value if that\nheader field was not present in the server's handshake.\nAdditionally, if any header fields in the server's handshake indicate\nthat cookies should be set (as defined by [RFC6265]), these cookies\nare referred to as "),t("em",[e._v("Cookies Set During the Server's Opening\nHandshake")]),e._v(".")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("4.2.  Server-Side Requirements")]),e._v("\n"),t("p",[e._v("Servers MAY offload the management of the connection to other agents\non the network, for example, load balancers and reverse proxies.  In\nsuch a situation, the server for the purposes of this specification\nis considered to include all parts of the server-side infrastructure\nfrom the first device to terminate the TCP connection all the way to\nthe server that processes requests and sends responses.")]),e._v("\n"),t("p",[e._v('EXAMPLE: A data center might have a server that responds to WebSocket\nrequests with an appropriate handshake and then passes the connection\nto another server to actually process the data frames.  For the\npurposes of this specification, the "server" is the combination of\nboth computers.')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("4.2.1.  Reading the Client's Opening Handshake")]),e._v("\n"),t("p",[e._v("When a client starts a WebSocket connection, it sends its part of the\nopening handshake.  The server must parse at least part of this\nhandshake in order to obtain the necessary information to generate\nthe server part of the handshake.")]),e._v("\n"),t("p",[e._v("The client's opening handshake consists of the following parts.  If\nthe server, while reading the handshake, finds that the client did\nnot send a handshake that matches the description below (note that as\nper [RFC2616], the order of the header fields is not important),\nincluding but not limited to any violations of the ABNF grammar\nspecified for the components of the handshake, the server MUST stop\nprocessing the client's handshake and return an HTTP response with an\nappropriate error code (such as 400 Bad Request).")]),e._v("\n"),t("ol",[e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('An HTTP/1.1 or higher GET request, including a "Request-URI"\n[RFC2616] that should be interpreted as a /resource name/\ndefined in Section 3 (or an absolute HTTP/HTTPS URI containing\nthe /resource name/).')]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("A |Host| header field containing the server's authority.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('An |Upgrade| header field containing the value "websocket",\ntreated as an ASCII case-insensitive value.')]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('A |Connection| header field that includes the token "Upgrade",\ntreated as an ASCII case-insensitive value.')]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("A |Sec-WebSocket-Key| header field with a base64-encoded (see\nSection 4 of [RFC4648]) value that, when decoded, is 16 bytes in\nlength.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("A |Sec-WebSocket-Version| header field, with a value of 13.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("Optionally, an |Origin| header field.  This header field is sent\nby all browser clients.  A connection attempt lacking this\nheader field SHOULD NOT be interpreted as coming from a browser\nclient.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("Optionally, a |Sec-WebSocket-Protocol| header field, with a list\nof values indicating which protocols the client would like to\nspeak, ordered by preference.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("Optionally, a |Sec-WebSocket-Extensions| header field, with a\nlist of values indicating which extensions the client would like\nto speak.  The interpretation of this header field is discussed\nin Section 9.1.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("Optionally, other header fields, such as those used to send\ncookies or request authentication to a server.  Unknown header\nfields are ignored, as per [RFC2616].")]),e._v("\n")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("4.2.2.  Sending the Server's Opening Handshake")]),e._v("\n"),t("p",[e._v("When a client establishes a WebSocket connection to a server, the\nserver MUST complete the following steps to accept the connection and\nsend the server's opening handshake.")]),e._v("\n"),t("ol",[e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('If the connection is happening on an HTTPS (HTTP-over-TLS) port,\nperform a TLS handshake over the connection.  If this fails\n(e.g., the client indicated a host name in the extended client\nhello "server_name" extension that the server does not host),\nthen close the connection; otherwise, all further communication\nfor the connection (including the server\'s handshake) MUST run\nthrough the encrypted tunnel [RFC5246].')]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("The server can perform additional client authentication, for\nexample, by returning a 401 status code with the corresponding\n|WWW-Authenticate| header field as described in [RFC2616].")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("The server MAY redirect the client using a 3xx status code\n[RFC2616].  Note that this step can happen together with, before,\nor after the optional authentication step described above.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("Establish the following information:")]),e._v("\n"),t("p",[e._v("/origin/\nThe |Origin| header field in the client's handshake indicates\nthe origin of the script establishing the connection.  The\norigin is serialized to ASCII and converted to lowercase.  The\nserver MAY use this information as part of a determination of\nwhether to accept the incoming connection.  If the server does\nnot validate the origin, it will accept connections from\nanywhere.  If the server does not wish to accept this\nconnection, it MUST return an appropriate HTTP error code\n(e.g., 403 Forbidden) and abort the WebSocket handshake\ndescribed in this section.  For more detail, refer to\nSection 10.")]),e._v("\n"),t("p",[e._v("/key/\nThe |Sec-WebSocket-Key| header field in the client's handshake\nincludes a base64-encoded value that, if decoded, is 16 bytes\nin length.  This (encoded) value is used in the creation of\nthe server's handshake to indicate an acceptance of the\nconnection.  It is not necessary for the server to base64-\ndecode the |Sec-WebSocket-Key| value.")]),e._v("\n"),t("p",[e._v("/version/\nThe |Sec-WebSocket-Version| header field in the client's\nhandshake includes the version of the WebSocket Protocol with\nwhich the client is attempting to communicate.  If this\nversion does not match a version understood by the server, the\nserver MUST abort the WebSocket handshake described in this\nsection and instead send an appropriate HTTP error code (such\nas 426 Upgrade Required) and a |Sec-WebSocket-Version| header\nfield indicating the version(s) the server is capable of\nunderstanding.")]),e._v("\n"),t("p",[e._v('/resource name/\nAn identifier for the service provided by the server.  If the\nserver provides multiple services, then the value should be\nderived from the resource name given in the client\'s handshake\nin the "Request-URI" [RFC2616] of the GET method.  If the\nrequested service is not available, the server MUST send an\nappropriate HTTP error code (such as 404 Not Found) and abort\nthe WebSocket handshake.')]),e._v("\n"),t("p",[e._v("/subprotocol/\nEither a single value representing the subprotocol the server\nis ready to use or null.  The value chosen MUST be derived\nfrom the client's handshake, specifically by selecting one of\nthe values from the |Sec-WebSocket-Protocol| field that the\nserver is willing to use for this connection (if any).  If the\nclient's handshake did not contain such a header field or if\nthe server does not agree to any of the client's requested\nsubprotocols, the only acceptable value is null.  The absence\nof such a field is equivalent to the null value (meaning that\nif the server does not wish to agree to one of the suggested\nsubprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol|\nheader field in its response).  The empty string is not the\nsame as the null value for these purposes and is not a legal\nvalue for this field.  The ABNF for the value of this header\nfield is (token), where the definitions of constructs and\nrules are as given in [RFC2616].")]),e._v("\n"),t("p",[e._v("/extensions/\nA (possibly empty) list representing the protocol-level\nextensions the server is ready to use.  If the server supports\nmultiple extensions, then the value MUST be derived from the\nclient's handshake, specifically by selecting one or more of\nthe values from the |Sec-WebSocket-Extensions| field.  The\nabsence of such a field is equivalent to the null value.  The\nempty string is not the same as the null value for these\npurposes.  Extensions not listed by the client MUST NOT be\nlisted.  The method by which these values should be selected\nand interpreted is discussed in Section 9.1.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("If the server chooses to accept the incoming connection, it MUST\nreply with a valid HTTP response indicating the following.")]),e._v("\n"),t("ol",[e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('A Status-Line with a 101 response code as per RFC 2616\n[RFC2616].  Such a response could look like "HTTP/1.1 101\nSwitching Protocols".')]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('An |Upgrade| header field with value "websocket" as per RFC\n2616 [RFC2616].')]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('A |Connection| header field with value "Upgrade".')]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v('A |Sec-WebSocket-Accept| header field.  The value of this\nheader field is constructed by concatenating /key/, defined\nabove in step 4 in Section 4.2.2, with the string "258EAFA5-\nE914-47DA-95CA-C5AB0DC85B11", taking the SHA-1 hash of this\nconcatenated value to obtain a 20-byte value and base64-\nencoding (see Section 4 of [RFC4648]) this 20-byte hash.')]),e._v("\n"),t("p",[e._v("The ABNF [RFC2616] of this header field is defined as\nfollows:")]),e._v("\n"),t("p",[e._v('Sec-WebSocket-Accept     = base64-value-non-empty\nbase64-value-non-empty = (1*base64-data [ base64-padding ]) |\nbase64-padding\nbase64-data      = 4base64-character\nbase64-padding   = (2base64-character "==") |\n(3base64-character "=")\nbase64-character = ALPHA | DIGIT | "+" | "/"')]),e._v("\n")]),e._v("\n")]),e._v("\n")]),e._v("\n")]),e._v("\n"),t("p",[e._v('NOTE: As an example, if the value of the |Sec-WebSocket-Key| header\nfield in the client\'s handshake were "dGhlIHNhbXBsZSBub25jZQ==", the\nserver would append the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"\nto form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-\nC5AB0DC85B11".  The server would then take the SHA-1 hash of this\nstring, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90\n0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea.  This value\nis then base64-encoded, to give the value\n"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", which would be returned in the\n|Sec-WebSocket-Accept| header field.')]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("   5.  Optionally, a |Sec-WebSocket-Protocol| header field, with a\n       value /subprotocol/ as defined in step 4 in Section 4.2.2.\n\n   6.  Optionally, a |Sec-WebSocket-Extensions| header field, with a\n       value /extensions/ as defined in step 4 in Section 4.2.2.  If\n       multiple extensions are to be used, they can all be listed in\n       a single |Sec-WebSocket-Extensions| header field or split\n       between multiple instances of the |Sec-WebSocket-Extensions|\n       header field.\n")])])]),t("p",[e._v("This completes the server's handshake.  If the server finishes these\nsteps without aborting the WebSocket handshake, the server considers\nthe WebSocket connection to be established and that the WebSocket\nconnection is in the OPEN state.  At this point, the server may begin\nsending (and receiving) data.")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("4.3.  Collected ABNF for New Header Fields Used in Handshake")]),e._v("\n"),t("p",[e._v('This section is using ABNF syntax/rules from Section 2.1 of\n[RFC2616], including the "implied *LWS rule".')]),e._v("\n"),t("p",[e._v('Note that the following ABNF conventions are used in this section.\nSome names of the rules correspond to names of the corresponding\nheader fields.  Such rules express values of the corresponding header\nfields, for example, the Sec-WebSocket-Key ABNF rule describes syntax\nof the |Sec-WebSocket-Key| header field value.  ABNF rules with the\n"-Client" suffix in the name are only used in requests sent by the\nclient to the server; ABNF rules with the "-Server" suffix in the\nname are only used in responses sent by the server to the client.\nFor example, the ABNF rule Sec-WebSocket-Protocol-Client describes\nsyntax of the |Sec-WebSocket-Protocol| header field value sent by the\nclient to the server.')]),e._v("\n"),t("p",[e._v("The following new header fields can be sent during the handshake from\nthe client to the server:")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  Sec-WebSocket-Key = base64-value-non-empty\n  Sec-WebSocket-Extensions = extension-list\n  Sec-WebSocket-Protocol-Client = 1#token\n  Sec-WebSocket-Version-Client = version\n\n  base64-value-non-empty = (1*base64-data [ base64-padding ]) |\n                            base64-padding\n  base64-data      = 4base64-character\n  base64-padding   = (2base64-character "==") |\n                     (3base64-character "=")\n  base64-character = ALPHA | DIGIT | "+" | "/"\n  extension-list = 1#extension\n  extension = extension-token *( ";" extension-param )\n  extension-token = registered-token\n  registered-token = token\n\n  extension-param = token [ "=" (token | quoted-string) ]\n       ; When using the quoted-string syntax variant, the value\n       ; after quoted-string unescaping MUST conform to the\n       ; \'token\' ABNF.\n  NZDIGIT       =  "1" | "2" | "3" | "4" | "5" | "6" |\n                   "7" | "8" | "9"\n  version = DIGIT | (NZDIGIT DIGIT) |\n            ("1" DIGIT DIGIT) | ("2" DIGIT DIGIT)\n            ; Limited to 0-255 range, with no leading zeros\n')])])]),t("p",[e._v("The following new header fields can be sent during the handshake from\nthe server to the client:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Sec-WebSocket-Extensions = extension-list\n  Sec-WebSocket-Accept     = base64-value-non-empty\n  Sec-WebSocket-Protocol-Server = token\n  Sec-WebSocket-Version-Server = 1#version\n")])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("4.4.  Supporting Multiple Versions of WebSocket Protocol")]),e._v("\n"),t("p",[e._v("This section provides some guidance on supporting multiple versions\nof the WebSocket Protocol in clients and servers.")]),e._v("\n"),t("p",[e._v("Using the WebSocket version advertisement capability (the\n|Sec-WebSocket-Version| header field), a client can initially request\nthe version of the WebSocket Protocol that it prefers (which doesn't\nnecessarily have to be the latest supported by the client).  If the\nserver supports the requested version and the handshake message is\notherwise valid, the server will accept that version.  If the server\ndoesn't support the requested version, it MUST respond with a\n|Sec-WebSocket-Version| header field (or multiple\n|Sec-WebSocket-Version| header fields) containing all versions it is\nwilling to use.  At this point, if the client supports one of the\nadvertised versions, it can repeat the WebSocket handshake using a\nnew version value.")]),e._v("\n"),t("p",[e._v("The following example demonstrates version negotiation described\nabove:")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  GET /chat HTTP/1.1\n  Host: server.example.com\n  Upgrade: websocket\n  Connection: Upgrade\n  ...\n  Sec-WebSocket-Version: 25\n")])])]),t("p",[e._v("The response from the server might look as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  HTTP/1.1 400 Bad Request\n  ...\n  Sec-WebSocket-Version: 13, 8, 7\n")])])]),t("p",[e._v("Note that the last response from the server might also look like:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  HTTP/1.1 400 Bad Request\n  ...\n  Sec-WebSocket-Version: 13\n  Sec-WebSocket-Version: 8, 7\n")])])]),t("p",[e._v("The client now repeats the handshake that conforms to version 13:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  GET /chat HTTP/1.1\n  Host: server.example.com\n  Upgrade: websocket\n  Connection: Upgrade\n  ...\n  Sec-WebSocket-Version: 13\n")])])])])])]),e._v(" "),t("h2",{attrs:{id:"_5-数据帧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据帧"}},[e._v("#")]),e._v(" 5. 数据帧")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"5"}},[e._v("\n"),t("li",[e._v("Data Framing")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.1.  Overview")]),e._v("\n"),t("p",[e._v("In the WebSocket Protocol, data is transmitted using a sequence of\nframes.  To avoid confusing network intermediaries (such as\nintercepting proxies) and for security reasons that are further\ndiscussed in Section 10.3, a client MUST mask all frames that it\nsends to the server (see Section 5.3 for further details).  (Note\nthat masking is done whether or not the WebSocket Protocol is running\nover TLS.)  The server MUST close the connection upon receiving a\nframe that is not masked.  In this case, a server MAY send a Close\nframe with a status code of 1002 (protocol error) as defined in\nSection 7.4.1.  A server MUST NOT mask any frames that it sends to\nthe client.  A client MUST close a connection if it detects a masked\nframe.  In this case, it MAY use the status code 1002 (protocol\nerror) as defined in Section 7.4.1.  (These rules might be relaxed in\na future specification.)")]),e._v("\n"),t("p",[e._v('The base framing protocol defines a frame type with an opcode, a\npayload length, and designated locations for "Extension data" and\n"Application data", which together define the "Payload data".\nCertain bits and opcodes are reserved for future expansion of the\nprotocol.')]),e._v("\n"),t("p",[e._v("A data frame MAY be transmitted by either the client or the server at\nany time after opening handshake completion and before that endpoint\nhas sent a Close frame (Section 5.5.1).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.2.  Base Framing Protocol")]),e._v("\n"),t("p",[e._v("This wire format for the data transfer part is described by the ABNF\n[RFC5234] given in detail in this section.  (Note that, unlike in\nother sections of this document, the ABNF in this section is\noperating on groups of bits.  The length of each group of bits is\nindicated in a comment.  When encoded on the wire, the most\nsignificant bit is the leftmost in the ABNF).  A high-level overview\nof the framing is given in the following figure.  In a case of\nconflict between the figure below and the ABNF specified later in\nthis section, the figure is authoritative.")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-------+-+-------------+-------------------------------+\n |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n | |1|2|3|       |K|             |                               |\n +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n |     Extended payload length continued, if payload len == 127  |\n + - - - - - - - - - - - - - - - +-------------------------------+\n |                               |Masking-key, if MASK set to 1  |\n +-------------------------------+-------------------------------+\n | Masking-key (continued)       |          Payload Data         |\n +-------------------------------- - - - - - - - - - - - - - - - +\n :                     Payload Data continued ...                :\n + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n |                     Payload Data continued ...                |\n +---------------------------------------------------------------+\n")])])]),t("p",[e._v("FIN:  1 bit")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Indicates that this is the final fragment in a message.  The first\n  fragment MAY also be the final fragment.\n")])])]),t("p",[e._v("RSV1, RSV2, RSV3:  1 bit each")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  MUST be 0 unless an extension is negotiated that defines meanings\n  for non-zero values.  If a nonzero value is received and none of\n  the negotiated extensions defines the meaning of such a nonzero\n  value, the receiving endpoint MUST _Fail the WebSocket\n  Connection_.\n")])])]),t("p",[e._v("Opcode:  4 bits")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  Defines the interpretation of the "Payload data".  If an unknown\n  opcode is received, the receiving endpoint MUST _Fail the\n  WebSocket Connection_.  The following values are defined.\n\n  *  %x0 denotes a continuation frame\n\n  *  %x1 denotes a text frame\n\n  *  %x2 denotes a binary frame\n\n  *  %x3-7 are reserved for further non-control frames\n\n  *  %x8 denotes a connection close\n\n  *  %x9 denotes a ping\n\n  *  %xA denotes a pong\n\n  *  %xB-F are reserved for further control frames\n')])])]),t("p",[e._v("Mask:  1 bit")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  Defines whether the "Payload data" is masked.  If set to 1, a\n  masking key is present in masking-key, and this is used to unmask\n  the "Payload data" as per Section 5.3.  All frames sent from\n  client to server have this bit set to 1.\n')])])]),t("p",[e._v("Payload length:  7 bits, 7+16 bits, or 7+64 bits")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  The length of the "Payload data", in bytes: if 0-125, that is the\n  payload length.  If 126, the following 2 bytes interpreted as a\n  16-bit unsigned integer are the payload length.  If 127, the\n  following 8 bytes interpreted as a 64-bit unsigned integer (the\n  most significant bit MUST be 0) are the payload length.  Multibyte\n  length quantities are expressed in network byte order.  Note that\n  in all cases, the minimal number of bytes MUST be used to encode\n  the length, for example, the length of a 124-byte-long string\n  can\'t be encoded as the sequence 126, 0, 124.  The payload length\n  is the length of the "Extension data" + the length of the\n  "Application data".  The length of the "Extension data" may be\n  zero, in which case the payload length is the length of the\n  "Application data".\n')])])]),t("p",[e._v("Masking-key:  0 or 4 bytes")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  All frames sent from the client to the server are masked by a\n  32-bit value that is contained within the frame.  This field is\n  present if the mask bit is set to 1 and is absent if the mask bit\n  is set to 0.  See Section 5.3 for further information on client-\n  to-server masking.\n")])])]),t("p",[e._v("Payload data:  (x+y) bytes")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  The "Payload data" is defined as "Extension data" concatenated\n  with "Application data".\n')])])]),t("p",[e._v("Extension data:  x bytes")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  The "Extension data" is 0 bytes unless an extension has been\n  negotiated.  Any extension MUST specify the length of the\n  "Extension data", or how that length may be calculated, and how\n  the extension use MUST be negotiated during the opening handshake.\n  If present, the "Extension data" is included in the total payload\n  length.\n')])])]),t("p",[e._v("Application data:  y bytes")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  Arbitrary "Application data", taking up the remainder of the frame\n  after any "Extension data".  The length of the "Application data"\n  is equal to the payload length minus the length of the "Extension\n  data".\n')])])]),t("p",[e._v('The base framing protocol is formally defined by the following ABNF\n[RFC5234].  It is important to note that the representation of this\ndata is binary, not ASCII characters.  As such, a field with a length\nof 1 bit that takes values %x0 / %x1 is represented as a single bit\nwhose value is 0 or 1, not a full byte (octet) that stands for the\ncharacters "0" or "1" in the ASCII encoding.  A field with a length\nof 4 bits with values between %x0-F again is represented by 4 bits,\nagain NOT by an ASCII character or full byte (octet) with these\nvalues.  [RFC5234] does not specify a character encoding: "Rules\nresolve into a string of terminal values, sometimes called\ncharacters.  In ABNF, a character is merely a non-negative integer.\nIn certain contexts, a specific mapping (encoding) of values into a\ncharacter set (such as ASCII) will be specified."  Here, the\nspecified encoding is a binary encoding where each terminal value is\nencoded in the specified number of bits, which varies for each field.')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("ws-frame                = frame-fin           ; 1 bit in length\n                          frame-rsv1          ; 1 bit in length\n                          frame-rsv2          ; 1 bit in length\n                          frame-rsv3          ; 1 bit in length\n                          frame-opcode        ; 4 bits in length\n                          frame-masked        ; 1 bit in length\n                          frame-payload-length   ; either 7, 7+16,\n                                                 ; or 7+64 bits in\n                                                 ; length\n                          [ frame-masking-key ]  ; 32 bits in length\n                          frame-payload-data     ; n*8 bits in\n                                                 ; length, where\n                                                 ; n >= 0\n\nframe-fin               = %x0 ; more frames of this message follow\n                        / %x1 ; final frame of this message\n                              ; 1 bit in length\n\nframe-rsv1              = %x0 / %x1\n                          ; 1 bit in length, MUST be 0 unless\n                          ; negotiated otherwise\n\nframe-rsv2              = %x0 / %x1\n                          ; 1 bit in length, MUST be 0 unless\n                          ; negotiated otherwise\n\nframe-rsv3              = %x0 / %x1\n                          ; 1 bit in length, MUST be 0 unless\n                          ; negotiated otherwise\n\nframe-opcode            = frame-opcode-non-control /\n                          frame-opcode-control /\n                          frame-opcode-cont\n\nframe-opcode-cont       = %x0 ; frame continuation\n\nframe-opcode-non-control= %x1 ; text frame\n                        / %x2 ; binary frame\n                        / %x3-7\n                        ; 4 bits in length,\n                        ; reserved for further non-control frames\n\nframe-opcode-control    = %x8 ; connection close\n                        / %x9 ; ping\n                        / %xA ; pong\n                        / %xB-F ; reserved for further control\n                                ; frames\n                                ; 4 bits in length\n\nframe-masked            = %x0\n                        ; frame is not masked, no frame-masking-key\n                        / %x1\n                        ; frame is masked, frame-masking-key present\n                        ; 1 bit in length\n\nframe-payload-length    = ( %x00-7D )\n                        / ( %x7E frame-payload-length-16 )\n                        / ( %x7F frame-payload-length-63 )\n                        ; 7, 7+16, or 7+64 bits in length,\n                        ; respectively\n\nframe-payload-length-16 = %x0000-FFFF ; 16 bits in length\n\nframe-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF\n                        ; 64 bits in length\n\nframe-masking-key       = 4( %x00-FF )\n                          ; present only if frame-masked is 1\n                          ; 32 bits in length\n\nframe-payload-data      = (frame-masked-extension-data\n                           frame-masked-application-data)\n                        ; when frame-masked is 1\n                          / (frame-unmasked-extension-data\n                            frame-unmasked-application-data)\n                        ; when frame-masked is 0\n\nframe-masked-extension-data     = *( %x00-FF )\n                        ; reserved for future extensibility\n                        ; n*8 bits in length, where n >= 0\n\nframe-masked-application-data   = *( %x00-FF )\n                        ; n*8 bits in length, where n >= 0\n\nframe-unmasked-extension-data   = *( %x00-FF )\n                        ; reserved for future extensibility\n                        ; n*8 bits in length, where n >= 0\n\nframe-unmasked-application-data = *( %x00-FF )\n                        ; n*8 bits in length, where n >= 0\n")])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.3.  Client-to-Server Masking")]),e._v("\n"),t("p",[e._v("A masked frame MUST have the field frame-masked set to 1, as defined\nin Section 5.2.")]),e._v("\n"),t("p",[e._v('The masking key is contained completely within the frame, as defined\nin Section 5.2 as frame-masking-key.  It is used to mask the "Payload\ndata" defined in the same section as frame-payload-data, which\nincludes "Extension data" and "Application data".')]),e._v("\n"),t("p",[e._v("The masking key is a 32-bit value chosen at random by the client.\nWhen preparing a masked frame, the client MUST pick a fresh masking\nkey from the set of allowed 32-bit values.  The masking key needs to\nbe unpredictable; thus, the masking key MUST be derived from a strong\nsource of entropy, and the masking key for a given frame MUST NOT\nmake it simple for a server/proxy to predict the masking key for a\nsubsequent frame.  The unpredictability of the masking key is\nessential to prevent authors of malicious applications from selecting\nthe bytes that appear on the wire.  RFC 4086 [RFC4086] discusses what\nentails a suitable source of entropy for security-sensitive\napplications.")]),e._v("\n"),t("p",[e._v('The masking does not affect the length of the "Payload data".  To\nconvert masked data into unmasked data, or vice versa, the following\nalgorithm is applied.  The same algorithm applies regardless of the\ndirection of the translation, e.g., the same steps are applied to\nmask the data as to unmask the data.')]),e._v("\n"),t("p",[e._v('Octet i of the transformed data ("transformed-octet-i") is the XOR of\noctet i of the original data ("original-octet-i") with octet at index\ni modulo 4 of the masking key ("masking-key-octet-j"):')]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" j                   = i MOD 4\n transformed-octet-i = original-octet-i XOR masking-key-octet-j\n")])])]),t("p",[e._v('The payload length, indicated in the framing as frame-payload-length,\ndoes NOT include the length of the masking key.  It is the length of\nthe "Payload data", e.g., the number of bytes following the masking\nkey.')])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.4.  Fragmentation")]),e._v("\n"),t("p",[e._v("The primary purpose of fragmentation is to allow sending a message\nthat is of unknown size when the message is started without having to\nbuffer that message.  If messages couldn't be fragmented, then an\nendpoint would have to buffer the entire message so its length could\nbe counted before the first byte is sent.  With fragmentation, a\nserver or intermediary may choose a reasonable size buffer and, when\nthe buffer is full, write a fragment to the network.")]),e._v("\n"),t("p",[e._v("A secondary use-case for fragmentation is for multiplexing, where it\nis not desirable for a large message on one logical channel to\nmonopolize the output channel, so the multiplexing needs to be free\nto split the message into smaller fragments to better share the\noutput channel.  (Note that the multiplexing extension is not\ndescribed in this document.)")]),e._v("\n"),t("p",[e._v("Unless specified otherwise by an extension, frames have no semantic\nmeaning.  An intermediary might coalesce and/or split frames, if no\nextensions were negotiated by the client and the server or if some\nextensions were negotiated, but the intermediary understood all the\nextensions negotiated and knows how to coalesce and/or split frames\nin the presence of these extensions.  One implication of this is that\nin absence of extensions, senders and receivers must not depend on\nthe presence of specific frame boundaries.")]),e._v("\n"),t("p",[e._v("The following rules apply to fragmentation:")]),e._v("\n"),t("p",[e._v("o  An unfragmented message consists of a single frame with the FIN\nbit set (Section 5.2) and an opcode other than 0.")]),e._v("\n"),t("p",[e._v('o  A fragmented message consists of a single frame with the FIN bit\nclear and an opcode other than 0, followed by zero or more frames\nwith the FIN bit clear and the opcode set to 0, and terminated by\na single frame with the FIN bit set and an opcode of 0.  A\nfragmented message is conceptually equivalent to a single larger\nmessage whose payload is equal to the concatenation of the\npayloads of the fragments in order; however, in the presence of\nextensions, this may not hold true as the extension defines the\ninterpretation of the "Extension data" present.  For instance,\n"Extension data" may only be present at the beginning of the first\nfragment and apply to subsequent fragments, or there may be\n"Extension data" present in each of the fragments that applies\nonly to that particular fragment.  In the absence of "Extension\ndata", the following example demonstrates how fragmentation works.')]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  EXAMPLE: For a text message sent as three fragments, the first\n  fragment would have an opcode of 0x1 and a FIN bit clear, the\n  second fragment would have an opcode of 0x0 and a FIN bit clear,\n  and the third fragment would have an opcode of 0x0 and a FIN bit\n  that is set.\n")])])]),t("p",[e._v("o  Control frames (see Section 5.5) MAY be injected in the middle of\na fragmented message.  Control frames themselves MUST NOT be\nfragmented.")]),e._v(" "),t("p",[e._v("o  Message fragments MUST be delivered to the recipient in the order\nsent by the sender.")]),e._v(" "),t("p",[e._v("o  The fragments of one message MUST NOT be interleaved between the\nfragments of another message unless an extension has been\nnegotiated that can interpret the interleaving.")]),e._v(" "),t("p",[e._v("o  An endpoint MUST be capable of handling control frames in the\nmiddle of a fragmented message.")]),e._v(" "),t("p",[e._v("o  A sender MAY create fragments of any size for non-control\nmessages.")]),e._v(" "),t("p",[e._v("o  Clients and servers MUST support receiving both fragmented and\nunfragmented messages.")]),e._v(" "),t("p",[e._v("o  As control frames cannot be fragmented, an intermediary MUST NOT\nattempt to change the fragmentation of a control frame.")]),e._v(" "),t("p",[e._v("o  An intermediary MUST NOT change the fragmentation of a message if\nany reserved bit values are used and the meaning of these values\nis not known to the intermediary.")]),e._v(" "),t("p",[e._v("o  An intermediary MUST NOT change the fragmentation of any message\nin the context of a connection where extensions have been\nnegotiated and the intermediary is not aware of the semantics of\nthe negotiated extensions.  Similarly, an intermediary that didn't\nsee the WebSocket handshake (and wasn't notified about its\ncontent) that resulted in a WebSocket connection MUST NOT change\nthe fragmentation of any message of such connection.")]),e._v(" "),t("p",[e._v("o  As a consequence of these rules, all fragments of a message are of\nthe same type, as set by the first fragment's opcode.  Since\ncontrol frames cannot be fragmented, the type for all fragments in\na message MUST be either text, binary, or one of the reserved\nopcodes.")]),e._v(" "),t("p",[e._v("NOTE: If control frames could not be interjected, the latency of a\nping, for example, would be very long if behind a large message.\nHence, the requirement of handling control frames in the middle of a\nfragmented message.")]),e._v(" "),t("p",[e._v("IMPLEMENTATION NOTE: In the absence of any extension, a receiver\ndoesn't have to buffer the whole frame in order to process it.  For\nexample, if a streaming API is used, a part of a frame can be\ndelivered to the application.  However, note that this assumption\nmight not hold true for all future WebSocket extensions.")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.5.  Control Frames")]),e._v("\n"),t("p",[e._v("Control frames are identified by opcodes where the most significant\nbit of the opcode is 1.  Currently defined opcodes for control frames\ninclude 0x8 (Close), 0x9 (Ping), and 0xA (Pong).  Opcodes 0xB-0xF are\nreserved for further control frames yet to be defined.")]),e._v("\n"),t("p",[e._v("Control frames are used to communicate state about the WebSocket.\nControl frames can be interjected in the middle of a fragmented\nmessage.")]),e._v("\n"),t("p",[e._v("All control frames MUST have a payload length of 125 bytes or less\nand MUST NOT be fragmented.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.5.1.  Close")]),e._v("\n"),t("p",[e._v("The Close frame contains an opcode of 0x8.")]),e._v("\n"),t("p",[e._v('The Close frame MAY contain a body (the "Application data" portion of\nthe frame) that indicates a reason for closing, such as an endpoint\nshutting down, an endpoint having received a frame too large, or an\nendpoint having received a frame that does not conform to the format\nexpected by the endpoint.  If there is a body, the first two bytes of\nthe body MUST be a 2-byte unsigned integer (in network byte order)\nrepresenting a status code with value /code/ defined in Section 7.4.\nFollowing the 2-byte integer, the body MAY contain UTF-8-encoded data\nwith value /reason/, the interpretation of which is not defined by\nthis specification.  This data is not necessarily human readable but\nmay be useful for debugging or passing information relevant to the\nscript that opened the connection.  As the data is not guaranteed to\nbe human readable, clients MUST NOT show it to end users.')]),e._v("\n"),t("p",[e._v("Close frames sent from client to server must be masked as per\nSection 5.3.")]),e._v("\n"),t("p",[e._v("The application MUST NOT send any more data frames after sending a\nClose frame.")]),e._v("\n"),t("p",[e._v("If an endpoint receives a Close frame and did not previously send a\nClose frame, the endpoint MUST send a Close frame in response.  (When\nsending a Close frame in response, the endpoint typically echos the\nstatus code it received.)  It SHOULD do so as soon as practical.  An\nendpoint MAY delay sending a Close frame until its current message is\nsent (for instance, if the majority of a fragmented message is\nalready sent, an endpoint MAY send the remaining fragments before\nsending a Close frame).  However, there is no guarantee that the\nendpoint that has already sent a Close frame will continue to process\ndata.")]),e._v("\n"),t("p",[e._v("After both sending and receiving a Close message, an endpoint\nconsiders the WebSocket connection closed and MUST close the\nunderlying TCP connection.  The server MUST close the underlying TCP\nconnection immediately; the client SHOULD wait for the server to\nclose the connection but MAY close the connection at any time after\nsending and receiving a Close message, e.g., if it has not received a\nTCP Close from the server in a reasonable time period.")]),e._v("\n"),t("p",[e._v("If a client and server both send a Close message at the same time,\nboth endpoints will have sent and received a Close message and should\nconsider the WebSocket connection closed and close the underlying TCP\nconnection.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.5.2.  Ping")]),e._v("\n"),t("p",[e._v("The Ping frame contains an opcode of 0x9.")]),e._v("\n"),t("p",[e._v('A Ping frame MAY include "Application data".')]),e._v("\n"),t("p",[e._v("Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\nresponse, unless it already received a Close frame.  It SHOULD\nrespond with Pong frame as soon as is practical.  Pong frames are\ndiscussed in Section 5.5.3.")]),e._v("\n"),t("p",[e._v("An endpoint MAY send a Ping frame any time after the connection is\nestablished and before the connection is closed.")]),e._v("\n"),t("p",[e._v("NOTE: A Ping frame may serve either as a keepalive or as a means to\nverify that the remote endpoint is still responsive.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.5.3.  Pong")]),e._v("\n"),t("p",[e._v("The Pong frame contains an opcode of 0xA.")]),e._v("\n"),t("p",[e._v("Section 5.5.2 details requirements that apply to both Ping and Pong\nframes.")]),e._v("\n"),t("p",[e._v('A Pong frame sent in response to a Ping frame must have identical\n"Application data" as found in the message body of the Ping frame\nbeing replied to.')]),e._v("\n"),t("p",[e._v("If an endpoint receives a Ping frame and has not yet sent Pong\nframe(s) in response to previous Ping frame(s), the endpoint MAY\nelect to send a Pong frame for only the most recently processed Ping\nframe.")]),e._v("\n"),t("p",[e._v("A Pong frame MAY be sent unsolicited.  This serves as a\nunidirectional heartbeat.  A response to an unsolicited Pong frame is\nnot expected.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.6.  Data Frames")]),e._v("\n"),t("p",[e._v("Data frames (e.g., non-control frames) are identified by opcodes\nwhere the most significant bit of the opcode is 0.  Currently defined\nopcodes for data frames include 0x1 (Text), 0x2 (Binary).  Opcodes\n0x3-0x7 are reserved for further non-control frames yet to be\ndefined.")]),e._v("\n"),t("p",[e._v("Data frames carry application-layer and/or extension-layer data.  The\nopcode determines the interpretation of the data:")]),e._v("\n"),t("p",[e._v("Text")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  The "Payload data" is text data encoded as UTF-8.  Note that a\n  particular text frame might include a partial UTF-8 sequence;\n  however, the whole message MUST contain valid UTF-8.  Invalid\n  UTF-8 in reassembled messages is handled as described in\n  Section 8.1.\n')])])]),t("p",[e._v("Binary")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  The "Payload data" is arbitrary binary data whose interpretation\n  is solely up to the application layer.\n')])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.7.  Examples")]),e._v("\n"),t("p",[e._v("o  A single-frame unmasked text message")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  *  0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains "Hello")\n')])])]),t("p",[e._v("o  A single-frame masked text message")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  *  0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58\n     (contains "Hello")\n')])])]),t("p",[e._v("o  A fragmented unmasked text message")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  *  0x01 0x03 0x48 0x65 0x6c (contains "Hel")\n\n  *  0x80 0x02 0x6c 0x6f (contains "lo")\n')])])]),t("p",[e._v("o  Unmasked Ping request and masked Ping response")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  *  0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of "Hello",\n     but the contents of the body are arbitrary)\n\n  *  0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58\n     (contains a body of "Hello", matching the body of the ping)\n')])])]),t("p",[e._v("o  256 bytes binary message in a single unmasked frame")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  *  0x82 0x7E 0x0100 [256 bytes of binary data]\n")])])]),t("p",[e._v("o  64KiB binary message in a single unmasked frame")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  *  0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]\n")])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("5.8.  Extensibility")]),e._v("\n"),t("p",[e._v('The protocol is designed to allow for extensions, which will add\ncapabilities to the base protocol.  The endpoints of a connection\nMUST negotiate the use of any extensions during the opening\nhandshake.  This specification provides opcodes 0x3 through 0x7 and\n0xB through 0xF, the "Extension data" field, and the frame-rsv1,\nframe-rsv2, and frame-rsv3 bits of the frame header for use by\nextensions.  The negotiation of extensions is discussed in further\ndetail in Section 9.1.  Below are some anticipated uses of\nextensions.  This list is neither complete nor prescriptive.')]),e._v("\n"),t("p",[e._v('o  "Extension data" may be placed in the "Payload data" before the\n"Application data".')]),e._v("\n"),t("p",[e._v("o  Reserved bits can be allocated for per-frame needs.")]),e._v("\n"),t("p",[e._v("o  Reserved opcode values can be defined.")]),e._v("\n"),t("p",[e._v("o  Reserved bits can be allocated to the opcode field if more opcode\nvalues are needed.")]),e._v("\n"),t("p",[e._v('o  A reserved bit or an "extension" opcode can be defined that\nallocates additional bits out of the "Payload data" to define\nlarger opcodes or more per-frame bits.')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_6-发送和接受数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-发送和接受数据"}},[e._v("#")]),e._v(" 6. 发送和接受数据")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"6"}},[e._v("\n"),t("li",[e._v("Sending and Receiving Data")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("6.1.  Sending Data")]),e._v("\n"),t("p",[e._v("To "),t("em",[e._v("Send a WebSocket Message")]),e._v(" comprising of /data/ over a WebSocket\nconnection, an endpoint MUST perform the following steps.")]),e._v("\n"),t("ol",[e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("The endpoint MUST ensure the WebSocket connection is in the OPEN\nstate (cf. Sections 4.1 and 4.2.2.)  If at any point the state of\nthe WebSocket connection changes, the endpoint MUST abort the\nfollowing steps.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("An endpoint MUST encapsulate the /data/ in a WebSocket frame as\ndefined in Section 5.2.  If the data to be sent is large or if\nthe data is not available in its entirety at the point the\nendpoint wishes to begin sending the data, the endpoint MAY\nalternately encapsulate the data in a series of frames as defined\nin Section 5.4.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("The opcode (frame-opcode) of the first frame containing the data\nMUST be set to the appropriate value from Section 5.2 for data\nthat is to be interpreted by the recipient as text or binary\ndata.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("The FIN bit (frame-fin) of the last frame containing the data\nMUST be set to 1 as defined in Section 5.2.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("If the data is being sent by the client, the frame(s) MUST be\nmasked as defined in Section 5.3.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("If any extensions (Section 9) have been negotiated for the\nWebSocket connection, additional considerations may apply as per\nthe definition of those extensions.")]),e._v("\n")]),e._v("\n"),t("li",[e._v("\n"),t("p",[e._v("The frame(s) that have been formed MUST be transmitted over the\nunderlying network connection.")]),e._v("\n")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("6.2.  Receiving Data")]),e._v("\n"),t("p",[e._v('To receive WebSocket data, an endpoint listens on the underlying\nnetwork connection.  Incoming data MUST be parsed as WebSocket frames\nas defined in Section 5.2.  If a control frame (Section 5.5) is\nreceived, the frame MUST be handled as defined by Section 5.5.  Upon\nreceiving a data frame (Section 5.6), the endpoint MUST note the\n/type/ of the data as defined by the opcode (frame-opcode) from\nSection 5.2.  The "Application data" from this frame is defined as\nthe /data/ of the message.  If the frame comprises an unfragmented\nmessage (Section 5.4), it is said that '),t("em",[e._v("A WebSocket Message Has Been\nReceived")]),e._v(' with type /type/ and data /data/.  If the frame is part of\na fragmented message, the "Application data" of the subsequent data\nframes is concatenated to form the /data/.  When the last fragment is\nreceived as indicated by the FIN bit (frame-fin), it is said that '),t("em",[e._v("A\nWebSocket Message Has Been Received")]),e._v(' with data /data/ (comprised of\nthe concatenation of the "Application data" of the fragments) and\ntype /type/ (noted from the first frame of the fragmented message).\nSubsequent data frames MUST be interpreted as belonging to a new\nWebSocket message.')]),e._v("\n"),t("p",[e._v('Extensions (Section 9) MAY change the semantics of how data is read,\nspecifically including what comprises a message boundary.\nExtensions, in addition to adding "Extension data" before the\n"Application data" in a payload, MAY also modify the "Application\ndata" (such as by compressing it).')]),e._v("\n"),t("p",[e._v("A server MUST remove masking for data frames received from a client\nas described in Section 5.3.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_7-关闭连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-关闭连接"}},[e._v("#")]),e._v(" 7. 关闭连接")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"7"}},[e._v("\n"),t("li",[e._v("Closing the Connection")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.  Definitions")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.1.  Close the WebSocket Connection")]),e._v("\n"),t("p",[e._v("To "),t("em",[e._v("Close the WebSocket Connection")]),e._v(", an endpoint closes the\nunderlying TCP connection.  An endpoint SHOULD use a method that\ncleanly closes the TCP connection, as well as the TLS session, if\napplicable, discarding any trailing bytes that may have been\nreceived.  An endpoint MAY close the connection via any means\navailable when necessary, such as when under attack.")]),e._v("\n"),t("p",[e._v("The underlying TCP connection, in most normal cases, SHOULD be closed\nfirst by the server, so that it holds the TIME_WAIT state and not the\nclient (as this would prevent it from re-opening the connection for 2\nmaximum segment lifetimes (2MSL), while there is no corresponding\nserver impact as a TIME_WAIT connection is immediately reopened upon\na new SYN with a higher seq number).  In abnormal cases (such as not\nhaving received a TCP Close from the server after a reasonable amount\nof time) a client MAY initiate the TCP Close.  As such, when a server\nis instructed to "),t("em",[e._v("Close the WebSocket Connection")]),e._v(" it SHOULD initiate\na TCP Close immediately, and when a client is instructed to do the\nsame, it SHOULD wait for a TCP Close from the server.")]),e._v("\n"),t("p",[e._v("As an example of how to obtain a clean closure in C using Berkeley\nsockets, one would call shutdown() with SHUT_WR on the socket, call\nrecv() until obtaining a return value of 0 indicating that the peer\nhas also performed an orderly shutdown, and finally call close() on\nthe socket.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.2.  Start the WebSocket Closing Handshake")]),e._v("\n"),t("p",[e._v("To "),t("em",[e._v("Start the WebSocket Closing Handshake")]),e._v(" with a status code\n(Section 7.4) /code/ and an optional close reason (Section 7.1.6)\n/reason/, an endpoint MUST send a Close control frame, as described\nin Section 5.5.1, whose status code is set to /code/ and whose close\nreason is set to /reason/.  Once an endpoint has both sent and\nreceived a Close control frame, that endpoint SHOULD "),t("em",[e._v("Close the\nWebSocket Connection")]),e._v(" as defined in Section 7.1.1.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.3.  The WebSocket Closing Handshake is Started")]),e._v("\n"),t("p",[e._v("Upon either sending or receiving a Close control frame, it is said\nthat "),t("em",[e._v("The WebSocket Closing Handshake is Started")]),e._v(" and that the\nWebSocket connection is in the CLOSING state.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.4.  The WebSocket Connection is Closed")]),e._v("\n"),t("p",[e._v("When the underlying TCP connection is closed, it is said that "),t("em",[e._v("The\nWebSocket Connection is Closed")]),e._v(" and that the WebSocket connection is\nin the CLOSED state.  If the TCP connection was closed after the\nWebSocket closing handshake was completed, the WebSocket connection\nis said to have been closed "),t("em",[e._v("cleanly")]),e._v(".")]),e._v("\n"),t("p",[e._v("If the WebSocket connection could not be established, it is also said\nthat "),t("em",[e._v("The WebSocket Connection is Closed")]),e._v(", but not "),t("em",[e._v("cleanly")]),e._v(".")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.5.  The WebSocket Connection Close Code")]),e._v("\n"),t("p",[e._v("As defined in Sections 5.5.1 and 7.4, a Close control frame may\ncontain a status code indicating a reason for closure.  A closing of\nthe WebSocket connection may be initiated by either endpoint,\npotentially simultaneously. "),t("em",[e._v("The WebSocket Connection Close Code")]),e._v(" is\ndefined as the status code (Section 7.4) contained in the first Close\ncontrol frame received by the application implementing this protocol.\nIf this Close control frame contains no status code, "),t("em",[e._v("The WebSocket\nConnection Close Code")]),e._v(" is considered to be 1005.  If "),t("em",[e._v("The WebSocket\nConnection is Closed")]),e._v(" and no Close control frame was received by the\nendpoint (such as could occur if the underlying transport connection\nis lost), "),t("em",[e._v("The WebSocket Connection Close Code")]),e._v(" is considered to be\n1006.")]),e._v("\n"),t("p",[e._v("NOTE: Two endpoints may not agree on the value of "),t("em",[e._v("The WebSocket\nConnection Close Code")]),e._v(".  As an example, if the remote endpoint sent a\nClose frame but the local application has not yet read the data\ncontaining the Close frame from its socket's receive buffer, and the\nlocal application independently decided to close the connection and\nsend a Close frame, both endpoints will have sent and received a\nClose frame and will not send further Close frames.  Each endpoint\nwill see the status code sent by the other end as "),t("em",[e._v("The WebSocket\nConnection Close Code")]),e._v(".  As such, it is possible that the two\nendpoints may not agree on the value of "),t("em",[e._v("The WebSocket Connection\nClose Code")]),e._v(" in the case that both endpoints "),t("em",[e._v("Start the WebSocket\nClosing Handshake")]),e._v(" independently and at roughly the same time.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.6.  The WebSocket Connection Close Reason")]),e._v("\n"),t("p",[e._v("As defined in Sections 5.5.1 and 7.4, a Close control frame may\ncontain a status code indicating a reason for closure, followed by\nUTF-8-encoded data, the interpretation of said data being left to the\nendpoints and not defined by this protocol.  A closing of the\nWebSocket connection may be initiated by either endpoint, potentially\nsimultaneously. "),t("em",[e._v("The WebSocket Connection Close Reason")]),e._v(" is defined as\nthe UTF-8-encoded data following the status code (Section 7.4)\ncontained in the first Close control frame received by the\napplication implementing this protocol.  If there is no such data in\nthe Close control frame, "),t("em",[e._v("The WebSocket Connection Close Reason")]),e._v(" is\nthe empty string.")]),e._v("\n"),t("p",[e._v("NOTE: Following the same logic as noted in Section 7.1.5, two\nendpoints may not agree on "),t("em",[e._v("The WebSocket Connection Close Reason")]),e._v(".")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.1.7.  Fail the WebSocket Connection")]),e._v("\n"),t("p",[e._v("Certain algorithms and specifications require an endpoint to "),t("em",[e._v("Fail\nthe WebSocket Connection")]),e._v(".  To do so, the client MUST "),t("em",[e._v("Close the\nWebSocket Connection")]),e._v(", and MAY report the problem to the user (which\nwould be especially useful for developers) in an appropriate manner.\nSimilarly, to do so, the server MUST "),t("em",[e._v("Close the WebSocket\nConnection")]),e._v(", and SHOULD log the problem.")]),e._v("\n"),t("p",[e._v("If "),t("em",[e._v("The WebSocket Connection is Established")]),e._v(" prior to the point where\nthe endpoint is required to "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(", the\nendpoint SHOULD send a Close frame with an appropriate status code\n(Section 7.4) before proceeding to "),t("em",[e._v("Close the WebSocket Connection")]),e._v(".\nAn endpoint MAY omit sending a Close frame if it believes the other\nside is unlikely to be able to receive and process the Close frame,\ndue to the nature of the error that led the WebSocket connection to\nfail in the first place.  An endpoint MUST NOT continue to attempt to\nprocess data (including a responding Close frame) from the remote\nendpoint after being instructed to "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".")]),e._v("\n"),t("p",[e._v("Except as indicated above or as specified by the application layer\n(e.g., a script using the WebSocket API), clients SHOULD NOT close\nthe connection.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.2.  Abnormal Closures")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.2.1.  Client-Initiated Closure")]),e._v("\n"),t("p",[e._v("Certain algorithms, in particular during the opening handshake,\nrequire the client to "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".  To do so, the\nclient MUST "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(" as defined in\nSection 7.1.7.")]),e._v("\n"),t("p",[e._v("If at any point the underlying transport layer connection is\nunexpectedly lost, the client MUST "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".")]),e._v("\n"),t("p",[e._v("Except as indicated above or as specified by the application layer\n(e.g., a script using the WebSocket API), clients SHOULD NOT close\nthe connection.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.2.2.  Server-Initiated Closure")]),e._v("\n"),t("p",[e._v("Certain algorithms require or recommend that the server "),t("em",[e._v("Abort the\nWebSocket Connection")]),e._v(" during the opening handshake.  To do so, the\nserver MUST simply "),t("em",[e._v("Close the WebSocket Connection")]),e._v(" (Section 7.1.1).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.2.3.  Recovering from Abnormal Closure")]),e._v("\n"),t("p",[e._v("Abnormal closures may be caused by any number of reasons.  Such\nclosures could be the result of a transient error, in which case\nreconnecting may lead to a good connection and a resumption of normal\noperations.  Such closures may also be the result of a nontransient\nproblem, in which case if each deployed client experiences an\nabnormal closure and immediately and persistently tries to reconnect,\nthe server may experience what amounts to a denial-of-service attack\nby a large number of clients trying to reconnect.  The end result of\nsuch a scenario could be that the service is unable to recover in a\ntimely manner or recovery is made much more difficult.")]),e._v("\n"),t("p",[e._v("To prevent this, clients SHOULD use some form of backoff when trying\nto reconnect after abnormal closures as described in this section.")]),e._v("\n"),t("p",[e._v("The first reconnect attempt SHOULD be delayed by a random amount of\ntime.  The parameters by which this random delay is chosen are left\nto the client to decide; a value chosen randomly between 0 and 5\nseconds is a reasonable initial delay though clients MAY choose a\ndifferent interval from which to select a delay length based on\nimplementation experience and particular application.")]),e._v("\n"),t("p",[e._v("Should the first reconnect attempt fail, subsequent reconnect\nattempts SHOULD be delayed by increasingly longer amounts of time,\nusing a method such as truncated binary exponential backoff.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.3.  Normal Closure of Connections")]),e._v("\n"),t("p",[e._v("Servers MAY close the WebSocket connection whenever desired.  Clients\nSHOULD NOT close the WebSocket connection arbitrarily.  In either\ncase, an endpoint initiates a closure by following the procedures to\n"),t("em",[e._v("Start the WebSocket Closing Handshake")]),e._v(" (Section 7.1.2).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.4.  Status Codes")]),e._v("\n"),t("p",[e._v("When closing an established connection (e.g., when sending a Close\nframe, after the opening handshake has completed), an endpoint MAY\nindicate a reason for closure.  The interpretation of this reason by\nan endpoint, and the action an endpoint should take given this\nreason, are left undefined by this specification.  This specification\ndefines a set of pre-defined status codes and specifies which ranges\nmay be used by extensions, frameworks, and end applications.  The\nstatus code and any associated textual message are optional\ncomponents of a Close frame.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.4.1.  Defined Status Codes")]),e._v("\n"),t("p",[e._v("Endpoints MAY use the following pre-defined status codes when sending\na Close frame.")]),e._v("\n"),t("p",[e._v("1000")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1000 indicates a normal closure, meaning that the purpose for\n  which the connection was established has been fulfilled.\n")])])]),t("p",[e._v("1001")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  1001 indicates that an endpoint is "going away", such as a server\n  going down or a browser having navigated away from a page.\n')])])]),t("p",[e._v("1002")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1002 indicates that an endpoint is terminating the connection due\n  to a protocol error.\n")])])]),t("p",[e._v("1003")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1003 indicates that an endpoint is terminating the connection\n  because it has received a type of data it cannot accept (e.g., an\n  endpoint that understands only text data MAY send this if it\n  receives a binary message).\n")])])]),t("p",[e._v("1004")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Reserved.  The specific meaning might be defined in the future.\n")])])]),t("p",[e._v("1005")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1005 is a reserved value and MUST NOT be set as a status code in a\n  Close control frame by an endpoint.  It is designated for use in\n  applications expecting a status code to indicate that no status\n  code was actually present.\n")])])]),t("p",[e._v("1006")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1006 is a reserved value and MUST NOT be set as a status code in a\n  Close control frame by an endpoint.  It is designated for use in\n  applications expecting a status code to indicate that the\n  connection was closed abnormally, e.g., without sending or\n  receiving a Close control frame.\n")])])]),t("p",[e._v("1007")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1007 indicates that an endpoint is terminating the connection\n  because it has received data within a message that was not\n  consistent with the type of the message (e.g., non-UTF-8 [RFC3629]\n  data within a text message).\n")])])]),t("p",[e._v("1008")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1008 indicates that an endpoint is terminating the connection\n  because it has received a message that violates its policy.  This\n  is a generic status code that can be returned when there is no\n  other more suitable status code (e.g., 1003 or 1009) or if there\n  is a need to hide specific details about the policy.\n")])])]),t("p",[e._v("1009")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1009 indicates that an endpoint is terminating the connection\n  because it has received a message that is too big for it to\n  process.\n")])])]),t("p",[e._v("1010")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1010 indicates that an endpoint (client) is terminating the\n  connection because it has expected the server to negotiate one or\n  more extension, but the server didn't return them in the response\n  message of the WebSocket handshake.  The list of extensions that\n  are needed SHOULD appear in the /reason/ part of the Close frame.\n  Note that this status code is not used by the server, because it\n  can fail the WebSocket handshake instead.\n")])])]),t("p",[e._v("1011")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1011 indicates that a server is terminating the connection because\n  it encountered an unexpected condition that prevented it from\n  fulfilling the request.\n")])])]),t("p",[e._v("1015")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  1015 is a reserved value and MUST NOT be set as a status code in a\n  Close control frame by an endpoint.  It is designated for use in\n  applications expecting a status code to indicate that the\n  connection was closed due to a failure to perform a TLS handshake\n  (e.g., the server certificate can't be verified).\n")])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("7.4.2.  Reserved Status Code Ranges")]),e._v("\n"),t("p",[e._v("0-999")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Status codes in the range 0-999 are not used.\n")])])]),t("p",[e._v("1000-2999")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Status codes in the range 1000-2999 are reserved for definition by\n  this protocol, its future revisions, and extensions specified in a\n  permanent and readily available public specification.\n")])])]),t("p",[e._v("3000-3999")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Status codes in the range 3000-3999 are reserved for use by\n  libraries, frameworks, and applications.  These status codes are\n  registered directly with IANA.  The interpretation of these codes\n  is undefined by this protocol.\n")])])]),t("p",[e._v("4000-4999")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Status codes in the range 4000-4999 are reserved for private use\n  and thus can't be registered.  Such codes can be used by prior\n  agreements between WebSocket applications.  The interpretation of\n  these codes is undefined by this protocol.\n")])])])])])]),e._v(" "),t("h2",{attrs:{id:"_8-错误处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-错误处理"}},[e._v("#")]),e._v(" 8. 错误处理")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"8"}},[e._v("\n"),t("li",[e._v("Error Handling")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("8.1.  Handling Errors in UTF-8-Encoded Data")]),e._v("\n"),t("p",[e._v("When an endpoint is to interpret a byte stream as UTF-8 but finds\nthat the byte stream is not, in fact, a valid UTF-8 stream, that\nendpoint MUST "),t("em",[e._v("Fail the WebSocket Connection")]),e._v(".  This rule applies\nboth during the opening handshake and during subsequent data\nexchange.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_9-扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-扩展"}},[e._v("#")]),e._v(" 9. 扩展")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"9"}},[e._v("\n"),t("li",[e._v("Extensions")]),e._v("\n")]),e._v("\n"),t("p",[e._v("WebSocket clients MAY request extensions to this specification, and\nWebSocket servers MAY accept some or all extensions requested by the\nclient.  A server MUST NOT respond with any extension not requested\nby the client.  If extension parameters are included in negotiations\nbetween the client and the server, those parameters MUST be chosen in\naccordance with the specification of the extension to which the\nparameters apply.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("9.1.  Negotiating Extensions")]),e._v("\n"),t("p",[e._v('A client requests extensions by including a |Sec-WebSocket-\nExtensions| header field, which follows the normal rules for HTTP\nheader fields (see [RFC2616], Section 4.2) and the value of the\nheader field is defined by the following ABNF [RFC2616].  Note that\nthis section is using ABNF syntax/rules from [RFC2616], including the\n"implied *LWS rule".  If a value is received by either the client or\nthe server during negotiation that does not conform to the ABNF\nbelow, the recipient of such malformed data MUST immediately '),t("em",[e._v("Fail\nthe WebSocket Connection")]),e._v(".")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('     Sec-WebSocket-Extensions = extension-list\n     extension-list = 1#extension\n     extension = extension-token *( ";" extension-param )\n     extension-token = registered-token\n     registered-token = token\n     extension-param = token [ "=" (token | quoted-string) ]\n         ;When using the quoted-string syntax variant, the value\n         ;after quoted-string unescaping MUST conform to the\n         ;\'token\' ABNF.\n')])])]),t("p",[e._v("Note that like other HTTP header fields, this header field MAY be\nsplit or combined across multiple lines.  Ergo, the following are\nequivalent:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("     Sec-WebSocket-Extensions: foo\n     Sec-WebSocket-Extensions: bar; baz=2\n")])])]),t("p",[e._v("is exactly equivalent to")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("     Sec-WebSocket-Extensions: foo, bar; baz=2\n")])])]),t("p",[e._v("Any extension-token used MUST be a registered token (see\nSection 11.4).  The parameters supplied with any given extension MUST\nbe defined for that extension.  Note that the client is only offering\nto use any advertised extensions and MUST NOT use them unless the\nserver indicates that it wishes to use the extension.")]),e._v(" "),t("p",[e._v("Note that the order of extensions is significant.  Any interactions\nbetween multiple extensions MAY be defined in the documents defining\nthe extensions.  In the absence of such definitions, the\ninterpretation is that the header fields listed by the client in its\nrequest represent a preference of the header fields it wishes to use,\nwith the first options listed being most preferable.  The extensions\nlisted by the server in response represent the extensions actually in\nuse for the connection.  Should the extensions modify the data and/or\nframing, the order of operations on the data should be assumed to be\nthe same as the order in which the extensions are listed in the\nserver's response in the opening handshake.")]),e._v(" "),t("p",[e._v('For example, if there are two extensions "foo" and "bar" and if the\nheader field |Sec-WebSocket-Extensions| sent by the server has the\nvalue "foo, bar", then operations on the data will be made as\nbar(foo(data)), be those changes to the data itself (such as\ncompression) or changes to the framing that may "stack".')]),e._v(" "),t("p",[e._v("Non-normative examples of acceptable extension header fields (note\nthat long lines are folded for readability):")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("     Sec-WebSocket-Extensions: deflate-stream\n     Sec-WebSocket-Extensions: mux; max-channels=4; flow-control,\n      deflate-stream\n     Sec-WebSocket-Extensions: private-extension\n")])])]),t("p",[e._v("A server accepts one or more extensions by including a\n|Sec-WebSocket-Extensions| header field containing one or more\nextensions that were requested by the client.  The interpretation of\nany extension parameters, and what constitutes a valid response by a\nserver to a requested set of parameters by a client, will be defined\nby each such extension.")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("9.2.  Known Extensions")]),e._v("\n"),t("p",[e._v("Extensions provide a mechanism for implementations to opt-in to\nadditional protocol features.  This document doesn't define any\nextension, but implementations MAY use extensions defined separately.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_10-安全注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-安全注意事项"}},[e._v("#")]),e._v(" 10. 安全注意事项")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"10"}},[e._v("\n"),t("li",[e._v("Security Considerations")]),e._v("\n")]),e._v("\n"),t("p",[e._v("This section describes some security considerations applicable to the\nWebSocket Protocol.  Specific security considerations are described\nin subsections of this section.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.1.  Non-Browser Clients")]),e._v("\n"),t("p",[e._v("The WebSocket Protocol protects against malicious JavaScript running\ninside a trusted application such as a web browser, for example, by\nchecking of the |Origin| header field (see below).  See Section 1.6\nfor additional details.  Such assumptions don't hold true in the case\nof a more-capable client.")]),e._v("\n"),t("p",[e._v("While this protocol is intended to be used by scripts in web pages,\nit can also be used directly by hosts.  Such hosts are acting on\ntheir own behalf and can therefore send fake |Origin| header fields,\nmisleading the server.  Servers should therefore be careful about\nassuming that they are talking directly to scripts from known origins\nand must consider that they might be accessed in unexpected ways.  In\nparticular, a server should not trust that any input is valid.")]),e._v("\n"),t("p",[e._v("EXAMPLE: If the server uses input as part of SQL queries, all input\ntext should be escaped before being passed to the SQL server, lest\nthe server be susceptible to SQL injection.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.2.  Origin Considerations")]),e._v("\n"),t("p",[e._v("Servers that are not intended to process input from any web page but\nonly for certain sites SHOULD verify the |Origin| field is an origin\nthey expect.  If the origin indicated is unacceptable to the server,\nthen it SHOULD respond to the WebSocket handshake with a reply\ncontaining HTTP 403 Forbidden status code.")]),e._v("\n"),t("p",[e._v("The |Origin| header field protects from the attack cases when the\nuntrusted party is typically the author of a JavaScript application\nthat is executing in the context of the trusted client.  The client\nitself can contact the server and, via the mechanism of the |Origin|\nheader field, determine whether to extend those communication\nprivileges to the JavaScript application.  The intent is not to\nprevent non-browsers from establishing connections but rather to\nensure that trusted browsers under the control of potentially\nmalicious JavaScript cannot fake a WebSocket handshake.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.3.  Attacks On Infrastructure (Masking)")]),e._v("\n"),t("p",[e._v("In addition to endpoints being the target of attacks via WebSockets,\nother parts of web infrastructure, such as proxies, may be the\nsubject of an attack.")]),e._v("\n"),t("p",[e._v('As this protocol was being developed, an experiment was conducted to\ndemonstrate a class of attacks on proxies that led to the poisoning\nof caching proxies deployed in the wild [TALKING].  The general form\nof the attack was to establish a connection to a server under the\n"attacker\'s" control, perform an UPGRADE on the HTTP connection\nsimilar to what the WebSocket Protocol does to establish a\nconnection, and subsequently send data over that UPGRADEd connection\nthat looked like a GET request for a specific known resource (which\nin an attack would likely be something like a widely deployed script\nfor tracking hits or a resource on an ad-serving network).  The\nremote server would respond with something that looked like a\nresponse to the fake GET request, and this response would be cached\nby a nonzero percentage of deployed intermediaries, thus poisoning\nthe cache.  The net effect of this attack would be that if a user\ncould be convinced to visit a website the attacker controlled, the\nattacker could potentially poison the cache for that user and other\nusers behind the same cache and run malicious script on other\norigins, compromising the web security model.')]),e._v("\n"),t("p",[e._v("To avoid such attacks on deployed intermediaries, it is not\nsufficient to prefix application-supplied data with framing that is\nnot compliant with HTTP, as it is not possible to exhaustively\ndiscover and test that each nonconformant intermediary does not skip\nsuch non-HTTP framing and act incorrectly on the frame payload.\nThus, the defense adopted is to mask all data from the client to the\nserver, so that the remote script (attacker) does not have control\nover how the data being sent appears on the wire and thus cannot\nconstruct a message that could be misinterpreted by an intermediary\nas an HTTP request.")]),e._v("\n"),t("p",[e._v("Clients MUST choose a new masking key for each frame, using an\nalgorithm that cannot be predicted by end applications that provide\ndata.  For example, each masking could be drawn from a\ncryptographically strong random number generator.  If the same key is\nused or a decipherable pattern exists for how the next key is chosen,\nthe attacker can send a message that, when masked, could appear to be\nan HTTP request (by taking the message the attacker wishes to see on\nthe wire and masking it with the next masking key to be used, the\nmasking key will effectively unmask the data when the client applies\nit).")]),e._v("\n"),t("p",[e._v("It is also necessary that once the transmission of a frame from a\nclient has begun, the payload (application-supplied data) of that\nframe must not be capable of being modified by the application.\nOtherwise, an attacker could send a long frame where the initial data\nwas a known value (such as all zeros), compute the masking key being\nused upon receipt of the first part of the data, and then modify the\ndata that is yet to be sent in the frame to appear as an HTTP request\nwhen masked.  (This is essentially the same problem described in the\nprevious paragraph with using a known or predictable masking key.)\nIf additional data is to be sent or data to be sent is somehow\nchanged, that new or changed data must be sent in a new frame and\nthus with a new masking key.  In short, once transmission of a frame\nbegins, the contents must not be modifiable by the remote script\n(application).")]),e._v("\n"),t("p",[e._v("The threat model being protected against is one in which the client\nsends data that appears to be an HTTP request.  As such, the channel\nthat needs to be masked is the data from the client to the server.\nThe data from the server to the client can be made to look like a\nresponse, but to accomplish this request, the client must also be\nable to forge a request.  As such, it was not deemed necessary to\nmask data in both directions (the data from the server to the client\nis not masked).")]),e._v("\n"),t("p",[e._v("Despite the protection provided by masking, non-compliant HTTP\nproxies will still be vulnerable to poisoning attacks of this type by\nclients and servers that do not apply masking.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.4.  Implementation-Specific Limits")]),e._v("\n"),t("p",[e._v("Implementations that have implementation- and/or platform-specific\nlimitations regarding the frame size or total message size after\nreassembly from multiple frames MUST protect themselves against\nexceeding those limits.  (For example, a malicious endpoint can try\nto exhaust its peer's memory or mount a denial-of-service attack by\nsending either a single big frame (e.g., of size 2**60) or by sending\na long stream of small frames that are a part of a fragmented\nmessage.)  Such an implementation SHOULD impose a limit on frame\nsizes and the total message size after reassembly from multiple\nframes.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.5.  WebSocket Client Authentication")]),e._v("\n"),t("p",[e._v("This protocol doesn't prescribe any particular way that servers can\nauthenticate clients during the WebSocket handshake.  The WebSocket\nserver can use any client authentication mechanism available to a\ngeneric HTTP server, such as cookies, HTTP authentication, or TLS\nauthentication.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.6.  Connection Confidentiality and Integrity")]),e._v("\n"),t("p",[e._v("Connection confidentiality and integrity is provided by running the\nWebSocket Protocol over TLS (wss URIs).  WebSocket implementations\nMUST support TLS and SHOULD employ it when communicating with their\npeers.")]),e._v("\n"),t("p",[e._v('For connections using TLS, the amount of benefit provided by TLS\ndepends greatly on the strength of the algorithms negotiated during\nthe TLS handshake.  For example, some TLS cipher mechanisms don\'t\nprovide connection confidentiality.  To achieve reasonable levels of\nprotection, clients should use only Strong TLS algorithms.  "Web\nSecurity Context: User Interface Guidelines"\n[W3C.REC-wsc-ui-20100812] discusses what constitutes Strong TLS\nalgorithms.  [RFC5246] provides additional guidance in Appendix A.5\nand Appendix D.3.')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.7.  Handling of Invalid Data")]),e._v("\n"),t("p",[e._v("Incoming data MUST always be validated by both clients and servers.\nIf, at any time, an endpoint is faced with data that it does not\nunderstand or that violates some criteria by which the endpoint\ndetermines safety of input, or when the endpoint sees an opening\nhandshake that does not correspond to the values it is expecting\n(e.g., incorrect path or origin in the client request), the endpoint\nMAY drop the TCP connection.  If the invalid data was received after\na successful WebSocket handshake, the endpoint SHOULD send a Close\nframe with an appropriate status code (Section 7.4) before proceeding\nto "),t("em",[e._v("Close the WebSocket Connection")]),e._v(".  Use of a Close frame with an\nappropriate status code can help in diagnosing the problem.  If the\ninvalid data is sent during the WebSocket handshake, the server\nSHOULD return an appropriate HTTP [RFC2616] status code.")]),e._v("\n"),t("p",[e._v("A common class of security problems arises when sending text data\nusing the wrong encoding.  This protocol specifies that messages with\na Text data type (as opposed to Binary or other types) contain UTF-8-\nencoded data.  Although the length is still indicated and\napplications implementing this protocol should use the length to\ndetermine where the frame actually ends, sending data in an improper\nencoding may still break assumptions that applications built on top\nof this protocol may make, leading to anything from misinterpretation\nof data to loss of data or potential security bugs.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("10.8.  Use of SHA-1 by the WebSocket Handshake")]),e._v("\n"),t("p",[e._v("The WebSocket handshake described in this document doesn't depend on\nany security properties of SHA-1, such as collision resistance or\nresistance to the second pre-image attack (as described in\n[RFC4270]).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_11-iana注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-iana注意事项"}},[e._v("#")]),e._v(" 11. IANA注意事项")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"11"}},[e._v("\n"),t("li",[e._v("IANA Considerations")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.1.  Registration of New URI Schemes")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v('11.1.1.  Registration of "ws" Scheme')]),e._v("\n"),t("p",[e._v("A |ws| URI identifies a WebSocket server and resource name.")]),e._v("\n"),t("p",[e._v("URI scheme name\nws")]),e._v("\n"),t("p",[e._v("Status\nPermanent")]),e._v("\n"),t("p",[e._v("URI scheme syntax\nUsing the ABNF [RFC5234] syntax and ABNF terminals from the URI\nspecification [RFC3986]:")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('       "ws:" "//" authority path-abempty [ "?" query ]\n')])])]),t("p",[e._v("The < path-abempty> and < query> [RFC3986] components form the resource\nname sent to the server to identify the kind of service desired.\nOther components have the meanings described in [RFC3986].")]),e._v(" "),t("p",[e._v("URI scheme semantics\nThe only operation for this scheme is to open a connection using\nthe WebSocket Protocol.")]),e._v(" "),t("p",[e._v("Encoding considerations\nCharacters in the host component that are excluded by the syntax\ndefined above MUST be converted from Unicode to ASCII as specified\nin [RFC3987] or its replacement.  For the purposes of scheme-based\nnormalization, Internationalized Domain Name (IDN) forms of the\nhost component and their conversions to punycode are considered\nequivalent (see Section 5.3.3 of [RFC3987]).")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Characters in other components that are excluded by the syntax\n  defined above MUST be converted from Unicode to ASCII by first\n  encoding the characters as UTF-8 and then replacing the\n  corresponding bytes using their percent-encoded form as defined in\n  the URI [RFC3986] and Internationalized Resource Identifier (IRI)\n  [RFC3987] specifications.\n")])])]),t("p",[e._v("Applications/protocols that use this URI scheme name\nWebSocket Protocol")]),e._v(" "),t("p",[e._v("Interoperability considerations\nUse of WebSocket requires use of HTTP version 1.1 or higher.")]),e._v(" "),t("p",[e._v('Security considerations\nSee "Security Considerations" section.')]),e._v(" "),t("p",[e._v("Contact\nHYBI WG "),t("a",{attrs:{href:"mailto:hybi@ietf.org"}},[e._v("hybi@ietf.org")])]),e._v(" "),t("p",[e._v("Author/Change controller\nIETF "),t("a",{attrs:{href:"mailto:iesg@ietf.org"}},[e._v("iesg@ietf.org")])]),e._v(" "),t("p",[e._v("References\nRFC 6455")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v('11.1.2.  Registration of "wss" Scheme')]),e._v("\n"),t("p",[e._v("A |wss| URI identifies a WebSocket server and resource name and\nindicates that traffic over that connection is to be protected via\nTLS (including standard benefits of TLS such as data confidentiality\nand integrity and endpoint authentication).")]),e._v("\n"),t("p",[e._v("URI scheme name\nwss")]),e._v("\n"),t("p",[e._v("Status\nPermanent")]),e._v("\n"),t("p",[e._v("URI scheme syntax\nUsing the ABNF [RFC5234] syntax and ABNF terminals from the URI\nspecification [RFC3986]:")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('       "wss:" "//" authority path-abempty [ "?" query ]\n')])])]),t("p",[e._v("The < path-abempty> and < query> components form the resource name sent\nto the server to identify the kind of service desired.  Other\ncomponents have the meanings described in [RFC3986].")]),e._v(" "),t("p",[e._v("URI scheme semantics\nThe only operation for this scheme is to open a connection using\nthe WebSocket Protocol, encrypted using TLS.")]),e._v(" "),t("p",[e._v("Encoding considerations\nCharacters in the host component that are excluded by the syntax\ndefined above MUST be converted from Unicode to ASCII as specified\nin [RFC3987] or its replacement.  For the purposes of scheme-based\nnormalization IDN forms of the host component and their\nconversions to punycode are considered equivalent (see Section\n5.3.3 of [RFC3987]).")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  Characters in other components that are excluded by the syntax\n  defined above MUST be converted from Unicode to ASCII by first\n  encoding the characters as UTF-8 and then replacing the\n  corresponding bytes using their percent-encoded form as defined in\n  the URI [RFC3986] and IRI [RFC3987] specifications.\n")])])]),t("p",[e._v("Applications/protocols that use this URI scheme name\nWebSocket Protocol over TLS")]),e._v(" "),t("p",[e._v("Interoperability considerations\nUse of WebSocket requires use of HTTP version 1.1 or higher.")]),e._v(" "),t("p",[e._v('Security considerations\nSee "Security Considerations" section.')]),e._v(" "),t("p",[e._v("Contact\nHYBI WG "),t("a",{attrs:{href:"mailto:hybi@ietf.org"}},[e._v("hybi@ietf.org")])]),e._v(" "),t("p",[e._v("Author/Change controller\nIETF "),t("a",{attrs:{href:"mailto:iesg@ietf.org"}},[e._v("iesg@ietf.org")])]),e._v(" "),t("p",[e._v("References\nRFC 6455")])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v('11.2.  Registration of the "WebSocket" HTTP Upgrade Keyword')]),e._v("\n"),t("p",[e._v("This section defines a keyword registered in the HTTP Upgrade Tokens\nRegistry as per RFC 2817 [RFC2817].")]),e._v("\n"),t("p",[e._v("Name of token\nWebSocket")]),e._v("\n"),t("p",[e._v("Author/Change controller\nIETF "),t("a",{attrs:{href:"mailto:iesg@ietf.org"}},[e._v("iesg@ietf.org")])]),e._v("\n"),t("p",[e._v("Contact\nHYBI "),t("a",{attrs:{href:"mailto:hybi@ietf.org"}},[e._v("hybi@ietf.org")])]),e._v("\n"),t("p",[e._v("References\nRFC 6455")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.3.  Registration of New HTTP Header Fields")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.3.1.  Sec-WebSocket-Key")]),e._v("\n"),t("p",[e._v("This section describes a header field registered in the Permanent\nMessage Header Field Names registry [RFC3864].")]),e._v("\n"),t("p",[e._v("Header field name\nSec-WebSocket-Key")]),e._v("\n"),t("p",[e._v("Applicable protocol\nhttp")]),e._v("\n"),t("p",[e._v("Status\nstandard")]),e._v("\n"),t("p",[e._v("Author/Change controller\nIETF")]),e._v("\n"),t("p",[e._v("Specification document(s)\nRFC 6455")]),e._v("\n"),t("p",[e._v("Related information\nThis header field is only used for WebSocket opening handshake.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Key| header field is used in the WebSocket opening\nhandshake.  It is sent from the client to the server to provide part\nof the information used by the server to prove that it received a\nvalid WebSocket opening handshake.  This helps ensure that the server\ndoes not accept connections from non-WebSocket clients (e.g., HTTP\nclients) that are being abused to send data to unsuspecting WebSocket\nservers.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Key| header field MUST NOT appear more than once\nin an HTTP request.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.3.2.  Sec-WebSocket-Extensions")]),e._v("\n"),t("p",[e._v("This section describes a header field for registration in the\nPermanent Message Header Field Names registry [RFC3864].")]),e._v("\n"),t("p",[e._v("Header field name\nSec-WebSocket-Extensions")]),e._v("\n"),t("p",[e._v("Applicable protocol\nhttp")]),e._v("\n"),t("p",[e._v("Status\nstandard")]),e._v("\n"),t("p",[e._v("Author/Change controller\nIETF")]),e._v("\n"),t("p",[e._v("Specification document(s)\nRFC 6455")]),e._v("\n"),t("p",[e._v("Related information\nThis header field is only used for WebSocket opening handshake.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Extensions| header field is used in the WebSocket\nopening handshake.  It is initially sent from the client to the\nserver, and then subsequently sent from the server to the client, to\nagree on a set of protocol-level extensions to use for the duration\nof the connection.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Extensions| header field MAY appear multiple times\nin an HTTP request (which is logically the same as a single\n|Sec-WebSocket-Extensions| header field that contains all values.\nHowever, the |Sec-WebSocket-Extensions| header field MUST NOT appear\nmore than once in an HTTP response.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.3.3.  Sec-WebSocket-Accept")]),e._v("\n"),t("p",[e._v("This section describes a header field registered in the Permanent\nMessage Header Field Names registry [RFC3864].")]),e._v("\n"),t("p",[e._v("Header field name\nSec-WebSocket-Accept")]),e._v("\n"),t("p",[e._v("Applicable protocol\nhttp")]),e._v("\n"),t("p",[e._v("Status\nstandard")]),e._v("\n"),t("p",[e._v("Author/Change controller\nIETF")]),e._v("\n"),t("p",[e._v("Specification document(s)\nRFC 6455")]),e._v("\n"),t("p",[e._v("Related information\nThis header field is only used for the WebSocket opening\nhandshake.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Accept| header field is used in the WebSocket\nopening handshake.  It is sent from the server to the client to\nconfirm that the server is willing to initiate the WebSocket\nconnection.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Accept| header MUST NOT appear more than once in\nan HTTP response.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.3.4.  Sec-WebSocket-Protocol")]),e._v("\n"),t("p",[e._v("This section describes a header field registered in the Permanent\nMessage Header Field Names registry [RFC3864].")]),e._v("\n"),t("p",[e._v("Header field name\nSec-WebSocket-Protocol")]),e._v("\n"),t("p",[e._v("Applicable protocol\nhttp")]),e._v("\n"),t("p",[e._v("Status\nstandard")]),e._v("\n"),t("p",[e._v("Author/Change controller\nIETF")]),e._v("\n"),t("p",[e._v("Specification document(s)\nRFC 6455")]),e._v("\n"),t("p",[e._v("Related information\nThis header field is only used for the WebSocket opening\nhandshake.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Protocol| header field is used in the WebSocket\nopening handshake.  It is sent from the client to the server and back\nfrom the server to the client to confirm the subprotocol of the\nconnection.  This enables scripts to both select a subprotocol and be\nsure that the server agreed to serve that subprotocol.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Protocol| header field MAY appear multiple times\nin an HTTP request (which is logically the same as a single\n|Sec-WebSocket-Protocol| header field that contains all values).\nHowever, the |Sec-WebSocket-Protocol| header field MUST NOT appear\nmore than once in an HTTP response.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.3.5.  Sec-WebSocket-Version")]),e._v("\n"),t("p",[e._v("This section describes a header field registered in the Permanent\nMessage Header Field Names registry [RFC3864].")]),e._v("\n"),t("p",[e._v("Header field name\nSec-WebSocket-Version")]),e._v("\n"),t("p",[e._v("Applicable protocol\nhttp")]),e._v("\n"),t("p",[e._v("Status\nstandard")]),e._v("\n"),t("p",[e._v("Author/Change controller\nIETF")]),e._v("\n"),t("p",[e._v("Specification document(s)\nRFC 6455")]),e._v("\n"),t("p",[e._v("Related information\nThis header field is only used for the WebSocket opening\nhandshake.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Version| header field is used in the WebSocket\nopening handshake.  It is sent from the client to the server to\nindicate the protocol version of the connection.  This enables\nservers to correctly interpret the opening handshake and subsequent\ndata being sent from the data, and close the connection if the server\ncannot interpret that data in a safe manner.  The |Sec-WebSocket-\nVersion| header field is also sent from the server to the client on\nWebSocket handshake error, when the version received from the client\ndoes not match a version understood by the server.  In such a case,\nthe header field includes the protocol version(s) supported by the\nserver.")]),e._v("\n"),t("p",[e._v("Note that there is no expectation that higher version numbers are\nnecessarily backward compatible with lower version numbers.")]),e._v("\n"),t("p",[e._v("The |Sec-WebSocket-Version| header field MAY appear multiple times in\nan HTTP response (which is logically the same as a single\n|Sec-WebSocket-Version| header field that contains all values).\nHowever, the |Sec-WebSocket-Version| header field MUST NOT appear\nmore than once in an HTTP request.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.4.  WebSocket Extension Name Registry")]),e._v("\n"),t("p",[e._v("This specification creates a new IANA registry for WebSocket\nExtension names to be used with the WebSocket Protocol in accordance\nwith the principles set out in RFC 5226 [RFC5226].")]),e._v("\n"),t("p",[e._v("As part of this registry, IANA maintains the following information:")]),e._v("\n"),t("p",[e._v("Extension Identifier\nThe identifier of the extension, as will be used in the\n|Sec-WebSocket-Extensions| header field registered in\nSection 11.3.2 of this specification.  The value must conform to\nthe requirements for an extension-token as defined in Section 9.1\nof this specification.")]),e._v("\n"),t("p",[e._v("Extension Common Name\nThe name of the extension, as the extension is generally referred\nto.")]),e._v("\n"),t("p",[e._v("Extension Definition\nA reference to the document in which the extension being used with\nthe WebSocket Protocol is defined.")]),e._v("\n"),t("p",[e._v("Known Incompatible Extensions\nA list of extension identifiers with which this extension is known\nto be incompatible.")]),e._v("\n"),t("p",[e._v('WebSocket Extension names are to be subject to the "First Come First\nServed" IANA registration policy [RFC5226].')]),e._v("\n"),t("p",[e._v("There are no initial values in this registry.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.5.  WebSocket Subprotocol Name Registry")]),e._v("\n"),t("p",[e._v("This specification creates a new IANA registry for WebSocket\nSubprotocol names to be used with the WebSocket Protocol in\naccordance with the principles set out in RFC 5226 [RFC5226].")]),e._v("\n"),t("p",[e._v("As part of this registry, IANA maintains the following information:")]),e._v("\n"),t("p",[e._v("Subprotocol Identifier\nThe identifier of the subprotocol, as will be used in the\n|Sec-WebSocket-Protocol| header field registered in Section 11.3.4\nof this specification.  The value must conform to the requirements\ngiven in item 10 of Section 4.1 of this specification -- namely,\nthe value must be a token as defined by RFC 2616 [RFC2616].")]),e._v("\n"),t("p",[e._v("Subprotocol Common Name\nThe name of the subprotocol, as the subprotocol is generally\nreferred to.")]),e._v("\n"),t("p",[e._v("Subprotocol Definition\nA reference to the document in which the subprotocol being used\nwith the WebSocket Protocol is defined.")]),e._v("\n"),t("p",[e._v('WebSocket Subprotocol names are to be subject to the "First Come\nFirst Served" IANA registration policy [RFC5226].')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.6.  WebSocket Version Number Registry")]),e._v("\n"),t("p",[e._v("This specification creates a new IANA registry for WebSocket Version\nNumbers to be used with the WebSocket Protocol in accordance with the\nprinciples set out in RFC 5226 [RFC5226].")]),e._v("\n"),t("p",[e._v("As part of this registry, IANA maintains the following information:")]),e._v("\n"),t("p",[e._v("Version Number\nThe version number to be used in the |Sec-WebSocket-Version| is\nspecified in Section 4.1 of this specification.  The value must be\na non-negative integer in the range between 0 and 255 (inclusive).")]),e._v("\n"),t("p",[e._v("Reference\nThe RFC requesting a new version number or a draft name with\nversion number (see below).")]),e._v("\n"),t("p",[e._v('Status\nEither "Interim" or "Standard".  See below for description.')]),e._v("\n"),t("p",[e._v('A version number is designated as either "Interim" or "Standard".')]),e._v("\n"),t("p",[e._v('A "Standard" version number is documented in an RFC and used to\nidentify a major, stable version of the WebSocket protocol, such as\nthe version defined by this RFC.  "Standard" version numbers are\nsubject to the "IETF Review" IANA registration policy [RFC5226].')]),e._v("\n"),t("p",[e._v('An "Interim" version number is documented in an Internet-Draft and\nused to help implementors identify and interoperate with deployed\nversions of the WebSocket protocol, such as versions developed before\nthe publication of this RFC.  "Interim" version numbers are subject\nto the "Expert Review" IANA registration policy [RFC5226], with the\nchairs of the HYBI Working Group (or, if the working group closes,\nthe Area Directors for the IETF Applications Area) being the initial\nDesignated Experts.')]),e._v("\n"),t("p",[e._v("IANA has added initial values to the registry as follows.")]),e._v("\n"),t("p",[e._v("+--------+-----------------------------------------+----------+\n|Version |                Reference                |  Status  |\n| Number |                                         |          |\n+--------+-----------------------------------------+----------+\n| 0      + draft-ietf-hybi-thewebsocketprotocol-00 | Interim  |\n+--------+-----------------------------------------+----------+\n| 1      + draft-ietf-hybi-thewebsocketprotocol-01 | Interim  |\n+--------+-----------------------------------------+----------+\n| 2      + draft-ietf-hybi-thewebsocketprotocol-02 | Interim  |\n+--------+-----------------------------------------+----------+\n| 3      + draft-ietf-hybi-thewebsocketprotocol-03 | Interim  |\n+--------+-----------------------------------------+----------+\n| 4      + draft-ietf-hybi-thewebsocketprotocol-04 | Interim  |\n+--------+-----------------------------------------+----------+\n| 5      + draft-ietf-hybi-thewebsocketprotocol-05 | Interim  |\n+--------+-----------------------------------------+----------+\n| 6      + draft-ietf-hybi-thewebsocketprotocol-06 | Interim  |\n+--------+-----------------------------------------+----------+\n| 7      + draft-ietf-hybi-thewebsocketprotocol-07 | Interim  |\n+--------+-----------------------------------------+----------+\n| 8      + draft-ietf-hybi-thewebsocketprotocol-08 | Interim  |\n+--------+-----------------------------------------+----------+\n| 9      +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 10     +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 11     +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 12     +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 13     +                RFC 6455                 | Standard |\n+--------+-----------------------------------------+----------+")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.7.  WebSocket Close Code Number Registry")]),e._v("\n"),t("p",[e._v("This specification creates a new IANA registry for WebSocket\nConnection Close Code Numbers in accordance with the principles set\nout in RFC 5226 [RFC5226].")]),e._v("\n"),t("p",[e._v("As part of this registry, IANA maintains the following information:")]),e._v("\n"),t("p",[e._v("Status Code\nThe Status Code denotes a reason for a WebSocket connection\nclosure as per Section 7.4 of this document.  The status code is\nan integer number between 1000 and 4999 (inclusive).")]),e._v("\n"),t("p",[e._v("Meaning\nThe meaning of the status code.  Each status code has to have a\nunique meaning.")]),e._v("\n"),t("p",[e._v("Contact\nA contact for the entity reserving the status code.")]),e._v("\n"),t("p",[e._v("Reference\nThe stable document requesting the status codes and defining their\nmeaning.  This is required for status codes in the range 1000-2999\nand recommended for status codes in the range 3000-3999.")]),e._v("\n"),t("p",[e._v('WebSocket Close Code Numbers are subject to different registration\nrequirements depending on their range.  Requests for status codes for\nuse by this protocol and its subsequent versions or extensions are\nsubject to any one of the "Standards Action", "Specification\nRequired" (which implies "Designated Expert"), or "IESG Review" IANA\nregistration policies and should be granted in the range 1000-2999.\nRequests for status codes for use by libraries, frameworks, and\napplications are subject to the "First Come First Served" IANA\nregistration policy and should be granted in the range 3000-3999.\nThe range of status codes from 4000-4999 is designated for Private\nUse.  Requests should indicate whether they are requesting status\ncodes for use by the WebSocket Protocol (or a future version of the\nprotocol), by extensions, or by libraries/frameworks/applications.')]),e._v("\n"),t("p",[e._v("IANA has added initial values to the registry as follows.")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" |Status Code | Meaning         | Contact       | Reference |\n-+------------+-----------------+---------------+-----------|\n | 1000       | Normal Closure  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1001       | Going Away      | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1002       | Protocol error  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1003       | Unsupported Data| hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1004       | ---Reserved---- | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1005       | No Status Rcvd  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1006       | Abnormal Closure| hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1007       | Invalid frame   | hybi@ietf.org | RFC 6455  |\n |            | payload data    |               |           |\n-+------------+-----------------+---------------+-----------|\n | 1008       | Policy Violation| hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1009       | Message Too Big | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1010       | Mandatory Ext.  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1011       | Internal Server | hybi@ietf.org | RFC 6455  |\n |            | Error           |               |           |\n-+------------+-----------------+---------------+-----------|\n | 1015       | TLS handshake   | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n")])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.8.  WebSocket Opcode Registry")]),e._v("\n"),t("p",[e._v("This specification creates a new IANA registry for WebSocket Opcodes\nin accordance with the principles set out in RFC 5226 [RFC5226].")]),e._v("\n"),t("p",[e._v("As part of this registry, IANA maintains the following information:")]),e._v("\n"),t("p",[e._v("Opcode\nThe opcode denotes the frame type of the WebSocket frame, as\ndefined in Section 5.2.  The opcode is an integer number between 0\nand 15, inclusive.")]),e._v("\n"),t("p",[e._v("Meaning\nThe meaning of the opcode value.")]),e._v("\n"),t("p",[e._v("Reference\nThe specification requesting the opcode.")]),e._v("\n"),t("p",[e._v('WebSocket Opcode numbers are subject to the "Standards Action" IANA\nregistration policy [RFC5226].')]),e._v("\n"),t("p",[e._v("IANA has added initial values to the registry as follows.")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" |Opcode  | Meaning                             | Reference |\n-+--------+-------------------------------------+-----------|\n | 0      | Continuation Frame                  | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 1      | Text Frame                          | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 2      | Binary Frame                        | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 8      | Connection Close Frame              | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 9      | Ping Frame                          | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 10     | Pong Frame                          | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n")])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("11.9.  WebSocket Framing Header Bits Registry")]),e._v("\n"),t("p",[e._v("This specification creates a new IANA registry for WebSocket Framing\nHeader Bits in accordance with the principles set out in RFC 5226\n[RFC5226].  This registry controls assignment of the bits marked\nRSV1, RSV2, and RSV3 in Section 5.2.")]),e._v("\n"),t("p",[e._v("These bits are reserved for future versions or extensions of this\nspecification.")]),e._v("\n"),t("p",[e._v('WebSocket Framing Header Bits assignments are subject to the\n"Standards Action" IANA registration policy [RFC5226].')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_12-使用其他规范中的websocket协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-使用其他规范中的websocket协议"}},[e._v("#")]),e._v(" 12. 使用其他规范中的WebSocket协议")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"12"}},[e._v("\n"),t("li",[e._v("Using the WebSocket Protocol from Other Specifications")]),e._v("\n")]),e._v("\n"),t("p",[e._v("The WebSocket Protocol is intended to be used by another\nspecification to provide a generic mechanism for dynamic author-\ndefined content, e.g., in a specification defining a scripted API.")]),e._v("\n"),t("p",[e._v("Such a specification first needs to "),t("em",[e._v("Establish a WebSocket\nConnection")]),e._v(", providing that algorithm with:")]),e._v("\n"),t("p",[e._v("o  The destination, consisting of a /host/ and a /port/.")]),e._v("\n"),t("p",[e._v("o  A /resource name/, which allows for multiple services to be\nidentified at one host and port.")]),e._v("\n"),t("p",[e._v("o  A /secure/ flag, which is true if the connection is to be\nencrypted and false otherwise.")]),e._v("\n"),t("p",[e._v("o  An ASCII serialization of an origin [RFC6454] that is being made\nresponsible for the connection.")]),e._v("\n"),t("p",[e._v("o  Optionally, a string identifying a protocol that is to be layered\nover the WebSocket connection.")]),e._v("\n"),t("p",[e._v("The /host/, /port/, /resource name/, and /secure/ flag are usually\nobtained from a URI using the steps to parse a WebSocket URI's\ncomponents.  These steps fail if the URI does not specify a\nWebSocket.")]),e._v("\n"),t("p",[e._v("If at any time the connection is to be closed, then the specification\nneeds to use the "),t("em",[e._v("Close the WebSocket Connection")]),e._v(" algorithm\n(Section 7.1.1).")]),e._v("\n"),t("p",[e._v("Section 7.1.4 defines when "),t("em",[e._v("The WebSocket Connection is Closed")]),e._v(".")]),e._v("\n"),t("p",[e._v("While a connection is open, the specification will need to handle the\ncases when "),t("em",[e._v("A WebSocket Message Has Been Received")]),e._v(" (Section 6.2).")]),e._v("\n"),t("p",[e._v("To send some data /data/ to an open connection, the specification\nneeds to "),t("em",[e._v("Send a WebSocket Message")]),e._v(" (Section 6.1).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_13-致谢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-致谢"}},[e._v("#")]),e._v(" 13. 致谢")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"13"}},[e._v("\n"),t("li",[e._v("Acknowledgements")]),e._v("\n")]),e._v("\n"),t("p",[e._v("Special thanks are due to Ian Hickson, who was the original author\nand editor of this protocol.  The initial design of this\nspecification benefitted from the participation of many people in the\nWHATWG and WHATWG mailing list.  Contributions to that specification\nare not tracked by section, but a list of all who contributed to that\nspecification is given in the WHATWG HTML specification at\nhttp://whatwg.org/html5.")]),e._v("\n"),t("p",[e._v('Special thanks also to John Tamplin for providing a significant\namount of text for the "Data Framing" section of this specification.')]),e._v("\n"),t("p",[e._v('Special thanks also to Adam Barth for providing a significant amount\nof text and background research for the "Data Masking" section of\nthis specification.')]),e._v("\n"),t("p",[e._v("Special thanks to Lisa Dusseault for the Apps Area review (and for\nhelping to start this work), Richard Barnes for the Gen-Art review,\nand Magnus Westerlund for the Transport Area Review.  Special thanks\nto HYBI WG past and present WG chairs who tirelessly worked behind\nthe scene to move this work toward completion: Joe Hildebrand,\nSalvatore Loreto, and Gabriel Montenegro.  And last but not least,\nspecial thank you to the responsible Area Director Peter Saint-Andre.")]),e._v("\n"),t("p",[e._v("Thank you to the following people who participated in discussions on\nthe HYBI WG mailing list and contributed ideas and/or provided\ndetailed reviews (the list is likely to be incomplete): Greg Wilkins,\nJohn Tamplin, Willy Tarreau, Maciej Stachowiak, Jamie Lokier, Scott\nFerguson, Bjoern Hoehrmann, Julian Reschke, Dave Cridland, Andy\nGreen, Eric Rescorla, Inaki Baz Castillo, Martin Thomson, Roberto\nPeon, Patrick McManus, Zhong Yu, Bruce Atherton, Takeshi Yoshino,\nMartin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding,\nMykyta Yevstifeyev, Len Holgate, Paul Colomiets, Piotr Kulaga, Brian\nRaymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen\nFarrell, Sean Turner, Pete Resnick, Peter Thorson, Joe Mason, John\nFallows, and Alexander Philippou.  Note that people listed above\ndidn't necessarily endorse the end result of this work.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("h2",{attrs:{id:"_14-引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-引用"}},[e._v("#")]),e._v(" 14. 引用")]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("ol",{attrs:{start:"14"}},[e._v("\n"),t("li",[e._v("References")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("14.1.  Normative References")]),e._v("\n"),t("p",[e._v('[ANSI.X3-4.1986]\nAmerican National Standards Institute, "Coded Character\nSet - 7-bit American Standard Code for Information\nInterchange", ANSI X3.4, 1986.')]),e._v("\n"),t("p",[e._v('[FIPS.180-3]\nNational Institute of Standards and Technology, "Secure\nHash Standard", FIPS PUB 180-3, October 2008,\n<http://csrc.nist.gov/publications/fips/fips180-3/\nfips180-3_final.pdf>.')]),e._v("\n"),t("p",[e._v('[RFC1928]  Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and\nL. Jones, "SOCKS Protocol Version 5", RFC 1928,\nMarch 1996.')]),e._v("\n"),t("p",[e._v('[RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate\nRequirement Levels", BCP 14, RFC 2119, March 1997.')]),e._v("\n"),t("p",[e._v('[RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\nMasinter, L., Leach, P., and T. Berners-Lee, "Hypertext\nTransfer Protocol -- HTTP/1.1", RFC 2616, June 1999.')]),e._v("\n"),t("p",[e._v('[RFC2817]  Khare, R. and S. Lawrence, "Upgrading to TLS Within\nHTTP/1.1", RFC 2817, May 2000.')]),e._v("\n"),t("p",[e._v('[RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818, May 2000.')]),e._v("\n"),t("p",[e._v('[RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO\n10646", STD 63, RFC 3629, November 2003.')]),e._v("\n"),t("p",[e._v('[RFC3864]  Klyne, G., Nottingham, M., and J. Mogul, "Registration\nProcedures for Message Header Fields", BCP 90, RFC 3864,\nSeptember 2004.')]),e._v("\n"),t("p",[e._v('[RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform\nResource Identifier (URI): Generic Syntax", STD 66,\nRFC 3986, January 2005.')]),e._v("\n"),t("p",[e._v('[RFC3987]  Duerst, M. and M. Suignard, "Internationalized Resource\nIdentifiers (IRIs)", RFC 3987, January 2005.')]),e._v("\n"),t("p",[e._v('[RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness\nRequirements for Security", BCP 106, RFC 4086, June 2005.')]),e._v("\n"),t("p",[e._v('[RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data\nEncodings", RFC 4648, October 2006.')]),e._v("\n"),t("p",[e._v('[RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an\nIANA Considerations Section in RFCs", BCP 26, RFC 5226,\nMay 2008.')]),e._v("\n"),t("p",[e._v('[RFC5234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax\nSpecifications: ABNF", STD 68, RFC 5234, January 2008.')]),e._v("\n"),t("p",[e._v('[RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security\n(TLS) Protocol Version 1.2", RFC 5246, August 2008.')]),e._v("\n"),t("p",[e._v('[RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:\nExtension Definitions", RFC 6066, January 2011.')]),e._v("\n"),t("p",[e._v('[RFC6454]  Barth, A., "The Web Origin Concept", RFC 6454,\nDecember 2011.')]),e._v("\n")]),e._v("\n")])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("14.2.  Informative References")]),e._v("\n"),t("p",[e._v('[RFC4122]  Leach, P., Mealling, M., and R. Salz, "A Universally\nUnique IDentifier (UUID) URN Namespace", RFC 4122,\nJuly 2005.')]),e._v("\n"),t("p",[e._v('[RFC4270]  Hoffman, P. and B. Schneier, "Attacks on Cryptographic\nHashes in Internet Protocols", RFC 4270, November 2005.')]),e._v("\n"),t("p",[e._v('[RFC5321]  Klensin, J., "Simple Mail Transfer Protocol", RFC 5321,\nOctober 2008.')]),e._v("\n"),t("p",[e._v('[RFC6202]  Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins,\n"Known Issues and Best Practices for the Use of Long\nPolling and Streaming in Bidirectional HTTP", RFC 6202,\nApril 2011.')]),e._v("\n"),t("p",[e._v('[RFC6265]  Barth, A., "HTTP State Management Mechanism", RFC 6265,\nApril 2011.')]),e._v("\n"),t("p",[e._v('[TALKING]  Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C.\nJackson, "Talking to Yourself for Fun and Profit", 2010,\n'),t("a",{attrs:{href:"http://w2spconf.com/2011/papers/websocket.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://w2spconf.com/2011/papers/websocket.pdf"),t("OutboundLink")],1),e._v(".")]),e._v("\n"),t("p",[e._v('[W3C.REC-wsc-ui-20100812]\nRoessler, T. and A. Saldhana, "Web Security Context: User\nInterface Guidelines", World Wide Web Consortium\nRecommendation REC-wsc-ui-20100812, August 2010,\n'),t("a",{attrs:{href:"http://www.w3.org/TR/2010/REC-wsc-ui-20100812/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.w3.org/TR/2010/REC-wsc-ui-20100812/"),t("OutboundLink")],1),e._v(".")]),e._v("\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("          Latest version available at\n          <http://www.w3.org/TR/wsc-ui/>.\n")])])]),t("p",[e._v('[WSAPI]    Hickson, I., "The WebSocket API", W3C Working Draft WD-\nwebsockets-20110929, September 2011,\n'),t("a",{attrs:{href:"http://www.w3.org/TR/2011/WD-websockets-20110929/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.w3.org/TR/2011/WD-websockets-20110929/"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("          Latest version available at\n          <http://www.w3.org/TR/websockets/>.\n")])])]),t("p",[e._v('[XMLHttpRequest]\nvan Kesteren, A., Ed., "XMLHttpRequest", W3C Candidate\nRecommendation CR-XMLHttpRequest-20100803, August 2010,\n'),t("a",{attrs:{href:"http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("          Latest version available at\n          <http://www.w3.org/TR/XMLHttpRequest/>.\n")])])])])])]),e._v(" "),t("details",[t("summary",[e._v("原文")]),e._v(" "),t("pre",[t("code",[e._v("\n"),t("p",[e._v("Authors' Addresses")]),e._v("\n"),t("p",[e._v("Ian Fette\nGoogle, Inc.")]),e._v("\n"),t("p",[e._v("EMail: ifette+ietf@google.com\nURI:   http://www.ianfette.com/")]),e._v("\n"),t("p",[e._v("Alexey Melnikov\nIsode Ltd.\n5 Castle Business Village\n36 Station Road\nHampton, Middlesex  TW12 2BX\nUK")]),e._v("\n"),t("p",[e._v("EMail: Alexey.Melnikov@isode.com")]),e._v("\n")]),e._v("\n")])])])}),[],!1,null,null,null);n.default=a.exports}}]);