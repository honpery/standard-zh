(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{363:function(e,t,n){"use strict";n.r(t);var a=n(42),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"http-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[e._v("#")]),e._v(" HTTP/2")]),e._v(" "),n("blockquote",[n("p",[e._v("Hypertext Transfer Protocol Version 2 (HTTP/2) "),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc7540",target:"_blank",rel:"noopener noreferrer"}},[e._v("原文链接"),n("OutboundLink")],1)])]),e._v(" "),n("h3",{attrs:{id:"摘要"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[e._v("#")]),e._v(" 摘要")]),e._v(" "),n("p",[e._v("本规范描述了超文本传输​​协议（HTTP）的优化表达语义，称为HTTP第二版（HTTP/2）。 HTTP/2通过引入header字段压缩和多路复用可以更有效地利用网络资源并减少延迟感知。还引入了主动从服务器推送到客户端的表示形式。")]),e._v(" "),n("p",[e._v("本规范是HTTP/1.1的补充，但并不作废。 HTTP的现有语义保持不变。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("Abstract")]),e._v("\n"),n("p",[e._v("This specification describes an optimized expression of the semantics\nof the Hypertext Transfer Protocol (HTTP), referred to as HTTP\nversion 2 (HTTP/2).  HTTP/2 enables a more efficient use of network\nresources and a reduced perception of latency by introducing header\nfield compression and allowing multiple concurrent exchanges on the\nsame connection.  It also introduces unsolicited push of\nrepresentations from servers to clients.")]),e._v("\n"),n("p",[e._v("This specification is an alternative to, but does not obsolete, the\nHTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"备忘录状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#备忘录状态"}},[e._v("#")]),e._v(" 备忘录状态")]),e._v(" "),n("p",[e._v("这是Internet标准跟踪文档。")]),e._v(" "),n("p",[e._v("本文档是Internet工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被Internet工程指导小组（IESG）批准发布。有关Internet标准的更多信息，请参见RFC 5741的第2节。")]),e._v(" "),n("p",[e._v("有关本文档当前状态，任何勘误以及如何提供反馈的信息，请访问"),n("a",{attrs:{href:"http://www.rfc-editor.org/info/rfc7230",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.rfc-editor.org/info/rfc7230"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("Status of This Memo")]),e._v("\n"),n("p",[e._v("This is an Internet Standards Track document.")]),e._v("\n"),n("p",[e._v("This document is a product of the Internet Engineering Task Force\n(IETF).  It represents the consensus of the IETF community.  It has\nreceived public review and has been approved for publication by the\nInternet Engineering Steering Group (IESG).  Further information on\nInternet Standards is available in "),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc5741#section-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("Section 2 of RFC 5741"),n("OutboundLink")],1),e._v(".")]),e._v("\n"),n("p",[e._v("Information about the current status of this document, any errata,\nand how to provide feedback on it may be obtained at\nhttp://www.rfc-editor.org/info/rfc7540.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"版权声明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#版权声明"}},[e._v("#")]),e._v(" 版权声明")]),e._v(" "),n("p",[e._v("版权所有（c）2015 IETF Trust和确定为文档作者的人员。版权所有。")]),e._v(" "),n("p",[e._v("本文档受"),n("a",{attrs:{href:"https://tools.ietf.org/html/bcp78",target:"_blank",rel:"noopener noreferrer"}},[e._v("BCP 78"),n("OutboundLink")],1),e._v("和IETF Trust关于IETF文档的法律规定（"),n("a",{attrs:{href:"http://trustee.ietf.org/license-info",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://trustee.ietf.org/license-info"),n("OutboundLink")],1),e._v("）的约束，自本文档发布之日起生效。请仔细阅读这些文档，因为它们描述了您对本文档的权利和限制。从本文档中摘录的代码组件必须包含《信托法律条款》第4.e节中所述的BSD简化许可证文本，并且如BSD简化许可证中所述，提供的内容不附带任何保证。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("Copyright Notice")]),e._v("\n"),n("p",[e._v("Copyright (c) 2015 IETF Trust and the persons identified as the\ndocument authors.  All rights reserved.")]),e._v("\n"),n("p",[e._v("This document is subject to "),n("a",{attrs:{href:"https://tools.ietf.org/html/bcp78",target:"_blank",rel:"noopener noreferrer"}},[e._v("BCP 78"),n("OutboundLink")],1),e._v(" and the IETF Trust's Legal\nProvisions Relating to IETF Documents\n("),n("a",{attrs:{href:"http://trustee.ietf.org/license-info",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://trustee.ietf.org/license-info"),n("OutboundLink")],1),e._v(") in effect on the date of\npublication of this document.  Please review these documents\ncarefully, as they describe your rights and restrictions with respect\nto this document.  Code Components extracted from this document must\ninclude Simplified BSD License text as described in Section 4.e of\nthe Trust Legal Provisions and are provided without warranty as\ndescribed in the Simplified BSD License.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"目录"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[e._v("#")]),e._v(" 目录")]),e._v(" "),n("p",[e._v(".")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("Table of Contents")]),e._v("\n"),n("ol",[e._v("\n"),n("li",[e._v("Introduction ....................................................4")]),e._v("\n"),n("li",[e._v("HTTP/2 Protocol Overview ........................................5\n2.1. Document Organization ......................................6\n2.2. Conventions and Terminology ................................6")]),e._v("\n"),n("li",[e._v('Starting HTTP/2 .................................................7\n3.1. HTTP/2 Version Identification ..............................8\n3.2. Starting HTTP/2 for "http" URIs ............................8\n3.2.1. HTTP2-Settings Header Field .........................9\n3.3. Starting HTTP/2 for "https" URIs ..........................10\n3.4. Starting HTTP/2 with Prior Knowledge ......................10\n3.5. HTTP/2 Connection Preface .................................11')]),e._v("\n"),n("li",[e._v("HTTP Frames ....................................................12\n4.1. Frame Format ..............................................12\n4.2. Frame Size ................................................13\n4.3. Header Compression and Decompression ......................14")]),e._v("\n"),n("li",[e._v("Streams and Multiplexing .......................................15\n5.1. Stream States .............................................16\n5.1.1. Stream Identifiers .................................21\n5.1.2. Stream Concurrency .................................22\n5.2. Flow Control ..............................................22\n5.2.1. Flow-Control Principles ............................23\n5.2.2. Appropriate Use of Flow Control ....................24\n5.3. Stream Priority ...........................................24\n5.3.1. Stream Dependencies ................................25\n5.3.2. Dependency Weighting ...............................26\n5.3.3. Reprioritization ...................................26\n5.3.4. Prioritization State Management ....................27\n5.3.5. Default Priorities .................................28\n5.4. Error Handling ............................................28\n5.4.1. Connection Error Handling ..........................29\n5.4.2. Stream Error Handling ..............................29\n5.4.3. Connection Termination .............................30\n5.5. Extending HTTP/2 ..........................................30")]),e._v("\n"),n("li",[e._v("Frame Definitions ..............................................31\n6.1. DATA ......................................................31\n6.2. HEADERS ...................................................32\n6.3. PRIORITY ..................................................34\n6.4. RST_STREAM ................................................36\n6.5. SETTINGS ..................................................36\n6.5.1. SETTINGS Format ....................................38\n6.5.2. Defined SETTINGS Parameters ........................38\n6.5.3. Settings Synchronization ...........................39\n6.6. PUSH_PROMISE ..............................................40\n6.7. PING ......................................................42\n6.8. GOAWAY ....................................................43\n6.9. WINDOW_UPDATE .............................................46\n6.9.1. The Flow-Control Window ............................47\n6.9.2. Initial Flow-Control Window Size ...................48\n6.9.3. Reducing the Stream Window Size ....................49\n6.10. CONTINUATION .............................................49")]),e._v("\n"),n("li",[e._v("Error Codes ....................................................50")]),e._v("\n"),n("li",[e._v("HTTP Message Exchanges .........................................51\n8.1. HTTP Request/Response Exchange ............................52\n8.1.1. Upgrading from HTTP/2 ..............................53\n8.1.2. HTTP Header Fields .................................53\n8.1.3. Examples ...........................................57\n8.1.4. Request Reliability Mechanisms in HTTP/2 ...........60\n8.2. Server Push ...............................................60\n8.2.1. Push Requests ......................................61\n8.2.2. Push Responses .....................................63\n8.3. The CONNECT Method ........................................64")]),e._v("\n"),n("li",[e._v("Additional HTTP Requirements/Considerations ....................65\n9.1. Connection Management .....................................65\n9.1.1. Connection Reuse ...................................66\n9.1.2. The 421 (Misdirected Request) Status Code ..........66\n9.2. Use of TLS Features .......................................67\n9.2.1. TLS 1.2 Features ...................................67\n9.2.2. TLS 1.2 Cipher Suites ..............................68")]),e._v("\n"),n("li",[e._v("Security Considerations .......................................69\n10.1. Server Authority .........................................69\n10.2. Cross-Protocol Attacks ...................................69\n10.3. Intermediary Encapsulation Attacks .......................70\n10.4. Cacheability of Pushed Responses .........................70\n10.5. Denial-of-Service Considerations .........................70\n10.5.1. Limits on Header Block Size .......................71\n10.5.2. CONNECT Issues ....................................72\n10.6. Use of Compression .......................................72\n10.7. Use of Padding ...........................................73\n10.8. Privacy Considerations ...................................73")]),e._v("\n"),n("li",[e._v("IANA Considerations ...........................................74\n11.1. Registration of HTTP/2 Identification Strings ............74\n11.2. Frame Type Registry ......................................75\n11.3. Settings Registry ........................................75\n11.4. Error Code Registry ......................................76\n11.5. HTTP2-Settings Header Field Registration .................77\n11.6. PRI Method Registration ..................................78\n11.7. The 421 (Misdirected Request) HTTP Status Code ...........78\n11.8. The h2c Upgrade Token ....................................78")]),e._v("\n"),n("li",[e._v("References ....................................................79\n12.1. Normative References .....................................79\n12.2. Informative References ...................................81\nAppendix A. TLS 1.2 Cipher Suite Black List .......................83\nAcknowledgements ..................................................95\nAuthors' Addresses ................................................96")]),e._v("\n")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h2",{attrs:{id:"_1-引言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-引言"}},[e._v("#")]),e._v(" 1. 引言")]),e._v(" "),n("p",[e._v("超文本传输​​协议（HTTP）是非常成功的协议。但是，HTTP/1.1使用基础传输的方式（"),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc7230#section-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("[RFC7230]，第6节"),n("OutboundLink")],1),e._v("）具有几个对当今的应用程序性能产生负面影响的特征。")]),e._v(" "),n("p",[e._v("特别是，HTTP/1.0在给定的TCP连接上一次只允许一个未完成的请求。 HTTP/1.1添加了请求流水线处理，但这仅部分解决了请求并发问题，并且仍然受到队头阻塞的困扰。因此，需要发出许多请求的HTTP/1.0和HTTP/1.1客户端使用与服务器的多个连接以实现并发性，从而减少延迟。")]),e._v(" "),n("p",[e._v("此外，HTTP header字段通常是重复的和冗长的，从而导致不必要的网络流量，并导致初始TCP ["),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc7540#ref-TCP",target:"_blank",rel:"noopener noreferrer"}},[e._v("TCP"),n("OutboundLink")],1),e._v("]拥塞窗口快速填充。当在一个新的TCP连接上进行多个请求时，这可能导致过多的延迟。")]),e._v(" "),n("p",[e._v("HTTP/2通过定义HTTP语义到基础连接的优化映射来解决这些问题。具体来说，它允许在同一连接上交织请求和响应消息，并对HTTP header字段使用有效的编码。它还允许对请求进行优先级排序，使更重要的请求更快地完成，从而进一步提高性能。")]),e._v(" "),n("p",[e._v("生成的协议对网络更友好，因为与HTTP/1.x相比，可以使用更少的TCP连接。这意味着与其他流量的竞争减少，连接寿命更长，进而可以更好地利用可用网络容量。")]),e._v(" "),n("p",[e._v("最后，HTTP/2还可以通过使用二进制消息帧来更有效地处理消息。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",[e._v("\n"),n("li",[e._v("Introduction")]),e._v("\n")]),e._v("\n"),n("p",[e._v("The Hypertext Transfer Protocol (HTTP) is a wildly successful\nprotocol.  However, the way HTTP/1.1 uses the underlying transport\n("),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc7230#section-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("[RFC7230], Section 6"),n("OutboundLink")],1),e._v(") has several characteristics that have a\nnegative overall effect on application performance today.")]),e._v("\n"),n("p",[e._v("In particular, HTTP/1.0 allowed only one request to be outstanding at\na time on a given TCP connection.  HTTP/1.1 added request pipelining,\nbut this only partially addressed request concurrency and still\nsuffers from head-of-line blocking.  Therefore, HTTP/1.0 and HTTP/1.1\nclients that need to make many requests use multiple connections to a\nserver in order to achieve concurrency and thereby reduce latency.")]),e._v("\n"),n("p",[e._v("Furthermore, HTTP header fields are often repetitive and verbose,\ncausing unnecessary network traffic as well as causing the initial\nTCP ["),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc7540#ref-TCP",target:"_blank",rel:"noopener noreferrer"}},[e._v("TCP"),n("OutboundLink")],1),e._v("] congestion window to quickly fill.  This can result in\nexcessive latency when multiple requests are made on a new TCP\nconnection.")]),e._v("\n"),n("p",[e._v("HTTP/2 addresses these issues by defining an optimized mapping of\nHTTP's semantics to an underlying connection.  Specifically, it\nallows interleaving of request and response messages on the same\nconnection and uses an efficient coding for HTTP header fields.  It\nalso allows prioritization of requests, letting more important\nrequests complete more quickly, further improving performance.")]),e._v("\n"),n("p",[e._v("The resulting protocol is more friendly to the network because fewer\nTCP connections can be used in comparison to HTTP/1.x.  This means\nless competition with other flows and longer-lived connections, which\nin turn lead to better utilization of available network capacity.")]),e._v("\n"),n("p",[e._v("Finally, HTTP/2 also enables more efficient processing of messages\nthrough use of binary message framing.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h2",{attrs:{id:"_2-http-2协议概述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-http-2协议概述"}},[e._v("#")]),e._v(" 2. HTTP/2协议概述")]),e._v(" "),n("p",[e._v("HTTP/2为HTTP语义提供了传输优化。HTTP/2支持HTTP/1.1的所有核心功能，但旨在通过多种方式提高效率。")]),e._v(" "),n("p",[e._v("HTTP/2中的基本协议单元是帧（第4.1节）。每种帧类型都有不同的用途。例如，HEADERS帧和DATA帧构成了HTTP请求和响应的基础（第8.1节）；其他帧类型（如SETTINGS，WINDOW_UPDATE和PUSH_PROMISE）用于支持其他HTTP/2功能。")]),e._v(" "),n("p",[e._v("通过使每个HTTP请求/响应交换与其自己的流相关联来实现请求的复用（第5节）。流在很大程度上彼此独立，因此被阻塞或停止的请求或响应不会阻止其他流的进度。")]),e._v(" "),n("p",[e._v("流控制和优先级确保可以有效地使用多路复用流。流控制（第5.2节）有助于确保仅传输接收机可以使用的数据。优先级（第5.3节）确保可以将有限的资源首先定向到最重要的流。")]),e._v(" "),n("p",[e._v("HTTP/2添加了新的交互模式，服务器可以通过该模式将响应推送到客户端（第8.2节）。服务器推送允许服务器推测性地将数据发送到服务器，服务器预期该客户端将需要，从而权衡了一些网络使用量和潜在的延迟增加。服务器通过合成请求来完成此任务，并以PUSH_PROMISE帧的形式发送。然后，服务器可以在单独的流上发送对合成请求的响应。")]),e._v(" "),n("p",[e._v("由于连接中使用的HTTP标头字段可能包含大量冗余数据，因此包含它们的帧将被压缩（第4.3节）。在通常情况下，这对请求大小具有特别有利的影响，允许将许多请求压缩到一个数据包中。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"2"}},[e._v("\n"),n("li",[e._v("HTTP/2 Protocol Overview")]),e._v("\n")]),e._v("\n"),n("p",[e._v("HTTP/2 provides an optimized transport for HTTP semantics.  HTTP/2\nsupports all of the core features of HTTP/1.1 but aims to be more\nefficient in several ways.")]),e._v("\n"),n("p",[e._v("The basic protocol unit in HTTP/2 is a frame (Section 4.1).  Each\nframe type serves a different purpose.  For example, HEADERS and DATA\nframes form the basis of HTTP requests and responses (Section 8.1);\nother frame types like SETTINGS, WINDOW_UPDATE, and PUSH_PROMISE are\nused in support of other HTTP/2 features.")]),e._v("\n"),n("p",[e._v("Multiplexing of requests is achieved by having each HTTP request/\nresponse exchange associated with its own stream (Section 5).\nStreams are largely independent of each other, so a blocked or\nstalled request or response does not prevent progress on other\nstreams.")]),e._v("\n"),n("p",[e._v("Flow control and prioritization ensure that it is possible to\nefficiently use multiplexed streams.  Flow control (Section 5.2)\nhelps to ensure that only data that can be used by a receiver is\ntransmitted.  Prioritization (Section 5.3) ensures that limited\nresources can be directed to the most important streams first.")]),e._v("\n"),n("p",[e._v("HTTP/2 adds a new interaction mode whereby a server can push\nresponses to a client (Section 8.2).  Server push allows a server to\nspeculatively send data to a client that the server anticipates the\nclient will need, trading off some network usage against a potential\nlatency gain.  The server does this by synthesizing a request, which\nit sends as a PUSH_PROMISE frame.  The server is then able to send a\nresponse to the synthetic request on a separate stream.")]),e._v("\n"),n("p",[e._v("Because HTTP header fields used in a connection can contain large\namounts of redundant data, frames that contain them are compressed\n(Section 4.3).  This has especially advantageous impact upon request\nsizes in the common case, allowing many requests to be compressed\ninto one packet.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_2-1-文档组织"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-文档组织"}},[e._v("#")]),e._v(" 2.1 文档组织")]),e._v(" "),n("p",[e._v("HTTP/2规范分为四个部分：")]),e._v(" "),n("ul",[n("li",[e._v("启用HTTP/2（第3节）介绍如何初始化HTTP/2连接。")]),e._v(" "),n("li",[e._v("帧（第4节）和流（第5节）层描述了HTTP/2帧的结构和形成多路复用流的方式。")]),e._v(" "),n("li",[e._v("帧（第6节）和错误（第7节）定义包括HTTP/2中使用的帧和错误类型的详细信息。")]),e._v(" "),n("li",[e._v("HTTP映射（第8节）和其他要求（第9节）描述了如何使用帧和流来表示HTTP语义。")])]),e._v(" "),n("p",[e._v("尽管某些帧和流层概念与HTTP隔离，但此规范并未定义完全通用的流层。帧和流层是根据HTTP协议和服务器推送的需求量身定制的。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("2.1.  Document Organization")]),e._v("\n"),n("p",[e._v("The HTTP/2 specification is split into four parts:")]),e._v("\n"),n("p",[e._v("o  Starting HTTP/2 (Section 3) covers how an HTTP/2 connection is\ninitiated.")]),e._v("\n"),n("p",[e._v("o  The frame (Section 4) and stream (Section 5) layers describe the\nway HTTP/2 frames are structured and formed into multiplexed\nstreams.")]),e._v("\n"),n("p",[e._v("o  Frame (Section 6) and error (Section 7) definitions include\ndetails of the frame and error types used in HTTP/2.")]),e._v("\n"),n("p",[e._v("o  HTTP mappings (Section 8) and additional requirements (Section 9)\ndescribe how HTTP semantics are expressed using frames and\nstreams.")]),e._v("\n"),n("p",[e._v("While some of the frame and stream layer concepts are isolated from\nHTTP, this specification does not define a completely generic frame\nlayer.  The frame and stream layers are tailored to the needs of the\nHTTP protocol and server push.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_2-2-约定和术语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-约定和术语"}},[e._v("#")]),e._v(" 2.2 约定和术语")]),e._v(" "),n("p",[e._v('本文档中的关键字"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"将按照RFC 2119 [RFC2119]中的说明进行解释。')]),e._v(" "),n("p",[e._v("所有数值均以网络字节顺序排列。除非另有说明，否则值是无符号的。适当时以十进制或十六进制提供文字值。十六进制文字以“0x”为前缀，以区别于十进制文字。")]),e._v(" "),n("p",[e._v("使用以下术语：")]),e._v(" "),n("p",[e._v("客户端(client)：启用HTTP/2连接的端点。客户端发送HTTP请求并接收HTTP响应。")]),e._v(" "),n("p",[e._v("连接(connection)：两个端点之间的传输层连接。")]),e._v(" "),n("p",[e._v("连接错误(connection error)：影响整个HTTP/2连接的错误。")]),e._v(" "),n("p",[e._v("端点(point)：连接的客户端或服务器。")]),e._v(" "),n("p",[e._v("帧(frame)：HTTP / 2连接中的最小通信单元，由标头和根据帧类型构成的八位字节的可变长度序列组成。")]),e._v(" "),n("p",[e._v("对等(peer)：在讨论特定端点时，“对等”是指远离讨论的主要主题的端点。")]),e._v(" "),n("p",[e._v("接收器(receiver)：正在接收帧的端点。")]),e._v(" "),n("p",[e._v("发送方(sender)：正在传输帧的端点。")]),e._v(" "),n("p",[e._v("服务器(server)：接受HTTP/2连接的端点。服务器接收HTTP请求并发送HTTP响应。")]),e._v(" "),n("p",[e._v("流(stream)：HTTP/2连接内的双向帧流。")]),e._v(" "),n("p",[e._v("流错误(stream error)：单个HTTP/2流上的错误。")]),e._v(" "),n("p",[e._v("最后，在[RFC7230]的第2.3节中定义了术语“网关”，“中介”，“代理”和“隧道”。中介在不同时间充当客户端和服务器。")]),e._v(" "),n("p",[e._v("[RFC7230]第3.3节定义了术语“有效载荷主体”。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("2.2.  Conventions and Terminology")]),e._v("\n"),n("p",[e._v('The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this\ndocument are to be interpreted as described in RFC 2119 [RFC2119].')]),e._v("\n"),n("p",[e._v('All numeric values are in network byte order.  Values are unsigned\nunless otherwise indicated.  Literal values are provided in decimal\nor hexadecimal as appropriate.  Hexadecimal literals are prefixed\nwith "0x" to distinguish them from decimal literals.')]),e._v("\n"),n("p",[e._v("The following terms are used:")]),e._v("\n"),n("p",[e._v("client:  The endpoint that initiates an HTTP/2 connection.  Clients\nsend HTTP requests and receive HTTP responses.")]),e._v("\n"),n("p",[e._v("connection:  A transport-layer connection between two endpoints.")]),e._v("\n"),n("p",[e._v("connection error:  An error that affects the entire HTTP/2\nconnection.")]),e._v("\n"),n("p",[e._v("endpoint:  Either the client or server of the connection.")]),e._v("\n"),n("p",[e._v("frame:  The smallest unit of communication within an HTTP/2\nconnection, consisting of a header and a variable-length sequence\nof octets structured according to the frame type.")]),e._v("\n"),n("p",[e._v('peer:  An endpoint.  When discussing a particular endpoint, "peer"\nrefers to the endpoint that is remote to the primary subject of\ndiscussion.')]),e._v("\n"),n("p",[e._v("receiver:  An endpoint that is receiving frames.")]),e._v("\n"),n("p",[e._v("sender:  An endpoint that is transmitting frames.")]),e._v("\n"),n("p",[e._v("server:  The endpoint that accepts an HTTP/2 connection.  Servers\nreceive HTTP requests and send HTTP responses.")]),e._v("\n"),n("p",[e._v("stream:  A bidirectional flow of frames within the HTTP/2 connection.")]),e._v("\n"),n("p",[e._v("stream error:  An error on the individual HTTP/2 stream.")]),e._v("\n"),n("p",[e._v('Finally, the terms "gateway", "intermediary", "proxy", and "tunnel"\nare defined in Section 2.3 of [RFC7230].  Intermediaries act as both\nclient and server at different times.')]),e._v("\n"),n("p",[e._v('The term "payload body" is defined in Section 3.3 of [RFC7230].')]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h2",{attrs:{id:"_3-启用http-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-启用http-2"}},[e._v("#")]),e._v(" 3. 启用HTTP/2")]),e._v(" "),n("p",[e._v("HTTP/2连接是在TCP连接（[TCP]）之上运行的应用层协议。客户端是TCP连接启用器。")]),e._v(" "),n("p",[e._v("HTTP/2使用与HTTP / 1.1相同的“http”和“https”URI方案。HTTP/2共享相同的默认端口号：“http”URI为80，“https”URI为443。结果，需要处理诸如“http://example.org/foo”或“https://example.com/bar”之类的对目标资源URI的请求的实现，以便首先发现上游服务器（客户端希望建立连接）支持HTTP/2。")]),e._v(" "),n("p",[e._v("“http”和“https”URI对HTTP/2的支持是不同的。3.2节中介绍了“http”URI的发现。第3.3节介绍了“https”URI的发现。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"3"}},[e._v("\n"),n("li",[e._v("Starting HTTP/2")]),e._v("\n")]),e._v("\n"),n("p",[e._v("An HTTP/2 connection is an application-layer protocol running on top\nof a TCP connection ([TCP]).  The client is the TCP connection\ninitiator.")]),e._v("\n"),n("p",[e._v('HTTP/2 uses the same "http" and "https" URI schemes used by HTTP/1.1.\nHTTP/2 shares the same default port numbers: 80 for "http" URIs and\n443 for "https" URIs.  As a result, implementations processing\nrequests for target resource URIs like "http://example.org/foo" or\n"https://example.com/bar" are required to first discover whether the\nupstream server (the immediate peer to which the client wishes to\nestablish a connection) supports HTTP/2.')]),e._v("\n"),n("p",[e._v('The means by which support for HTTP/2 is determined is different for\n"http" and "https" URIs.  Discovery for "http" URIs is described in\nSection 3.2.  Discovery for "https" URIs is described in Section 3.3.')]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_3-1-http-2版本标识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-http-2版本标识"}},[e._v("#")]),e._v(" 3.1 HTTP/2版本标识")]),e._v(" "),n("p",[e._v("本文档中定义的协议具有两个标识符。")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("字符串“h2”标识HTTP/2使用传输层安全（TLS）[TLS12]。该标识符用于TLS应用程序层协议协商（ALPN）扩展[TLS-ALPN]字段中，以及标识TLS上的HTTP/2的任何地方。")]),e._v(" "),n("p",[e._v("“h2”字符串被序列化为一个ALPN协议标识符，为两个八位字节序列：0x68、0x32。")])]),e._v(" "),n("li",[n("p",[e._v("字符串“h2c”标识HTTP/2在明文TCP上运行的协议。此标识符用于HTTP/1.1升级标头字段中，以及在标识HTTP/2 over TCP的任何地方。")]),e._v(" "),n("p",[e._v("“h2c”字符串是从ALPN标识符空间保留的，但是描述了不使用TLS的协议。")])])]),e._v(" "),n("p",[e._v("协商“h2”或“h2c”意味着使用本文档中描述的传输、安全性、成帧和消息语义。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("3.1.  HTTP/2 Version Identification")]),e._v("\n"),n("p",[e._v("The protocol defined in this document has two identifiers.")]),e._v("\n"),n("p",[e._v('o  The string "h2" identifies the protocol where HTTP/2 uses\nTransport Layer Security (TLS) [TLS12].  This identifier is used\nin the TLS application-layer protocol negotiation (ALPN) extension\n[TLS-ALPN] field and in any place where HTTP/2 over TLS is\nidentified.')]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('The "h2" string is serialized into an ALPN protocol identifier as\nthe two-octet sequence: 0x68, 0x32.\n')])])]),n("p",[e._v('o  The string "h2c" identifies the protocol where HTTP/2 is run over\ncleartext TCP.  This identifier is used in the HTTP/1.1 Upgrade\nheader field and in any place where HTTP/2 over TCP is identified.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('The "h2c" string is reserved from the ALPN identifier space but\ndescribes a protocol that does not use TLS.\n')])])]),n("p",[e._v('Negotiating "h2" or "h2c" implies the use of the transport, security,\nframing, and message semantics described in this document.')])])])]),e._v(" "),n("h3",{attrs:{id:"_3-2-使用-http-uri启用http-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-使用-http-uri启用http-2"}},[e._v("#")]),e._v(' 3.2 使用"http"URI启用HTTP/2')]),e._v(" "),n("p",[e._v("客户端请求“http”URI时，如果不具有有关下一跳对HTTP/2支持的先验知识，则使用HTTP升级机制（[RFC7230]的6.7节）。客户端通过发出HTTP/1.1请求来做到这一点，该请求包括带有“h2c”令牌的Upgrade标头字段。这样的HTTP/1.1请求务必包含一个HTTP2-Settings（第3.2.1节）header字段。")]),e._v(" "),n("p",[e._v("例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("GET / HTTP/1.1\nHost: server.example.com\nConnection: Upgrade, HTTP2-Settings\nUpgrade: h2c\nHTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>\n")])])]),n("p",[e._v("在客户端可以发送HTTP/2帧之前，必须完整发送包含有效内容主体的请求。这意味着较大的请求可能会阻止连接的使用，直到完全发送为止。")]),e._v(" "),n("p",[e._v("如果初始请求与后续请求的并发性很重要，则可以使用OPTIONS请求执行到HTTP/2的升级，但要付出额外的往返消耗。")]),e._v(" "),n("p",[e._v("不支持HTTP/2的服务器可以响应该请求，就像缺少升级header字段一样：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("HTTP/1.1 200 OK\nContent-Length: 243\nContent-Type: text/html\n\n...\n")])])]),n("p",[e._v("服务器必须忽略升级头字段中的“h2”令牌。带有“h2”的令牌的存在意味着基于TLS的HTTP/2，而是按照3.3节中的说明进行协商。")]),e._v(" "),n("p",[e._v("支持HTTP/2的服务器以"),n("code",[e._v("101 (Switching Protocols)")]),e._v("响应接受升级。在空行终止101响应之后，服务器可以开始发送HTTP/2帧。这些帧必须包括对发起升级请求的响应。")]),e._v(" "),n("p",[e._v("例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("HTTP/1.1 101 Switching Protocols\nConnection: Upgrade\nUpgrade: h2c\n\n[ HTTP/2 connection ...\n")])])]),n("p",[e._v("服务器发送的第一个HTTP/2帧必须是一个由SETTINGS帧（第6.5节）组成的服务器连接前言（第3.5节）。收到101响应后，客户端必须发送一个包括一个SETTINGS帧的连接前言（第3.5节），")]),e._v(" "),n("p",[e._v("在升级之前发送的HTTP/1.1请求被分配了具有默认优先级值（第5.3.5节）的流标识符1（请参阅第5.1.1节）。由于请求是作为HTTP/1.1请求完成的，因此流1是从客户端到服务器的隐式“半封闭”（请参阅​​第5.1节）。开始HTTP/2连接后，流1用于响应。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v('3.2.  Starting HTTP/2 for "http" URIs')]),e._v("\n"),n("p",[e._v('A client that makes a request for an "http" URI without prior\nknowledge about support for HTTP/2 on the next hop uses the HTTP\nUpgrade mechanism (Section 6.7 of [RFC7230]).  The client does so by\nmaking an HTTP/1.1 request that includes an Upgrade header field with\nthe "h2c" token.  Such an HTTP/1.1 request MUST include exactly one\nHTTP2-Settings (Section 3.2.1) header field.')]),e._v("\n"),n("p",[e._v("For example:")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("GET / HTTP/1.1\nHost: server.example.com\nConnection: Upgrade, HTTP2-Settings\nUpgrade: h2c\nHTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>\n")])])]),n("p",[e._v("Requests that contain a payload body MUST be sent in their entirety\nbefore the client can send HTTP/2 frames.  This means that a large\nrequest can block the use of the connection until it is completely\nsent.")]),e._v(" "),n("p",[e._v("If concurrency of an initial request with subsequent requests is\nimportant, an OPTIONS request can be used to perform the upgrade to\nHTTP/2, at the cost of an additional round trip.")]),e._v(" "),n("p",[e._v("A server that does not support HTTP/2 can respond to the request as\nthough the Upgrade header field were absent:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("HTTP/1.1 200 OK\nContent-Length: 243\nContent-Type: text/html\n\n...\n")])])]),n("p",[e._v('A server MUST ignore an "h2" token in an Upgrade header field.\nPresence of a token with "h2" implies HTTP/2 over TLS, which is\ninstead negotiated as described in Section 3.3.')]),e._v(" "),n("p",[e._v("A server that supports HTTP/2 accepts the upgrade with a 101\n(Switching Protocols) response.  After the empty line that terminates\nthe 101 response, the server can begin sending HTTP/2 frames.  These\nframes MUST include a response to the request that initiated the\nupgrade.")]),e._v(" "),n("p",[e._v("For example:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("HTTP/1.1 101 Switching Protocols\nConnection: Upgrade\nUpgrade: h2c\n\n[ HTTP/2 connection ...\n")])])]),n("p",[e._v("The first HTTP/2 frame sent by the server MUST be a server connection\npreface (Section 3.5) consisting of a SETTINGS frame (Section 6.5).\nUpon receiving the 101 response, the client MUST send a connection\npreface (Section 3.5), which includes a SETTINGS frame.")]),e._v(" "),n("p",[e._v('The HTTP/1.1 request that is sent prior to upgrade is assigned a\nstream identifier of 1 (see Section 5.1.1) with default priority\nvalues (Section 5.3.5).  Stream 1 is implicitly "half-closed" from\nthe client toward the server (see Section 5.1), since the request is\ncompleted as an HTTP/1.1 request.  After commencing the HTTP/2\nconnection, stream 1 is used for the response.')])])])]),e._v(" "),n("h4",{attrs:{id:"_3-2-1-http2-settings-头字段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-http2-settings-头字段"}},[e._v("#")]),e._v(" 3.2.1 HTTP2-Settings 头字段")]),e._v(" "),n("p",[e._v("从HTTP/1.1升级到HTTP/2的请求务必包含一个“HTTP2-Settings”头字段。HTTP2-Settings头字段是特定于连接的头字段，其中包含控制HTTP/2连接的参数，这些参数是在服务器接受升级请求的前提下提供的。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("HTTP2-Settings    = token68\n")])])]),n("p",[e._v("如果此标头字段不存在或存在多个，则服务器不得将连接升级到HTTP/2。服务器不得发送此头字段。")]),e._v(" "),n("p",[e._v("HTTP2-Settings头字段的内容是SETTINGS帧的有效负载（第6.5节），编码为base64url字符串（即[RFC4648]第5节中描述的URL和文件名安全的Base64编码，包括末尾的'='字符被省略）[token68]的ABNF[RFC5234]生成在[RFC7235]的2.1节中定义。")]),e._v(" "),n("p",[e._v("由于升级仅适用于直接连接，因此发送HTTP2-Settings头字段的客户端还必须在Connection头字段中发送“HTTP2-Settings”作为连接选项以防止转发（参见第6.1节[RFC7230]。")]),e._v(" "),n("p",[e._v("服务器将对这些值进行解码和解释，就像处理其他任何SETTINGS帧一样。不需要显式确认这些设置（第6.5.3节），因为101响应用作隐式确认。在升级请求中提供这些值将使客户端有机会在从服务器接收任何帧之前提供参数。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("3.2.1.  HTTP2-Settings Header Field")]),e._v("\n"),n("p",[e._v('A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly\none "HTTP2-Settings" header field.  The HTTP2-Settings header field\nis a connection-specific header field that includes parameters that\ngovern the HTTP/2 connection, provided in anticipation of the server\naccepting the request to upgrade.')]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("HTTP2-Settings    = token68\n")])])]),n("p",[e._v("A server MUST NOT upgrade the connection to HTTP/2 if this header\nfield is not present or if more than one is present.  A server MUST\nNOT send this header field.")]),e._v(" "),n("p",[e._v("The content of the HTTP2-Settings header field is the payload of a\nSETTINGS frame (Section 6.5), encoded as a base64url string (that is,\nthe URL- and filename-safe Base64 encoding described in Section 5 of\n[RFC4648], with any trailing '=' characters omitted).  The ABNF\n[RFC5234] production for \"token68\" is defined in Section 2.1 of\n[RFC7235].")]),e._v(" "),n("p",[e._v('Since the upgrade is only intended to apply to the immediate\nconnection, a client sending the HTTP2-Settings header field MUST\nalso send "HTTP2-Settings" as a connection option in the Connection\nheader field to prevent it from being forwarded (see Section 6.1 of\n[RFC7230]).')]),e._v(" "),n("p",[e._v("A server decodes and interprets these values as it would any other\nSETTINGS frame.  Explicit acknowledgement of these settings\n(Section 6.5.3) is not necessary, since a 101 response serves as\nimplicit acknowledgement.  Providing these values in the upgrade\nrequest gives a client an opportunity to provide parameters prior to\nreceiving any frames from the server.")])])])]),e._v(" "),n("h3",{attrs:{id:"_3-3-使用-https-uri启用http-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-使用-https-uri启用http-2"}},[e._v("#")]),e._v(' 3.3 使用"https"URI启用HTTP/2')]),e._v(" "),n("p",[e._v("向“https”URI发出请求的客户端使用带有应用程序层协议协商（ALPN）扩展名[TLS-ALPN]的TLS [TLS12]。")]),e._v(" "),n("p",[e._v("TLS上的HTTP/2使用“h2”协议标识符。“h2c”协议标识符不得由客户端发送或由服务器选择；“h2c”协议标识符描述了不使用TLS的协议。")]),e._v(" "),n("p",[e._v("TLS协商完成后，客户端和服务器都必须发送连接序言（第3.5节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v('3.3.  Starting HTTP/2 for "https" URIs')]),e._v("\n"),n("p",[e._v('A client that makes a request to an "https" URI uses TLS [TLS12] with\nthe application-layer protocol negotiation (ALPN) extension\n[TLS-ALPN].')]),e._v("\n"),n("p",[e._v('HTTP/2 over TLS uses the "h2" protocol identifier.  The "h2c"\nprotocol identifier MUST NOT be sent by a client or selected by a\nserver; the "h2c" protocol identifier describes a protocol that does\nnot use TLS.')]),e._v("\n"),n("p",[e._v("Once TLS negotiation is complete, both the client and the server MUST\nsend a connection preface (Section 3.5).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_3-4-先知情况下启用http-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-先知情况下启用http-2"}},[e._v("#")]),e._v(" 3.4 先知情况下启用HTTP/2")]),e._v(" "),n("p",[e._v("客户端可以通过其他方式得知特定服务器支持HTTP/2。例如，[ALT-SVC]描述了一种用于宣传此功能的机制。")]),e._v(" "),n("p",[e._v("客户端可以通过其他方式得知特定服务器支持HTTP/2。例如，[ALT-SVC]描述了一种用于宣传此功能的机制。")]),e._v(" "),n("p",[e._v("客户端必须发送连接前言（第3.5节），然后可以立即向该服务器发送HTTP/2帧；服务器可以通过存在连接前言来识别这些连接。这仅影响通过明文TCP的HTTP/2连接的建立。在TLS上支持HTTP/2的实现必须在TLS [TLS-ALPN]中使用协议协商。")]),e._v(" "),n("p",[e._v("同样，服务器必须发送连接前言（第3.5节）。")]),e._v(" "),n("p",[e._v("如果没有其他信息，先前对HTTP/2的支持并不是一个强信号，即给定的服务器将为将来的连接支持HTTP/2。例如，服务器配置可能会更改，集群服务器中实例之间的配置可能会更改，或者网络条件可能会更改。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("3.4.  Starting HTTP/2 with Prior Knowledge")]),e._v("\n"),n("p",[e._v("A client can learn that a particular server supports HTTP/2 by other\nmeans.  For example, [ALT-SVC] describes a mechanism for advertising\nthis capability.")]),e._v("\n"),n("p",[e._v("A client MUST send the connection preface (Section 3.5) and then MAY\nimmediately send HTTP/2 frames to such a server; servers can identify\nthese connections by the presence of the connection preface.  This\nonly affects the establishment of HTTP/2 connections over cleartext\nTCP; implementations that support HTTP/2 over TLS MUST use protocol\nnegotiation in TLS [TLS-ALPN].")]),e._v("\n"),n("p",[e._v("Likewise, the server MUST send a connection preface (Section 3.5).")]),e._v("\n"),n("p",[e._v("Without additional information, prior support for HTTP/2 is not a\nstrong signal that a given server will support HTTP/2 for future\nconnections.  For example, it is possible for server configurations\nto change, for configurations to differ between instances in\nclustered servers, or for network conditions to change.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_3-5-http-2连接序言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-http-2连接序言"}},[e._v("#")]),e._v(" 3.5 HTTP/2连接序言")]),e._v(" "),n("p",[e._v("在HTTP/2中，要求每个端点发送一个连接序言作为对所使用协议的最终确认，并为HTTP/2连接建立初始设置。客户端和服务器各自发送不同的连接序言。")]),e._v(" "),n("p",[e._v("客户端连接序言以24个八位位组的序列开头，十六进制表示为：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a\n")])])]),n("p",[e._v('即，连接序言以字符串"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n"开头。这个序列之后必须是一个SETTINGS帧（第6.5节），该帧可以为空。客户端在收到101(Switching Protocols)响应（表示升级成功）或作为TLS连接的第一个应用程序数据八位字节后立即发送客户端连接序言。如果使用服务器对协议的先知开始HTTP/2连接，则在建立连接时发送客户端连接序言。')]),e._v(" "),n("p",[e._v("注意：选择客户端连接前言是为了使大部分HTTP/1.1或HTTP/1.0服务器和中介都不会尝试处理其他帧。请注意，这不能解决在[通话]中提出的问题。")]),e._v(" "),n("p",[e._v("服务器连接序言由可能为空的SETTINGS帧（第6.5节）组成，该帧必须是服务器在HTTP/2连接中发送的第一帧。")]),e._v(" "),n("p",[e._v("发送连接序言后，必须确认从对等方收到的作为连接序言一部分的SETTINGS帧（请参阅第6.5.3节）。")]),e._v(" "),n("p",[e._v("为了避免不必要的延迟，允许客户端在发送客户端连接序言之后立即向服务器发送其他帧，而不必等待接收服务器连接序言。但是，请务必注意，服务器连接前言SETTINGS帧可能包含一些参数，这些参数必定会更改期望客户端与服务器通信的方式。在接收到SETTINGS帧后，客户端应遵守所有已建立的参数。在某些配置中，服务器有可能在客户端发送其他帧之前传输设置，从而提供了避免此问题的机会。")]),e._v(" "),n("p",[e._v("客户端和服务器必须将无效的连接前言视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。在这种情况下，可以忽略GOAWAY帧（第6.8节），因为无效的前言表示对等方未使用HTTP/2。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("3.5.  HTTP/2 Connection Preface")]),e._v("\n"),n("p",[e._v("In HTTP/2, each endpoint is required to send a connection preface as\na final confirmation of the protocol in use and to establish the\ninitial settings for the HTTP/2 connection.  The client and server\neach send a different connection preface.")]),e._v("\n"),n("p",[e._v("The client connection preface starts with a sequence of 24 octets,\nwhich in hex notation is:")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a\n")])])]),n("p",[e._v('That is, the connection preface starts with the string "PRI *\nHTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n").  This sequence MUST be followed by a\nSETTINGS frame (Section 6.5), which MAY be empty.  The client sends\nthe client connection preface immediately upon receipt of a 101\n(Switching Protocols) response (indicating a successful upgrade) or\nas the first application data octets of a TLS connection.  If\nstarting an HTTP/2 connection with prior knowledge of server support\nfor the protocol, the client connection preface is sent upon\nconnection establishment.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("Note: The client connection preface is selected so that a large\nproportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do\nnot attempt to process further frames.  Note that this does not\naddress the concerns raised in [TALKING].\n")])])]),n("p",[e._v("The server connection preface consists of a potentially empty\nSETTINGS frame (Section 6.5) that MUST be the first frame the server\nsends in the HTTP/2 connection.")]),e._v(" "),n("p",[e._v("The SETTINGS frames received from a peer as part of the connection\npreface MUST be acknowledged (see Section 6.5.3) after sending the\nconnection preface.")]),e._v(" "),n("p",[e._v("To avoid unnecessary latency, clients are permitted to send\nadditional frames to the server immediately after sending the client\nconnection preface, without waiting to receive the server connection\npreface.  It is important to note, however, that the server\nconnection preface SETTINGS frame might include parameters that\nnecessarily alter how a client is expected to communicate with the\nserver.  Upon receiving the SETTINGS frame, the client is expected to\nhonor any parameters established.  In some configurations, it is\npossible for the server to transmit SETTINGS before the client sends\nadditional frames, providing an opportunity to avoid this issue.")]),e._v(" "),n("p",[e._v("Clients and servers MUST treat an invalid connection preface as a\nconnection error (Section 5.4.1) of type PROTOCOL_ERROR.  A GOAWAY\nframe (Section 6.8) MAY be omitted in this case, since an invalid\npreface indicates that the peer is not using HTTP/2.")])])])]),e._v(" "),n("h2",{attrs:{id:"_4-http帧"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-http帧"}},[e._v("#")]),e._v(" 4. HTTP帧")]),e._v(" "),n("p",[e._v("一旦HTTP / 2连接建立，端点就可以开始交换帧。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"4"}},[e._v("\n"),n("li",[e._v("HTTP Frames")]),e._v("\n")]),e._v("\n"),n("p",[e._v("Once the HTTP/2 connection is established, endpoints can begin\nexchanging frames.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_4-1-帧格式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-帧格式"}},[e._v("#")]),e._v(" 4.1 帧格式")]),e._v(" "),n("p",[e._v("所有帧均以固定的9字节首部开头，后跟可变长度的有效载荷。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("+-----------------------------------------------+\n|                 Length (24)                   |\n+---------------+---------------+---------------+\n|   Type (8)    |   Flags (8)   |\n+-+-------------+---------------+-------------------------------+\n|R|                 Stream Identifier (31)                      |\n+=+=============================================================+\n|                   Frame Payload (0...)                      ...\n+---------------------------------------------------------------+\n\n                        Figure 1: Frame Layout\n")])])]),n("p",[e._v("帧头的字段定义为：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("长度(Length)：帧有效载荷的长度，表示为无符号的24位整数。除非接收者为SETTINGS_MAX_FRAME_SIZE设置了更大的值，否则不得发送大于2^14（16,384）的值。")]),e._v(" "),n("p",[e._v("帧头的9个八位位组不包含在该值中。")])]),e._v(" "),n("li",[n("p",[e._v("类型(Type)：帧的8位类型。帧类型决定了框架的格式和语义。实现必须忽略并丢弃任何类型未知的帧。")])]),e._v(" "),n("li",[n("p",[e._v("标志(Flags)：一个8位字段，为特定于帧类型的布尔标志保留。")]),e._v(" "),n("p",[e._v("为标志分配特定于所指示帧类型的语义。对于特定帧类型，没有定义语义的标记必须被忽略，并且在发送时必须置为未设置（0x0）。")])]),e._v(" "),n("li",[n("p",[e._v("R：保留的1位字段。该位的语义是不确定的，发送时该位必须保持未设置状态（0x0），而接收时该位必须忽略。")])]),e._v(" "),n("li",[n("p",[e._v("流标识符(Stream Identifier)：流标识符（请参阅第5.1.1节），表示为无符号的31位整数。值0x0保留给与整个连接（而不是单个流）相关联的帧。")])])]),e._v(" "),n("p",[e._v("帧有效负载的结构和内容完全取决于帧类型。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("4.1.  Frame Format")]),e._v("\n"),n("p",[e._v("All frames begin with a fixed 9-octet header followed by a variable-\nlength payload.")]),e._v("\n"),n("p",[e._v("+-----------------------------------------------+\n|                 Length (24)                   |\n+---------------+---------------+---------------+\n|   Type (8)    |   Flags (8)   |\n+-+-------------+---------------+-------------------------------+\n|R|                 Stream Identifier (31)                      |\n+=+=============================================================+\n|                   Frame Payload (0...)                      ...\n+---------------------------------------------------------------+")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("                    Figure 1: Frame Layout\n")])])]),n("p",[e._v("The fields of the frame header are defined as:")]),e._v(" "),n("p",[e._v("Length:  The length of the frame payload expressed as an unsigned\n24-bit integer.  Values greater than 2^14 (16,384) MUST NOT be\nsent unless the receiver has set a larger value for\nSETTINGS_MAX_FRAME_SIZE.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("The 9 octets of the frame header are not included in this value.\n")])])]),n("p",[e._v("Type:  The 8-bit type of the frame.  The frame type determines the\nformat and semantics of the frame.  Implementations MUST ignore\nand discard any frame that has a type that is unknown.")]),e._v(" "),n("p",[e._v("Flags:  An 8-bit field reserved for boolean flags specific to the\nframe type.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("Flags are assigned semantics specific to the indicated frame type.\nFlags that have no defined semantics for a particular frame type\nMUST be ignored and MUST be left unset (0x0) when sending.\n")])])]),n("p",[e._v("R: A reserved 1-bit field.  The semantics of this bit are undefined,\nand the bit MUST remain unset (0x0) when sending and MUST be\nignored when receiving.")]),e._v(" "),n("p",[e._v("Stream Identifier:  A stream identifier (see Section 5.1.1) expressed\nas an unsigned 31-bit integer.  The value 0x0 is reserved for\nframes that are associated with the connection as a whole as\nopposed to an individual stream.")]),e._v(" "),n("p",[e._v("The structure and content of the frame payload is dependent entirely\non the frame type.")])])])]),e._v(" "),n("h3",{attrs:{id:"_4-2-帧大小"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-帧大小"}},[e._v("#")]),e._v(" 4.2 帧大小")]),e._v(" "),n("p",[e._v("帧有效负载的大小受接收者在SETTINGS_MAX_FRAME_SIZE设置中发布的最大大小限制。此设置的值可以介于2^14（16,384）和2^24-1（16,777,215）个八位字节之间（包括两端）。")]),e._v(" "),n("p",[e._v("所有实现都必须能够接收和最小处理长度最大为2^14个八位字节的帧，以及9个八位字节的帧头（第4.1节）。说明帧大小时，不包括帧头的大小。")]),e._v(" "),n("p",[e._v("注：某些帧类型（例如PING（第6.7节））对允许的有效载荷数据量施加了其他限制。")]),e._v(" "),n("p",[e._v("如果帧超出了帧头的大小，则端点必须发送错误代码FRAME_SIZE_ERROR。在SETTINGS_MAX_FRAME_SIZE中定义的大小，超出为帧类型定义的任何限制，或者太小而无法包含必需的帧数据。可能会改变整个连接状态的帧中的帧大小错误必须视为连接错误（第5.4.1节）；这包括任何带有标题块（第4.3节）（即HEADERS，PUSH_PROMISE和CONTINUATION），SETTINGS的帧，以及流标识符为0的任何帧。")]),e._v(" "),n("p",[e._v("端点没有义务使用帧中的所有可用空间。通过使用小于允许的最大尺寸的框架进行了改进。发送大帧会导致延迟时间敏感帧（例如RST_STREAM，WINDOW_UPDATE或PRIORITY），如果发送大帧会阻止它们，则可能会影响性能。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("4.2.  Frame Size")]),e._v("\n"),n("p",[e._v("The size of a frame payload is limited by the maximum size that a\nreceiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.  This\nsetting can have any value between 2^14 (16,384) and 2^24-1\n(16,777,215) octets, inclusive.")]),e._v("\n"),n("p",[e._v("All implementations MUST be capable of receiving and minimally\nprocessing frames up to 2^14 octets in length, plus the 9-octet frame\nheader (Section 4.1).  The size of the frame header is not included\nwhen describing frame sizes.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("Note: Certain frame types, such as PING (Section 6.7), impose\nadditional limits on the amount of payload data allowed.\n")])])]),n("p",[e._v("An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame\nexceeds the size defined in SETTINGS_MAX_FRAME_SIZE, exceeds any\nlimit defined for the frame type, or is too small to contain\nmandatory frame data.  A frame size error in a frame that could alter\nthe state of the entire connection MUST be treated as a connection\nerror (Section 5.4.1); this includes any frame carrying a header\nblock (Section 4.3) (that is, HEADERS, PUSH_PROMISE, and\nCONTINUATION), SETTINGS, and any frame with a stream identifier of 0.")]),e._v(" "),n("p",[e._v("Endpoints are not obligated to use all available space in a frame.\nResponsiveness can be improved by using frames that are smaller than\nthe permitted maximum size.  Sending large frames can result in\ndelays in sending time-sensitive frames (such as RST_STREAM,\nWINDOW_UPDATE, or PRIORITY), which, if blocked by the transmission of\na large frame, could affect performance.")])])])]),e._v(" "),n("h3",{attrs:{id:"_4-3-头部压缩和解压缩"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-头部压缩和解压缩"}},[e._v("#")]),e._v(" 4.3 头部压缩和解压缩")]),e._v(" "),n("p",[e._v("与HTTP/1中一样，HTTP/2中的头字段是具有一个或多个关联值的名称。头字段用于HTTP请求和响应消息以及服务器推送操作中（请参见8.2节）。")]),e._v(" "),n("p",[e._v("标头列表是零个或多个标头字段的集合。通过连接传输时，头文件列表会使用HTTP头文件压缩[COMPRESSION]序列化到前面的块中。然后将这些序列化的报头块划分为一个或多个八位字节序列，称为报头块片段，并在HEADERS（第6.2节），PUSH_PROMISE（第6.6节）或CONTINUATION（第6.10节）帧的有效载荷内传输。")]),e._v(" "),n("p",[e._v("处理Cookie头字段[COOKIE]特别是通过HTTPmapping（请参阅第8.1.2.5节）。")]),e._v(" "),n("p",[e._v("接收端点通过连接其片段重新组合头块，然后解压缩该块以重建头列表。")]),e._v(" "),n("p",[e._v("完整的头块由以下组成：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("单个HEADERS或PUSH_PROMISE帧以及END_HEADERS标志集。")])]),e._v(" "),n("li",[n("p",[e._v("或者清除了ENDERS标记的HEADERS或PUSH_PROMISE帧以及一个或多个CONTINUATION帧，其中最后一个CONTINUATION帧设置了END_HEADERS标记。")])])]),e._v(" "),n("p",[e._v("标头压缩是有状态的。一个压缩上下文和一个解压缩上下文用于整个连接。头块中的解码错误必须被视为COMPRESSION_ERROR类型的连接错误（第5.4.1节），")]),e._v(" "),n("p",[e._v("每个头块都作为离散单元处理。报头块必须作为连续的帧序列发送，没有任何其他类型的交错帧或来自任何其他流的帧。 HEADERS或CONTINUATION帧序列中的最后一个帧设置了END_HEADERS标志。 PUSH_PROMISEor CONTINUATION帧序列中的最后一个帧设置了END_HEADERS标志。这使得前导块在逻辑上等效于单个帧。")]),e._v(" "),n("p",[e._v("头块片段只能作为HEADERS，PUSH_PROMISE或CONTINUATION帧的有效负载发送，因为这些帧承载的数据可以修改接收机维护的压缩上下文。接收HEADERS，PUSH_PROMISE或CONTINUATION帧的端点需要重新组合头块并执行解压缩，即使要丢弃这些帧也是如此。如果接收方未解压缩头块，则必须以COMPRESSION_ERROR类型的连接错误（第5.4.1节）终止连接。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("4.3.  Header Compression and Decompression")]),e._v("\n"),n("p",[e._v("Just as in HTTP/1, a header field in HTTP/2 is a name with one or\nmore associated values.  Header fields are used within HTTP request\nand response messages as well as in server push operations (see\nSection 8.2).")]),e._v("\n"),n("p",[e._v("Header lists are collections of zero or more header fields.  When\ntransmitted over a connection, a header list is serialized into a\nheader block using HTTP header compression [COMPRESSION].  The\nserialized header block is then divided into one or more octet\nsequences, called header block fragments, and transmitted within the\npayload of HEADERS (Section 6.2), PUSH_PROMISE (Section 6.6), or\nCONTINUATION (Section 6.10) frames.")]),e._v("\n"),n("p",[e._v("The Cookie header field [COOKIE] is treated specially by the HTTP\nmapping (see Section 8.1.2.5).")]),e._v("\n"),n("p",[e._v("A receiving endpoint reassembles the header block by concatenating\nits fragments and then decompresses the block to reconstruct the\nheader list.")]),e._v("\n"),n("p",[e._v("A complete header block consists of either:")]),e._v("\n"),n("p",[e._v("o  a single HEADERS or PUSH_PROMISE frame, with the END_HEADERS flag\nset, or")]),e._v("\n"),n("p",[e._v("o  a HEADERS or PUSH_PROMISE frame with the END_HEADERS flag cleared\nand one or more CONTINUATION frames, where the last CONTINUATION\nframe has the END_HEADERS flag set.")]),e._v("\n"),n("p",[e._v("Header compression is stateful.  One compression context and one\ndecompression context are used for the entire connection.  A decoding\nerror in a header block MUST be treated as a connection error\n(Section 5.4.1) of type COMPRESSION_ERROR.")]),e._v("\n"),n("p",[e._v("Each header block is processed as a discrete unit.  Header blocks\nMUST be transmitted as a contiguous sequence of frames, with no\ninterleaved frames of any other type or from any other stream.  The\nlast frame in a sequence of HEADERS or CONTINUATION frames has the\nEND_HEADERS flag set.  The last frame in a sequence of PUSH_PROMISE\nor CONTINUATION frames has the END_HEADERS flag set.  This allows a\nheader block to be logically equivalent to a single frame.")]),e._v("\n"),n("p",[e._v("Header block fragments can only be sent as the payload of HEADERS,\nPUSH_PROMISE, or CONTINUATION frames because these frames carry data\nthat can modify the compression context maintained by a receiver.  An\nendpoint receiving HEADERS, PUSH_PROMISE, or CONTINUATION frames\nneeds to reassemble header blocks and perform decompression even if\nthe frames are to be discarded.  A receiver MUST terminate the\nconnection with a connection error (Section 5.4.1) of type\nCOMPRESSION_ERROR if it does not decompress a header block.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h2",{attrs:{id:"_5-流和多路复用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-流和多路复用"}},[e._v("#")]),e._v(" 5. 流和多路复用")]),e._v(" "),n("p",[n("code",[e._v("流(stream)")]),e._v("是HTTP/2连接中客户端和服务器之间交换的独立的双向帧序列。")]),e._v(" "),n("p",[e._v("流具有几个重要的特征：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("单个HTTP/2连接可以包含多个并发打开的流，其中任一端点都可以交错多个流中的帧。")])]),e._v(" "),n("li",[n("p",[e._v("流可以被单方面建立和使用，也可以由客户端或服务器共享。")])]),e._v(" "),n("li",[n("p",[e._v("任一端点均可关闭流。")])]),e._v(" "),n("li",[n("p",[e._v("在流上发送帧的顺序很重要。接受者按接收顺序处理帧。特别是，"),n("code",[e._v("HEADERS")]),e._v("和"),n("code",[e._v("DATA")]),e._v("帧的顺序在语义上很重要。")])]),e._v(" "),n("li",[n("p",[e._v("流由整数标识。通过端点启动流，将流标识符分配给流。")])])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"5"}},[e._v("\n"),n("li",[e._v("Streams and Multiplexing")]),e._v("\n")]),e._v("\n"),n("p",[e._v('A "stream" is an independent, bidirectional sequence of frames\nexchanged between the client and server within an HTTP/2 connection.\nStreams have several important characteristics:')]),e._v("\n"),n("p",[e._v("o  A single HTTP/2 connection can contain multiple concurrently open\nstreams, with either endpoint interleaving frames from multiple\nstreams.")]),e._v("\n"),n("p",[e._v("o  Streams can be established and used unilaterally or shared by\neither the client or server.")]),e._v("\n"),n("p",[e._v("o  Streams can be closed by either endpoint.")]),e._v("\n"),n("p",[e._v("o  The order in which frames are sent on a stream is significant.\nRecipients process frames in the order they are received.  In\nparticular, the order of HEADERS and DATA frames is semantically\nsignificant.")]),e._v("\n"),n("p",[e._v("o  Streams are identified by an integer.  Stream identifiers are\nassigned to streams by the endpoint initiating the stream.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_5-1-流状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-流状态"}},[e._v("#")]),e._v(" 5.1 流状态")]),e._v(" "),n("p",[e._v("流的生命周期如图2所示。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("                                +--------+\n                        send PP |        | recv PP\n                       ,--------|  idle  |--------.\n                      /         |        |         \\\n                     v          +--------+          v\n              +----------+          |           +----------+\n              |          |          | send H /  |          |\n       ,------| reserved |          | recv H    | reserved |------.\n       |      | (local)  |          |           | (remote) |      |\n       |      +----------+          v           +----------+      |\n       |          |             +--------+             |          |\n       |          |     recv ES |        | send ES     |          |\n       |   send H |     ,-------|  open  |-------.     | recv H   |\n       |          |    /        |        |        \\    |          |\n       |          v   v         +--------+         v   v          |\n       |      +----------+          |           +----------+      |\n       |      |   half   |          |           |   half   |      |\n       |      |  closed  |          | send R /  |  closed  |      |\n       |      | (remote) |          | recv R    | (local)  |      |\n       |      +----------+          |           +----------+      |\n       |           |                |                 |           |\n       |           | send ES /      |       recv ES / |           |\n       |           | send R /       v        send R / |           |\n       |           | recv R     +--------+   recv R   |           |\n       | send R /  `-----------\x3e|        |<-----------'  send R / |\n       | recv R                 | closed |               recv R   |\n       `-----------------------\x3e|        |<----------------------'\n                                +--------+\n\n          send:   endpoint sends this frame\n          recv:   endpoint receives this frame\n\n          H:  HEADERS frame (with implied CONTINUATIONs)\n          PP: PUSH_PROMISE frame (with implied CONTINUATIONs)\n          ES: END_STREAM flag\n          R:  RST_STREAM frame\n\n                          Figure 2: Stream States\n\n")])])]),n("p",[e._v("请注意，此图显示了流状态转换以及仅影响这些转换的帧和标志。在这方面，"),n("code",[e._v("CONTINUATION")]),e._v("帧不会导致状态转换。它们实际上是它们遵循的"),n("code",[e._v("HEADERS")]),e._v("或"),n("code",[e._v("PUSH_PROMISE")]),e._v("的一部分。")]),e._v(" "),n("p",[e._v("为了进行状态转换，将"),n("code",[e._v("END_STREAM")]),e._v("标志作为对其承载帧的单独事件进行处理。设置了"),n("code",[e._v("END_STREAM")]),e._v("标志的"),n("code",[e._v("HEADERS")]),e._v("帧可能导致两个状态转换。")]),e._v(" "),n("p",[e._v("两个端点都具有流状态的主观视图，当传输帧时，状态可能会有所不同。端点不协调流的创建；它们是由任一端点单方面创建的。状态不匹配的负面影响仅限于发送"),n("code",[e._v("RST_STREAM")]),e._v("之后的“关闭”状态，其中在关闭后的一段时间内可能会接收到帧。")]),e._v(" "),n("p",[e._v("流具有以下状态：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("idle:")]),e._v(" "),n("p",[e._v("所有流均以"),n("code",[e._v("idle")]),e._v("状态开始。")]),e._v(" "),n("p",[e._v("从此状态开始，以下转换有效：")]),e._v(" "),n("ul",[n("li",[e._v("发送或接收"),n("code",[e._v("HEADERS")]),e._v("帧会使流变为"),n("code",[e._v("open")]),e._v("状态。如第5.1.1节所述选择流标识符。相同的"),n("code",[e._v("HEADERS")]),e._v("帧还可以使流立即变为"),n("code",[e._v("half-closed")]),e._v("。")]),e._v(" "),n("li",[e._v("在另一个流上发送"),n("code",[e._v("PUSH_PROMISE")]),e._v("帧保留标识为以后使用的空闲流。保留流的流状态转换为"),n("code",[e._v("reserved (local)")]),e._v("。")]),e._v(" "),n("li",[e._v("在另一个流上接收"),n("code",[e._v("PUSH_PROMISE")]),e._v("帧将保留一个空闲流，该空闲流将被标识以供以后使用。保留流的流状态转换为"),n("code",[e._v("reserved (remote)")]),e._v("。")]),e._v(" "),n("li",[e._v("请注意，"),n("code",[e._v("PUSH_PROMISE")]),e._v("帧不是在空闲流上发送的，而是在Promised Stream ID字段中引用新保留的流。")])]),e._v(" "),n("p",[e._v("在这种状态下，在流上接收到除"),n("code",[e._v("HEADERS")]),e._v("或"),n("code",[e._v("PRIORITY")]),e._v("以外的任何帧，都必须视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")])]),e._v(" "),n("li",[n("p",[e._v("reserved (local):")]),e._v(" "),n("p",[e._v("处于"),n("code",[e._v("reserved (local)")]),e._v("状态的流是通过发送"),n("code",[e._v("PUSH_PROMISE")]),e._v("帧承诺的。"),n("code",[e._v("PUSH_PROMISE")]),e._v("帧通过将流与远程对等方启动的开放流相关联来保留空闲流（请参见第8.2节）。")]),e._v(" "),n("p",[e._v("在这种状态下，只能进行以下转换：")]),e._v(" "),n("ul",[n("li",[e._v("端点可以发送HEADERS帧。这将导致流以"),n("code",[e._v("half-closed (remote)")]),e._v("状态打开。")]),e._v(" "),n("li",[e._v("任一端点均可发送"),n("code",[e._v("RST_STREAM")]),e._v("帧以使流转为"),n("code",[e._v("closed")]),e._v("。这将释放流保留。")])]),e._v(" "),n("p",[e._v("在这种状态下，端点不得发送除"),n("code",[e._v("HEADERS")]),e._v("、"),n("code",[e._v("RST_STREAM")]),e._v("或"),n("code",[e._v("PRIORITY")]),e._v("以外的任何类型的帧。")]),e._v(" "),n("p",[e._v("在这种状态下可以接收一个"),n("code",[e._v("PRIORITY")]),e._v("或"),n("code",[e._v("WINDOW_UPDATE")]),e._v("帧。在这种状态下，在流上接收除"),n("code",[e._v("RST_STREAM")]),e._v("、"),n("code",[e._v("PRIORITY")]),e._v("或"),n("code",[e._v("WINDOW_UPDATE")]),e._v("以外的任何类型的帧，都必须视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")])]),e._v(" "),n("li",[n("p",[e._v("reserved (remote):")]),e._v(" "),n("p",[e._v("处于"),n("code",[e._v("reserved (remote)")]),e._v("状态的流已被远程对等方保留。")]),e._v(" "),n("p",[e._v("在这种状态下，只能进行以下转换：")]),e._v(" "),n("ul",[n("li",[e._v("接收"),n("code",[e._v("HEADERS")]),e._v("帧会使流转换为"),n("code",[e._v("half-closed (local)")]),e._v("。")]),e._v(" "),n("li",[e._v("任一端点均可发送"),n("code",[e._v("RST_STREAM")]),e._v("帧以使流"),n("code",[e._v("closed")]),e._v("。这将释放流保留。")])]),e._v(" "),n("p",[e._v("端点可以在这种状态下发送一个"),n("code",[e._v("PRIORITY")]),e._v("帧来重新排序保留流的优先级。在这种状态下，端点不得发送除"),n("code",[e._v("RST_STREAM")]),e._v("，"),n("code",[e._v("WINDOW_UPDATE")]),e._v("或"),n("code",[e._v("PRIORITY")]),e._v("以外的任何类型的帧。")]),e._v(" "),n("p",[e._v("在这种状态下，在流上接收除"),n("code",[e._v("HEADERS")]),e._v("，"),n("code",[e._v("RST_STREAM")]),e._v("或"),n("code",[e._v("PRIORITY")]),e._v("以外的任何类型的帧，都必须视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")])]),e._v(" "),n("li",[n("p",[e._v("open:")]),e._v(" "),n("p",[e._v("处于"),n("code",[e._v("open")]),e._v("状态的流可被两个对等方用来发送任何类型的帧。在这种状态下，发送对等方遵守通告的流级别流控制限制（第5.2节）。")]),e._v(" "),n("p",[e._v("从此状态，任一端点都可以发送设置了"),n("code",[e._v("END_STREAM")]),e._v("标志的帧，这会使流转换为"),n("code",[e._v("half-closed")]),e._v("状态之一。发送"),n("code",[e._v("END_STREAM")]),e._v("标志的端点使流状态变为"),n("code",[e._v("half-closed (local)")]),e._v("；接收到"),n("code",[e._v("END_STREAM")]),e._v("标志的端点使流状态变为"),n("code",[e._v("half-closed (remote)")]),e._v("。")]),e._v(" "),n("p",[e._v("任何一个端点都可以从该状态发送"),n("code",[e._v("RST_STREAM")]),e._v("帧，从而使其立即转换为"),n("code",[e._v("closed")]),e._v("状态。")])]),e._v(" "),n("li",[n("p",[e._v("half-closed (local):")]),e._v(" "),n("p",[e._v("处于"),n("code",[e._v("half-closed (local)")]),e._v("状态的流不能用于发送"),n("code",[e._v("WINDOW_UPDATE")]),e._v("，"),n("code",[e._v("PRIORITY")]),e._v("和"),n("code",[e._v("RST_STREAM")]),e._v("以外的帧。")]),e._v(" "),n("p",[e._v("当收到包含"),n("code",[e._v("END_STREAM")]),e._v("标志的帧或任一对等方发送"),n("code",[e._v("RST_STREAM")]),e._v("帧时，流将从此状态转换为"),n("code",[e._v("closed")]),e._v("。")]),e._v(" "),n("p",[e._v("端点可以在此状态下接收任何类型的帧。要继续接收流控制的帧，必须使用"),n("code",[e._v("WINDOW_UPDATE")]),e._v("帧提供流控制信用。在这种状态下，接收器可以忽略"),n("code",[e._v("WINDOW_UPDATE")]),e._v("帧，这些帧可能在发送带有"),n("code",[e._v("END_STREAM")]),e._v("标志的帧之后的短时间内到达。")]),e._v(" "),n("p",[e._v("在此状态下接收的"),n("code",[e._v("PRIORITY")]),e._v("帧用于重新确定依赖于已标识流的流的优先级。")])]),e._v(" "),n("li",[n("p",[e._v("half-closed (remote):")]),e._v(" "),n("p",[e._v("对等方不再使用"),n("code",[e._v("half-closed (remote):")]),e._v("流发送帧。在这种状态下，端点不再必须维护接收器流控制窗口。")]),e._v(" "),n("p",[e._v("如果端点收到处于此状态的流的"),n("code",[e._v("WINDOW_UPDATE")]),e._v("，"),n("code",[e._v("PRIORITY")]),e._v("或"),n("code",[e._v("RST_STREAM")]),e._v("以外的其他帧，则它必须以"),n("code",[e._v("STREAM_CLOSED")]),e._v("类型的流错误（第5.4.2节）作出响应。")]),e._v(" "),n("p",[e._v("端点可以使用"),n("code",[e._v("half-closed (remote)")]),e._v("流来发送任何类型的帧。在这种状态下，端点继续遵守通告的流级流量控制限制（第5.2节）。")]),e._v(" "),n("p",[e._v("通过发送包含"),n("code",[e._v("END_STREAM")]),e._v("标志的帧或任何一个对等方发送"),n("code",[e._v("RST_STREAM")]),e._v("帧，流都可以从此状态转换为"),n("code",[e._v("closed")]),e._v("。")])]),e._v(" "),n("li",[n("p",[e._v("closed:")]),e._v(" "),n("p",[n("code",[e._v("closed")]),e._v("状态是终止状态。")]),e._v(" "),n("p",[e._v("端点不得在封闭流上发送除"),n("code",[e._v("PRIORITY")]),e._v("以外的帧。接收到"),n("code",[e._v("RST_STREAM")]),e._v("之后接收到除"),n("code",[e._v("PRIORITY")]),e._v("以外的任何帧的端点必须将其视为"),n("code",[e._v("STREAM_CLOSED")]),e._v("类型的流错误（5.4.2节）。类似地，在接收到设置了"),n("code",[e._v("END_STREAM")]),e._v("标志的帧之后接收任何帧的端点务必将其视为"),n("code",[e._v("STREAM_CLOSED")]),e._v("类型的连接错误（第5.4.1节），除非如下所述允许该帧。")]),e._v(" "),n("p",[e._v("发送包含"),n("code",[e._v("END_STREAM")]),e._v("标志的"),n("code",[e._v("DATA")]),e._v("或"),n("code",[e._v("HEADERS")]),e._v("帧后，可以在此状态下短时间内接收"),n("code",[e._v("WINDOW_UPDATE")]),e._v("或"),n("code",[e._v("RST_STREAM")]),e._v("帧。在远程对等方接收并处理"),n("code",[e._v("RST_STREAM")]),e._v("或带有"),n("code",[e._v("END_STREAM")]),e._v("标志的帧之前，它可能会发送这些类型的帧。端点必须忽略在这种状态下接收到的"),n("code",[e._v("WINDOW_UPDATE")]),e._v("或"),n("code",[e._v("RST_STREAM")]),e._v("帧，尽管端点可以选择将发送"),n("code",[e._v("END_STREAM")]),e._v("之后很长时间到达的帧视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("可以在封闭流上发送"),n("code",[e._v("PRIORITY")]),e._v("帧，以区分依赖于封闭流的流的优先级。端点应该处理"),n("code",[e._v("PRIORITY")]),e._v("帧，但是如果从依赖关系树中删除了流，则可以忽略它们（参见第5.3.4节）。")]),e._v(" "),n("p",[e._v("如果由于发送"),n("code",[e._v("RST_STREAM")]),e._v("帧而达到此状态，则接收"),n("code",[e._v("RST_STREAM")]),e._v("的对等端可能已经发送了（或已排队发送）无法撤消的流上的帧。端点发送"),n("code",[e._v("RST_STREAM")]),e._v("帧后，必须忽略其在关闭流上接收的帧。端点可以选择限制其忽略帧的时间段，并将在此时间之后到达的帧视为错误。")]),e._v(" "),n("p",[e._v("发送"),n("code",[e._v("RST_STREAM")]),e._v("之后收到的流控制帧（即"),n("code",[e._v("DATA")]),e._v("）计入连接流控制窗口。即使这些帧可能会被忽略，因为它们是在发送方接收"),n("code",[e._v("RST_STREAM")]),e._v("之前发送的，因此发送方将考虑将这些帧计入流控制窗口。")]),e._v(" "),n("p",[e._v("端点在发送"),n("code",[e._v("RST_STREAM")]),e._v("之后可能会收到"),n("code",[e._v("PUSH_PROMISE")]),e._v("帧。即使相关联的流已被重置，"),n("code",[e._v("PUSH_PROMISE")]),e._v("也会使流变为"),n("code",[e._v("reserved")]),e._v("。因此，需要"),n("code",[e._v("RST_STREAM")]),e._v("来关闭不需要的承诺流。")])])]),e._v(" "),n("p",[e._v("在本文档其他地方没有更具体的指导的情况下，实现应将状态描述中未明确允许的帧接收视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。请注意，可以在任何流状态下发送和接收"),n("code",[e._v("PRIORITY")]),e._v("。未知类型的帧将被忽略。")]),e._v(" "),n("p",[e._v("HTTP请求/响应交换的状态转换示例可以在第8.1节中找到。有关服务器推送的状态转换的示例，请参见第8.2.1和8.2.2节。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.1.  Stream States")]),e._v("\n"),n("p",[e._v("The lifecycle of a stream is shown in Figure 2.\n+--------+\nsend PP |        | recv PP\n,--------|  idle  |--------.\n/         |        |         "),n("br"),e._v("\nv          +--------+          v\n+----------+          |           +----------+\n|          |          | send H /  |          |\n,------| reserved |          | recv H    | reserved |------.\n|      | (local)  |          |           | (remote) |      |\n|      +----------+          v           +----------+      |\n|          |             +--------+             |          |\n|          |     recv ES |        | send ES     |          |\n|   send H |     ,-------|  open  |-------.     | recv H   |\n|          |    /        |        |        \\    |          |\n|          v   v         +--------+         v   v          |\n|      +----------+          |           +----------+      |\n|      |   half   |          |           |   half   |      |\n|      |  closed  |          | send R /  |  closed  |      |\n|      | (remote) |          | recv R    | (local)  |      |\n|      +----------+          |           +----------+      |\n|           |                |                 |           |\n|           | send ES /      |       recv ES / |           |\n|           | send R /       v        send R / |           |\n|           | recv R     +--------+   recv R   |           |\n| send R /  "),n("code",[e._v("-----------\x3e| |<-----------' send R / | | recv R | closed | recv R |")]),e._v("-----------------------\x3e|        |<----------------------'\n+--------+")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("      send:   endpoint sends this frame\n      recv:   endpoint receives this frame\n\n      H:  HEADERS frame (with implied CONTINUATIONs)\n      PP: PUSH_PROMISE frame (with implied CONTINUATIONs)\n      ES: END_STREAM flag\n      R:  RST_STREAM frame\n\n                      Figure 2: Stream States\n")])])]),n("p",[e._v("Note that this diagram shows stream state transitions and the frames\nand flags that affect those transitions only.  In this regard,\nCONTINUATION frames do not result in state transitions; they are\neffectively part of the HEADERS or PUSH_PROMISE that they follow.")]),e._v(" "),n("p",[e._v("For the purpose of state transitions, the END_STREAM flag is\nprocessed as a separate event to the frame that bears it; a HEADERS\nframe with the END_STREAM flag set can cause two state transitions.")]),e._v(" "),n("p",[e._v('Both endpoints have a subjective view of the state of a stream that\ncould be different when frames are in transit.  Endpoints do not\ncoordinate the creation of streams; they are created unilaterally by\neither endpoint.  The negative consequences of a mismatch in states\nare limited to the "closed" state after sending RST_STREAM, where\nframes might be received for some time after closing.')]),e._v(" "),n("p",[e._v("Streams have the following states:")]),e._v(" "),n("p",[e._v('idle:\nAll streams start in the "idle" state.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('The following transitions are valid from this state:\n\n*  Sending or receiving a HEADERS frame causes the stream to\n    become "open".  The stream identifier is selected as described\n    in Section 5.1.1.  The same HEADERS frame can also cause a\n    stream to immediately become "half-closed".\n\n*  Sending a PUSH_PROMISE frame on another stream reserves the\n    idle stream that is identified for later use.  The stream state\n    for the reserved stream transitions to "reserved (local)".\n\n*  Receiving a PUSH_PROMISE frame on another stream reserves an\n    idle stream that is identified for later use.  The stream state\n    for the reserved stream transitions to "reserved (remote)".\n\n*  Note that the PUSH_PROMISE frame is not sent on the idle stream\n    but references the newly reserved stream in the Promised Stream\n    ID field.\n\nReceiving any frame other than HEADERS or PRIORITY on a stream in\nthis state MUST be treated as a connection error (Section 5.4.1)\nof type PROTOCOL_ERROR.\n')])])]),n("p",[e._v('reserved (local):\nA stream in the "reserved (local)" state is one that has been\npromised by sending a PUSH_PROMISE frame.  A PUSH_PROMISE frame\nreserves an idle stream by associating the stream with an open\nstream that was initiated by the remote peer (see Section 8.2).')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('In this state, only the following transitions are possible:\n\n*  The endpoint can send a HEADERS frame.  This causes the stream\n    to open in a "half-closed (remote)" state.\n\n*  Either endpoint can send a RST_STREAM frame to cause the stream\n    to become "closed".  This releases the stream reservation.\n\n\nAn endpoint MUST NOT send any type of frame other than HEADERS,\nRST_STREAM, or PRIORITY in this state.\n\nA PRIORITY or WINDOW_UPDATE frame MAY be received in this state.\nReceiving any type of frame other than RST_STREAM, PRIORITY, or\nWINDOW_UPDATE on a stream in this state MUST be treated as a\nconnection error (Section 5.4.1) of type PROTOCOL_ERROR.\n')])])]),n("p",[e._v('reserved (remote):\nA stream in the "reserved (remote)" state has been reserved by a\nremote peer.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('In this state, only the following transitions are possible:\n\n*  Receiving a HEADERS frame causes the stream to transition to\n    "half-closed (local)".\n\n*  Either endpoint can send a RST_STREAM frame to cause the stream\n    to become "closed".  This releases the stream reservation.\n\nAn endpoint MAY send a PRIORITY frame in this state to\nreprioritize the reserved stream.  An endpoint MUST NOT send any\ntype of frame other than RST_STREAM, WINDOW_UPDATE, or PRIORITY in\nthis state.\n\nReceiving any type of frame other than HEADERS, RST_STREAM, or\nPRIORITY on a stream in this state MUST be treated as a connection\nerror (Section 5.4.1) of type PROTOCOL_ERROR.\n')])])]),n("p",[e._v('open:\nA stream in the "open" state may be used by both peers to send\nframes of any type.  In this state, sending peers observe\nadvertised stream-level flow-control limits (Section 5.2).')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('From this state, either endpoint can send a frame with an\nEND_STREAM flag set, which causes the stream to transition into\none of the "half-closed" states.  An endpoint sending an\nEND_STREAM flag causes the stream state to become "half-closed\n(local)"; an endpoint receiving an END_STREAM flag causes the\nstream state to become "half-closed (remote)".\n\nEither endpoint can send a RST_STREAM frame from this state,\ncausing it to transition immediately to "closed".\n')])])]),n("p",[e._v('half-closed (local):\nA stream that is in the "half-closed (local)" state cannot be used\nfor sending frames other than WINDOW_UPDATE, PRIORITY, and\nRST_STREAM.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('A stream transitions from this state to "closed" when a frame that\ncontains an END_STREAM flag is received or when either peer sends\na RST_STREAM frame.\n\nAn endpoint can receive any type of frame in this state.\nProviding flow-control credit using WINDOW_UPDATE frames is\nnecessary to continue receiving flow-controlled frames.  In this\nstate, a receiver can ignore WINDOW_UPDATE frames, which might\narrive for a short period after a frame bearing the END_STREAM\nflag is sent.\n\nPRIORITY frames received in this state are used to reprioritize\nstreams that depend on the identified stream.\n')])])]),n("p",[e._v('half-closed (remote):\nA stream that is "half-closed (remote)" is no longer being used by\nthe peer to send frames.  In this state, an endpoint is no longer\nobligated to maintain a receiver flow-control window.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('If an endpoint receives additional frames, other than\nWINDOW_UPDATE, PRIORITY, or RST_STREAM, for a stream that is in\nthis state, it MUST respond with a stream error (Section 5.4.2) of\ntype STREAM_CLOSED.\n\nA stream that is "half-closed (remote)" can be used by the\nendpoint to send frames of any type.  In this state, the endpoint\ncontinues to observe advertised stream-level flow-control limits\n(Section 5.2).\n\nA stream can transition from this state to "closed" by sending a\nframe that contains an END_STREAM flag or when either peer sends a\nRST_STREAM frame.\n')])])]),n("p",[e._v('closed:\nThe "closed" state is the terminal state.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('An endpoint MUST NOT send frames other than PRIORITY on a closed\nstream.  An endpoint that receives any frame other than PRIORITY\nafter receiving a RST_STREAM MUST treat that as a stream error\n(Section 5.4.2) of type STREAM_CLOSED.  Similarly, an endpoint\nthat receives any frames after receiving a frame with the\nEND_STREAM flag set MUST treat that as a connection error\n(Section 5.4.1) of type STREAM_CLOSED, unless the frame is\npermitted as described below.\n\nWINDOW_UPDATE or RST_STREAM frames can be received in this state\nfor a short period after a DATA or HEADERS frame containing an\nEND_STREAM flag is sent.  Until the remote peer receives and\nprocesses RST_STREAM or the frame bearing the END_STREAM flag, it\nmight send frames of these types.  Endpoints MUST ignore\nWINDOW_UPDATE or RST_STREAM frames received in this state, though\nendpoints MAY choose to treat frames that arrive a significant\ntime after sending END_STREAM as a connection error\n(Section 5.4.1) of type PROTOCOL_ERROR.\n\nPRIORITY frames can be sent on closed streams to prioritize\nstreams that are dependent on the closed stream.  Endpoints SHOULD\nprocess PRIORITY frames, though they can be ignored if the stream\nhas been removed from the dependency tree (see Section 5.3.4).\n\nIf this state is reached as a result of sending a RST_STREAM\nframe, the peer that receives the RST_STREAM might have already\nsent -- or enqueued for sending -- frames on the stream that\ncannot be withdrawn.  An endpoint MUST ignore frames that it\nreceives on closed streams after it has sent a RST_STREAM frame.\nAn endpoint MAY choose to limit the period over which it ignores\nframes and treat frames that arrive after this time as being in\nerror.\n\nFlow-controlled frames (i.e., DATA) received after sending\nRST_STREAM are counted toward the connection flow-control window.\nEven though these frames might be ignored, because they are sent\nbefore the sender receives the RST_STREAM, the sender will\nconsider the frames to count against the flow-control window.\n\nAn endpoint might receive a PUSH_PROMISE frame after it sends\nRST_STREAM.  PUSH_PROMISE causes a stream to become "reserved"\neven if the associated stream has been reset.  Therefore, a\nRST_STREAM is needed to close an unwanted promised stream.\n')])])]),n("p",[e._v("In the absence of more specific guidance elsewhere in this document,\nimplementations SHOULD treat the receipt of a frame that is not\nexpressly permitted in the description of a state as a connection\nerror (Section 5.4.1) of type PROTOCOL_ERROR.  Note that PRIORITY can\nbe sent and received in any stream state.  Frames of unknown types\nare ignored.")]),e._v(" "),n("p",[e._v("An example of the state transitions for an HTTP request/response\nexchange can be found in Section 8.1.  An example of the state\ntransitions for server push can be found in Sections 8.2.1 and 8.2.2.")])])])]),e._v(" "),n("h4",{attrs:{id:"_5-1-1-流标识符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-流标识符"}},[e._v("#")]),e._v(" 5.1.1 流标识符")]),e._v(" "),n("p",[e._v("用无符号31位整数来标识流。由客户端发起的流必须使用奇数流标识符。由服务器发起的流必须使用偶数流标识符。流标识符零（0x0）用于连接控制消息。流标识符零不能用于建立新流。")]),e._v(" "),n("p",[e._v("升级到HTTP/2（请参阅第3.2节）的HTTP/1.1请求将以流标识符1（0x1）进行响应。升级完成后，流0x1被"),n("code",[e._v("half-closed (local)")]),e._v("到客户端。因此，从HTTP/1.1升级的客户端无法将流0x1选择为新的流标识符。")]),e._v(" "),n("p",[e._v("新建立的流的标识符必须在数值上大于发起端点已打开或保留的所有流。这控制使用"),n("code",[e._v("HEADERS")]),e._v("帧打开的流和使用"),n("code",[e._v("PUSH_PROMISE")]),e._v("保留的流。收到未知流标识符的端点必须以"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）做出响应。")]),e._v(" "),n("p",[e._v("首次使用新的流标识符会隐式关闭处于"),n("code",[e._v("idle")]),e._v("状态的所有流，该流可能已由该对等方使用值较低的流标识符启动。例如，如果客户端在流7上发送"),n("code",[e._v("HEADERS")]),e._v("帧而没有在流5上发送帧，则当发送或接收流7的第一个帧时，流5转换为"),n("code",[e._v("closed")]),e._v("状态。")]),e._v(" "),n("p",[e._v("流标识符不能重复使用。长期存在的连接可能导致端点耗尽可用范围的流标识符。无法建立新的流标识符的客户端可以为新的流建立新的连接。无法建立新流标识符的服务器可以发送"),n("code",[e._v("GOAWAY")]),e._v("帧，以便客户端被迫为新流打开新连接。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.1.1.  Stream Identifiers")]),e._v("\n"),n("p",[e._v("Streams are identified with an unsigned 31-bit integer.  Streams\ninitiated by a client MUST use odd-numbered stream identifiers; those\ninitiated by the server MUST use even-numbered stream identifiers.  A\nstream identifier of zero (0x0) is used for connection control\nmessages; the stream identifier of zero cannot be used to establish a\nnew stream.")]),e._v("\n"),n("p",[e._v('HTTP/1.1 requests that are upgraded to HTTP/2 (see Section 3.2) are\nresponded to with a stream identifier of one (0x1).  After the\nupgrade completes, stream 0x1 is "half-closed (local)" to the client.\nTherefore, stream 0x1 cannot be selected as a new stream identifier\nby a client that upgrades from HTTP/1.1.')]),e._v("\n"),n("p",[e._v("The identifier of a newly established stream MUST be numerically\ngreater than all streams that the initiating endpoint has opened or\nreserved.  This governs streams that are opened using a HEADERS frame\nand streams that are reserved using PUSH_PROMISE.  An endpoint that\nreceives an unexpected stream identifier MUST respond with a\nconnection error (Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v("\n"),n("p",[e._v('The first use of a new stream identifier implicitly closes all\nstreams in the "idle" state that might have been initiated by that\npeer with a lower-valued stream identifier.  For example, if a client\nsends a HEADERS frame on stream 7 without ever sending a frame on\nstream 5, then stream 5 transitions to the "closed" state when the\nfirst frame for stream 7 is sent or received.')]),e._v("\n"),n("p",[e._v("Stream identifiers cannot be reused.  Long-lived connections can\nresult in an endpoint exhausting the available range of stream\nidentifiers.  A client that is unable to establish a new stream\nidentifier can establish a new connection for new streams.  A server\nthat is unable to establish a new stream identifier can send a GOAWAY\nframe so that the client is forced to open a new connection for new\nstreams.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-1-2-流并发性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-2-流并发性"}},[e._v("#")]),e._v(" 5.1.2 流并发性")]),e._v(" "),n("p",[e._v("对等方可以使用"),n("code",[e._v("SETTINGS")]),e._v("帧内的"),n("code",[e._v("SETTINGS_MAX_CONCURRENT_STREAMS")]),e._v("参数（请参阅第6.5.2节）来限制并发活动流的数量。最大并发流设置特定于每个端点，并且仅适用于接收该设置的对等方。即，客户端指定服务器可以启动的并发流的最大数量，服务器指定客户端可以启动的并发流的最大数量。")]),e._v(" "),n("p",[e._v("处于"),n("code",[e._v("open")]),e._v("状态或处于"),n("code",[e._v("half-closed")]),e._v("状态中的任一状态的流均计入允许端点打开的最大流数。这三种状态中任何一种的流都将计入"),n("code",[e._v("SETTINGS_MAX_CONCURRENT_STREAMS")]),e._v("设置中公布的限制。处于任何"),n("code",[e._v("reserved")]),e._v("状态的流均不会计入流限制。")]),e._v(" "),n("p",[e._v("端点不得超过其对等方设置的限制。接收到导致其通告的并发流限制被超过的"),n("code",[e._v("HEADERS")]),e._v("帧的端点必须将此视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("或"),n("code",[e._v("REFUSED_STREAM")]),e._v("类型的流错误（第5.4.2节）。错误代码的选择确定端点是否希望启用自动重试（有关详细信息，请参见第8.1.4节）。")]),e._v(" "),n("p",[e._v("希望将"),n("code",[e._v("SETTINGS_MAX_CONCURRENT_STREAMS")]),e._v("的值减小到当前打开流的数量以下的端点可以关闭超过新值的流，或者允许流完成。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.1.2.  Stream Concurrency")]),e._v("\n"),n("p",[e._v("A peer can limit the number of concurrently active streams using the\nSETTINGS_MAX_CONCURRENT_STREAMS parameter (see Section 6.5.2) within\na SETTINGS frame.  The maximum concurrent streams setting is specific\nto each endpoint and applies only to the peer that receives the\nsetting.  That is, clients specify the maximum number of concurrent\nstreams the server can initiate, and servers specify the maximum\nnumber of concurrent streams the client can initiate.")]),e._v("\n"),n("p",[e._v('Streams that are in the "open" state or in either of the "half-\nclosed" states count toward the maximum number of streams that an\nendpoint is permitted to open.  Streams in any of these three states\ncount toward the limit advertised in the\nSETTINGS_MAX_CONCURRENT_STREAMS setting.  Streams in either of the\n"reserved" states do not count toward the stream limit.')]),e._v("\n"),n("p",[e._v("Endpoints MUST NOT exceed the limit set by their peer.  An endpoint\nthat receives a HEADERS frame that causes its advertised concurrent\nstream limit to be exceeded MUST treat this as a stream error\n(Section 5.4.2) of type PROTOCOL_ERROR or REFUSED_STREAM.  The choice\nof error code determines whether the endpoint wishes to enable\nautomatic retry (see Section 8.1.4) for details).")]),e._v("\n"),n("p",[e._v("An endpoint that wishes to reduce the value of\nSETTINGS_MAX_CONCURRENT_STREAMS to a value that is below the current\nnumber of open streams can either close streams that exceed the new\nvalue or allow streams to complete.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_5-2-流控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-流控制"}},[e._v("#")]),e._v(" 5.2 流控制")]),e._v(" "),n("p",[e._v("使用流进行多路复用会引起TCP连接使用方面的争用，从而导致流阻塞。流控制方案可确保同一连接上的流不会造成相消干扰。流控制既用于单个流，也用于整个连接。")]),e._v(" "),n("p",[e._v("HTTP/2通过使用"),n("code",[e._v("WINDOW_UPDATE")]),e._v("框架提供流控制（第6.9节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.2.  Flow Control")]),e._v("\n"),n("p",[e._v("Using streams for multiplexing introduces contention over use of the\nTCP connection, resulting in blocked streams.  A flow-control scheme\nensures that streams on the same connection do not destructively\ninterfere with each other.  Flow control is used for both individual\nstreams and for the connection as a whole.")]),e._v("\n"),n("p",[e._v("HTTP/2 provides for flow control through use of the WINDOW_UPDATE\nframe (Section 6.9).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-2-1-流控制原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-流控制原理"}},[e._v("#")]),e._v(" 5.2.1 流控制原理")]),e._v(" "),n("p",[e._v("HTTP/2流流控制旨在允许使用各种流控制算法而无需更改协议。 HTTP/2中的流控制具有以下特征：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("流控制特定于连接。两种类型的流控制都在单跳的端点之间，而不是在整个端到端路径上。")])]),e._v(" "),n("li",[n("p",[e._v("流控制基于"),n("code",[e._v("WINDOW_UPDATE")]),e._v("帧。接收方通告它们准备在流上以及整个连接中接收多少个八位位组。这是基于信用的方案。")])]),e._v(" "),n("li",[n("p",[e._v("流量控制是方向性的，由接收器提供总体控制。接收者可以选择设置每个流和整个连接所需的任何窗口大小。发送方必须遵守接收方施加的流量控制限制。客户端，服务器和中介都独立地将其流控制窗口发布为接收方，并在发送时遵守其对等方设置的流控制限制。")])]),e._v(" "),n("li",[n("p",[e._v("对于新流和整个连接，流控制窗口的初始值为65,535个八位位组。")])]),e._v(" "),n("li",[n("p",[e._v("帧类型确定流控制是否适用于帧。在本文档中指定的帧中，只有"),n("code",[e._v("DATA")]),e._v("帧要进行流控制；否则，仅对"),n("code",[e._v("DATA")]),e._v("帧进行流控制。所有其他帧类型都不会占用广告流控制窗口中的空间。这确保了重要的控制帧不会被流控制阻塞。")])]),e._v(" "),n("li",[n("p",[e._v("无法禁用流控制。")])]),e._v(" "),n("li",[n("p",[e._v("HTTP/2仅定义"),n("code",[e._v("WINDOW_UPDATE")]),e._v("帧的格式和语义（第6.9节）。该文件没有规定接收者如何决定何时发送该帧或它发送的值，也没有规定发送者如何选择发送分组。实现者可以选择任何适合其需求的算法。")])])]),e._v(" "),n("p",[e._v("实现还负责管理如何根据优先级发送请求和响应，选择如何避免对请求的行头阻塞以及管理新流的创建。这些算法的选择可以与任何流控制算法交互。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.2.1.  Flow-Control Principles")]),e._v("\n"),n("p",[e._v("HTTP/2 stream flow control aims to allow a variety of flow-control\nalgorithms to be used without requiring protocol changes.  Flow\ncontrol in HTTP/2 has the following characteristics:")]),e._v("\n"),n("ol",[e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("Flow control is specific to a connection.  Both types of flow\ncontrol are between the endpoints of a single hop and not over\nthe entire end-to-end path.")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("Flow control is based on WINDOW_UPDATE frames.  Receivers\nadvertise how many octets they are prepared to receive on a\nstream and for the entire connection.  This is a credit-based\nscheme.")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("Flow control is directional with overall control provided by the\nreceiver.  A receiver MAY choose to set any window size that it\ndesires for each stream and for the entire connection.  A sender\nMUST respect flow-control limits imposed by a receiver.  Clients,\nservers, and intermediaries all independently advertise their\nflow-control window as a receiver and abide by the flow-control\nlimits set by their peer when sending.")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("The initial value for the flow-control window is 65,535 octets\nfor both new streams and the overall connection.")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("The frame type determines whether flow control applies to a\nframe.  Of the frames specified in this document, only DATA\nframes are subject to flow control; all other frame types do not\nconsume space in the advertised flow-control window.  This\nensures that important control frames are not blocked by flow\ncontrol.")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("Flow control cannot be disabled.")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("HTTP/2 defines only the format and semantics of the WINDOW_UPDATE\nframe (Section 6.9).  This document does not stipulate how a\nreceiver decides when to send this frame or the value that it\nsends, nor does it specify how a sender chooses to send packets.\nImplementations are able to select any algorithm that suits their\nneeds.")]),e._v("\n")]),e._v("\n")]),e._v("\n"),n("p",[e._v("Implementations are also responsible for managing how requests and\nresponses are sent based on priority, choosing how to avoid head-of-\nline blocking for requests, and managing the creation of new streams.\nAlgorithm choices for these could interact with any flow-control\nalgorithm.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-2-2-适当使用流控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-适当使用流控制"}},[e._v("#")]),e._v(" 5.2.2 适当使用流控制")]),e._v(" "),n("p",[e._v("定义流控制以保护在资源约束下运行的端点。例如，代理需要在许多连接之间共享内存，并且可能具有较慢的上游连接和较快的下游连接。流控制解决了以下情况：接收器无法处理一个流上的数据，但希望继续处理同一连接中的其他流。")]),e._v(" "),n("p",[e._v("不需要此功能的部署可以通告最大大小的流控制窗口（2^31-1），并在接收到任何数据时通过发送"),n("code",[e._v("WINDOW_UPDATE")]),e._v("帧来维护此窗口。这有效地禁用了该接收器的流控制。相反，发送方始终要遵守接收方通告的流控制窗口。")]),e._v(" "),n("p",[e._v("资源受限（例如，内存）的部署可以采用流控制来限制对等方可以消耗的内存量。但是请注意，如果在不了解带宽延迟乘积的情况下启用了流控制，则会导致可用网络资源的最佳使用（请参阅[RFC7323]）。")]),e._v(" "),n("p",[e._v("即使完全了解当前的带宽延迟产品，执行流控制也可能很困难。使用流控制时，接收者务必及时从TCP接收缓冲区中读取。如果未读取并执行诸如"),n("code",[e._v("WINDOW_UPDATE")]),e._v("之类的关键帧，则可能会导致死锁。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.2.2.  Appropriate Use of Flow Control")]),e._v("\n"),n("p",[e._v("Flow control is defined to protect endpoints that are operating under\nresource constraints.  For example, a proxy needs to share memory\nbetween many connections and also might have a slow upstream\nconnection and a fast downstream one.  Flow-control addresses cases\nwhere the receiver is unable to process data on one stream yet wants\nto continue to process other streams in the same connection.")]),e._v("\n"),n("p",[e._v("Deployments that do not require this capability can advertise a flow-\ncontrol window of the maximum size (2^31-1) and can maintain this\nwindow by sending a WINDOW_UPDATE frame when any data is received.\nThis effectively disables flow control for that receiver.\nConversely, a sender is always subject to the flow-control window\nadvertised by the receiver.")]),e._v("\n"),n("p",[e._v("Deployments with constrained resources (for example, memory) can\nemploy flow control to limit the amount of memory a peer can consume.\nNote, however, that this can lead to suboptimal use of available\nnetwork resources if flow control is enabled without knowledge of the\nbandwidth-delay product (see [RFC7323]).")]),e._v("\n"),n("p",[e._v("Even with full awareness of the current bandwidth-delay product,\nimplementation of flow control can be difficult.  When using flow\ncontrol, the receiver MUST read from the TCP receive buffer in a\ntimely fashion.  Failure to do so could lead to a deadlock when\ncritical frames, such as WINDOW_UPDATE, are not read and acted upon.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_5-3-流优先级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-流优先级"}},[e._v("#")]),e._v(" 5.3 流优先级")]),e._v(" "),n("p",[e._v("客户端可以通过在打开流的"),n("code",[e._v("HEADERS")]),e._v("帧（第6.2节）中包括优先级信息来为新流分配优先级。在任何其他时间，可以使用"),n("code",[e._v("PRIORITY")]),e._v("帧（第6.3节）来更改流的优先级。")]),e._v(" "),n("p",[e._v("优先级划分的目的是允许端点表达在管理并发流时希望其对等方分配资源的方式。最重要的是，当发送容量有限时，可以使用优先级来选择传输帧的流。")]),e._v(" "),n("p",[e._v("可以通过将流标记为依赖于其他流的完成来对流进行优先级排序（第5.3.1节）。每个依赖项都分配了一个相对权重，该数字用于确定分配给依赖于同一流的流的可用资源的相对比例。")]),e._v(" "),n("p",[e._v("明确设置流的优先级输入到优先级处理中。它不保证该流相对于任何其他流的任何特定处理或传输顺序。端点不能强制对等方使用优先级按特定顺序处理并发流。因此，表达优先级只是一个建议。")]),e._v(" "),n("p",[e._v("可以从消息中省略优先级信息。在提供任何显式值之前使用默认值（第5.3.5节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.3.  Stream Priority")]),e._v("\n"),n("p",[e._v("A client can assign a priority for a new stream by including\nprioritization information in the HEADERS frame (Section 6.2) that\nopens the stream.  At any other time, the PRIORITY frame\n(Section 6.3) can be used to change the priority of a stream.")]),e._v("\n"),n("p",[e._v("The purpose of prioritization is to allow an endpoint to express how\nit would prefer its peer to allocate resources when managing\nconcurrent streams.  Most importantly, priority can be used to select\nstreams for transmitting frames when there is limited capacity for\nsending.")]),e._v("\n"),n("p",[e._v("Streams can be prioritized by marking them as dependent on the\ncompletion of other streams (Section 5.3.1).  Each dependency is\nassigned a relative weight, a number that is used to determine the\nrelative proportion of available resources that are assigned to\nstreams dependent on the same stream.")]),e._v("\n"),n("p",[e._v("Explicitly setting the priority for a stream is input to a\nprioritization process.  It does not guarantee any particular\nprocessing or transmission order for the stream relative to any other\nstream.  An endpoint cannot force a peer to process concurrent\nstreams in a particular order using priority.  Expressing priority is\ntherefore only a suggestion.")]),e._v("\n"),n("p",[e._v("Prioritization information can be omitted from messages.  Defaults\nare used prior to any explicit values being provided (Section 5.3.5).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-3-1-流依赖关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-1-流依赖关系"}},[e._v("#")]),e._v(" 5.3.1 流依赖关系")]),e._v(" "),n("p",[e._v("每个流都可以被赋予对另一个流的显式依赖关系，包括一个依赖关系表示优先向标识的流而不是依赖流分配资源;")]),e._v(" "),n("p",[e._v("不依赖任何其他流的流的流依赖关系为0x0。换句话说，不存在的流0构成树的根。")]),e._v(" "),n("p",[e._v("依赖于另一个流的流是从属流。流所依赖的流是父流。对当前不在树中的流的依赖性（例如处于"),n("code",[e._v("idle")]),e._v("状态的流）会导致该流被赋予默认优先级（第5.3.5节）。")]),e._v(" "),n("p",[e._v("在分配对另一个流的依赖性时，该流为作为父流的新依赖项添加。共享同一父对象的从属流不会相对于彼此排序。例如，如果流B和C依赖于流A，并且如果创建的流D依赖于流A，则这将导致A的依赖顺序，然后是B，C和D的任何顺序。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\n       A                 A\n      / \\      ==>      /|\\\n     B   C             B D C\n\nFigure 3: Example of Default Dependency Creation\n\n")])])]),n("p",[e._v("排他标志允许插入新级别的依赖关系。独占标志导致流成为其父流的唯一依赖项，从而导致其他依赖项变为依赖于独占流。在前面的示例中，如果创建的流D具有对流A的排他性依赖关系，则结果D将成为B和C的依赖关系父级。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("                         A\n       A                 |\n      / \\      ==>       D\n     B   C              / \\\n                       B   C\n\nFigure 4: Example of Exclusive Dependency Creation\n")])])]),n("p",[e._v("在依赖关系树内部，从属流仅应在其所依赖的所有流（父流链最高为0x0）关闭或无法在其上取得进展时才分配资源。")]),e._v(" "),n("p",[e._v("流不能依靠自己。端点必须将此视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的流错误（5.4.2节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.3.1.  Stream Dependencies")]),e._v("\n"),n("p",[e._v("Each stream can be given an explicit dependency on another stream.\nIncluding a dependency expresses a preference to allocate resources\nto the identified stream rather than to the dependent stream.")]),e._v("\n"),n("p",[e._v("A stream that is not dependent on any other stream is given a stream\ndependency of 0x0.  In other words, the non-existent stream 0 forms\nthe root of the tree.")]),e._v("\n"),n("p",[e._v('A stream that depends on another stream is a dependent stream.  The\nstream upon which a stream is dependent is a parent stream.  A\ndependency on a stream that is not currently in the tree -- such as a\nstream in the "idle" state -- results in that stream being given a\ndefault priority (Section 5.3.5).')]),e._v("\n"),n("p",[e._v("When assigning a dependency on another stream, the stream is added as\na new dependency of the parent stream.  Dependent streams that share\nthe same parent are not ordered with respect to each other.  For\nexample, if streams B and C are dependent on stream A, and if stream\nD is created with a dependency on stream A, this results in a\ndependency order of A followed by B, C, and D in any order.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("   A                 A\n  / \\      ==>      /|\\\n B   C             B D C\n\n         Figure 3: Example of Default Dependency Creation\n")])])]),n("p",[e._v("An exclusive flag allows for the insertion of a new level of\ndependencies.  The exclusive flag causes the stream to become the\nsole dependency of its parent stream, causing other dependencies to\nbecome dependent on the exclusive stream.  In the previous example,\nif stream D is created with an exclusive dependency on stream A, this\nresults in D becoming the dependency parent of B and C.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("                     A\n   A                 |\n  / \\      ==>       D\n B   C              / \\\n                   B   C\n\n        Figure 4: Example of Exclusive Dependency Creation\n")])])]),n("p",[e._v("Inside the dependency tree, a dependent stream SHOULD only be\nallocated resources if either all of the streams that it depends on\n(the chain of parent streams up to 0x0) are closed or it is not\npossible to make progress on them.")]),e._v(" "),n("p",[e._v("A stream cannot depend on itself.  An endpoint MUST treat this as a\nstream error (Section 5.4.2) of type PROTOCOL_ERROR.")])])])]),e._v(" "),n("h4",{attrs:{id:"_5-3-2-依赖权重"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-2-依赖权重"}},[e._v("#")]),e._v(" 5.3.2 依赖权重")]),e._v(" "),n("p",[e._v("所有依赖流都被分配1到256（含）之间的整数权重。")]),e._v(" "),n("p",[e._v("具有相同父流的流应根据其权重按比例分配资源。因此，如果流B依赖权重为4的流A，流C依赖权重为12的流A，并且流A上无法进行任何处理，则流B理想地接收分配给流C的资源的三分之一。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.3.2.  Dependency Weighting")]),e._v("\n"),n("p",[e._v("All dependent streams are allocated an integer weight between 1 and\n256 (inclusive).")]),e._v("\n"),n("p",[e._v("Streams with the same parent SHOULD be allocated resources\nproportionally based on their weight.  Thus, if stream B depends on\nstream A with weight 4, stream C depends on stream A with weight 12,\nand no progress can be made on stream A, stream B ideally receives\none-third of the resources allocated to stream C.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-3-3-重新排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-3-重新排序"}},[e._v("#")]),e._v(" 5.3.3 重新排序")]),e._v(" "),n("p",[e._v("流优先级使用"),n("code",[e._v("PRIORITY")]),e._v("帧进行更改。设置独立性会导致流变得依赖于已标识的父流。")]),e._v(" "),n("p",[e._v("如果父级被重新初始化，则从属流将与其父级流一起移动。为排定优先级的流设置具有独占标志的依赖关系会导致新的父流的所有依赖关系都变为已排定优先级的流。")]),e._v(" "),n("p",[e._v("如果使流依赖于其自己的依赖关系之一，则首先移动以前依赖的流以使其依赖于优先流的先前父对象。移动的依赖项保持其权重。")]),e._v(" "),n("p",[e._v("例如，考虑原始的依赖关系树，其中B和C依赖于A，D和E依赖于C，F依赖于D.如果使A依赖于D，则D代替A.全部其他依赖关系保持不变，但F除外，如果重新优先级排他，则F依赖于A。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("       x                x                x                 x\n       |               / \\               |                 |\n       A              D   A              D                 D\n      / \\            /   / \\            / \\                |\n     B   C     ==>  F   B   C   ==>    F   A       OR      A\n        / \\                 |             / \\             /|\\\n       D   E                E            B   C           B C F\n       |                                     |             |\n       F                                     E             E\n                  (intermediate)   (non-exclusive)    (exclusive)\n\n                Figure 5: Example of Dependency Reordering\n")])])]),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.3.3.  Reprioritization")]),e._v("\n"),n("p",[e._v("Stream priorities are changed using the PRIORITY frame.  Setting a\ndependency causes a stream to become dependent on the identified\nparent stream.")]),e._v("\n"),n("p",[e._v("Dependent streams move with their parent stream if the parent is\nreprioritized.  Setting a dependency with the exclusive flag for a\nreprioritized stream causes all the dependencies of the new parent\nstream to become dependent on the reprioritized stream.")]),e._v("\n"),n("p",[e._v("If a stream is made dependent on one of its own dependencies, the\nformerly dependent stream is first moved to be dependent on the\nreprioritized stream's previous parent.  The moved dependency retains\nits weight.")]),e._v("\n"),n("p",[e._v("For example, consider an original dependency tree where B and C\ndepend on A, D and E depend on C, and F depends on D.  If A is made\ndependent on D, then D takes the place of A.  All other dependency\nrelationships stay the same, except for F, which becomes dependent on\nA if the reprioritization is exclusive.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("   x                x                x                 x\n   |               / \\               |                 |\n   A              D   A              D                 D\n  / \\            /   / \\            / \\                |\n B   C     ==>  F   B   C   ==>    F   A       OR      A\n    / \\                 |             / \\             /|\\\n   D   E                E            B   C           B C F\n   |                                     |             |\n   F                                     E             E\n              (intermediate)   (non-exclusive)    (exclusive)\n\n            Figure 5: Example of Dependency Reordering\n")])])])])])]),e._v(" "),n("h4",{attrs:{id:"_5-3-4-优先级状态管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-4-优先级状态管理"}},[e._v("#")]),e._v(" 5.3.4 优先级状态管理")]),e._v(" "),n("p",[e._v("当从依赖关系树中删除流时，可以将其依赖关系移动为依赖于封闭流的父级。通过根据封闭流的权重按比例分配封闭流的依赖关系权重，可以重新计算新依赖关系的权重。")]),e._v(" "),n("p",[e._v("从依赖关系树中删除的流会导致某些优先级信息丢失。资源在具有相同父流的流之间共享，这意味着如果该流中的某个流关闭或被阻塞，则分配给该流的任何备用容量都将分配给该流的直接邻居。但是，如果从树中删除了公共依赖项，则这些流与下一个最高级别的流共享资源。")]),e._v(" "),n("p",[e._v("例如，假设流A和B共享父级，而流C和D都依赖流A。在删除流A之前，如果流A和D无法进行，则流C接收所有专用于流A的资源。如果从树中删除了流A，则流A的权重将在流C和D之间分配。如果流D仍然无法进行，则导致流C接收减少了资源。对于相等的起始权重，C接收的是可用资源的三分之一而不是一半。")]),e._v(" "),n("p",[e._v("如果在依赖项中标识的流没有关联的优先级信息，则在依赖该优先级的信息正在传输时，该流可能会关闭。 然后为依存流分配默认优先级（第5.3.5节）。由于可能会给流一个与预期的优先级不同的优先级，因此可能会产生次优的优先级。")]),e._v(" "),n("p",[e._v("为避免这些问题，端点应在流关闭后的一段时间内保留流优先级状态。状态保留的时间越长，分配区域的流分配不正确或默认优先级值的机会就越少。")]),e._v(" "),n("p",[e._v("类似地，处于"),n("code",[e._v("idle")]),e._v("状态的流可以被分配优先级或成为其他流的父级。这允许在依赖关系树中创建分组节点，从而实现更灵活的优先级表达。空闲流以默认优先级开头（第5.3.5节）。")]),e._v(" "),n("p",[e._v("对于未计入"),n("code",[e._v("SETTINGS_MAX_CONCURRENT_STREAMS")]),e._v("设置的限制的流，优先级信息的保留可能会给端点造成很大的状态负担。因此，保留的优先级状态数量可能会受到限制。")]),e._v(" "),n("p",[e._v("端点为优先级保留的其他状态数量可能取决于负载；在高负载下，可以丢弃优先级状态以限制资源承诺。在极端情况下，端点甚至可以丢弃活动或保留流的优先级状态。如果应用了限制，则端点SHOULD至少应保持其"),n("code",[e._v("SETTINGS_MAX_CONCURRENT_STREAMS")]),e._v("设置所允许的流数量。实施还应尝试为优先级树中处于活动状态的流保留状态。")]),e._v(" "),n("p",[e._v("如果保留的状态足以保留该状态，则接收"),n("code",[e._v("PRIORITY")]),e._v("帧的端点将更改关闭流的优先级，应改变依赖于此流的流的依赖关系。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.3.4.  Prioritization State Management")]),e._v("\n"),n("p",[e._v("When a stream is removed from the dependency tree, its dependencies\ncan be moved to become dependent on the parent of the closed stream.\nThe weights of new dependencies are recalculated by distributing the\nweight of the dependency of the closed stream proportionally based on\nthe weights of its dependencies.")]),e._v("\n"),n("p",[e._v("Streams that are removed from the dependency tree cause some\nprioritization information to be lost.  Resources are shared between\nstreams with the same parent stream, which means that if a stream in\nthat set closes or becomes blocked, any spare capacity allocated to a\nstream is distributed to the immediate neighbors of the stream.\nHowever, if the common dependency is removed from the tree, those\nstreams share resources with streams at the next highest level.")]),e._v("\n"),n("p",[e._v("For example, assume streams A and B share a parent, and streams C and\nD both depend on stream A.  Prior to the removal of stream A, if\nstreams A and D are unable to proceed, then stream C receives all the\nresources dedicated to stream A.  If stream A is removed from the\ntree, the weight of stream A is divided between streams C and D.  If\nstream D is still unable to proceed, this results in stream C\nreceiving a reduced proportion of resources.  For equal starting\nweights, C receives one third, rather than one half, of available\nresources.")]),e._v("\n"),n("p",[e._v("It is possible for a stream to become closed while prioritization\ninformation that creates a dependency on that stream is in transit.\nIf a stream identified in a dependency has no associated priority\ninformation, then the dependent stream is instead assigned a default\npriority (Section 5.3.5).  This potentially creates suboptimal\nprioritization, since the stream could be given a priority that is\ndifferent from what is intended.")]),e._v("\n"),n("p",[e._v("To avoid these problems, an endpoint SHOULD retain stream\nprioritization state for a period after streams become closed.  The\nlonger state is retained, the lower the chance that streams are\nassigned incorrect or default priority values.")]),e._v("\n"),n("p",[e._v('Similarly, streams that are in the "idle" state can be assigned\npriority or become a parent of other streams.  This allows for the\ncreation of a grouping node in the dependency tree, which enables\nmore flexible expressions of priority.  Idle streams begin with a\ndefault priority (Section 5.3.5).')]),e._v("\n"),n("p",[e._v("The retention of priority information for streams that are not\ncounted toward the limit set by SETTINGS_MAX_CONCURRENT_STREAMS could\ncreate a large state burden for an endpoint.  Therefore, the amount\nof prioritization state that is retained MAY be limited.")]),e._v("\n"),n("p",[e._v("The amount of additional state an endpoint maintains for\nprioritization could be dependent on load; under high load,\nprioritization state can be discarded to limit resource commitments.\nIn extreme cases, an endpoint could even discard prioritization state\nfor active or reserved streams.  If a limit is applied, endpoints\nSHOULD maintain state for at least as many streams as allowed by\ntheir setting for SETTINGS_MAX_CONCURRENT_STREAMS.  Implementations\nSHOULD also attempt to retain state for streams that are in active\nuse in the priority tree.")]),e._v("\n"),n("p",[e._v("If it has retained enough state to do so, an endpoint receiving a\nPRIORITY frame that changes the priority of a closed stream SHOULD\nalter the dependencies of the streams that depend on it.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-3-5-默认优先级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-5-默认优先级"}},[e._v("#")]),e._v(" 5.3.5 默认优先级")]),e._v(" "),n("p",[e._v("最初为所有流分配了对流0x0的非排他性依赖关系。推送的流（第8.2节）最初取决于它们的关联流。在这两种情况下，流均被分配默认权重16。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.3.5.  Default Priorities")]),e._v("\n"),n("p",[e._v("All streams are initially assigned a non-exclusive dependency on\nstream 0x0.  Pushed streams (Section 8.2) initially depend on their\nassociated stream.  In both cases, streams are assigned a default\nweight of 16.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_5-4-错误处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-错误处理"}},[e._v("#")]),e._v(" 5.4 错误处理")]),e._v(" "),n("p",[e._v("HTTP/2帧允许两种错误：")]),e._v(" "),n("ul",[n("li",[e._v("使整个连接不可用的错误条件是连接错误。")]),e._v(" "),n("li",[e._v("单个流中的错误是流错误。")])]),e._v(" "),n("p",[e._v("第7节中包含错误代码列表。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.4.  Error Handling")]),e._v("\n"),n("p",[e._v("HTTP/2 framing permits two classes of error:")]),e._v("\n"),n("p",[e._v("o  An error condition that renders the entire connection unusable is\na connection error.")]),e._v("\n"),n("p",[e._v("o  An error in an individual stream is a stream error.")]),e._v("\n"),n("p",[e._v("A list of error codes is included in Section 7.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-4-1-连接错误处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-1-连接错误处理"}},[e._v("#")]),e._v(" 5.4.1 连接错误处理")]),e._v(" "),n("p",[e._v("连接错误是指阻止帧层进一步处理或破坏任何连接状态的任何错误。")]),e._v(" "),n("p",[e._v("遇到连接错误的端点应首先发送一个"),n("code",[e._v("GOAWAY")]),e._v("帧（第6.8节），该帧带有从其成功接收到的最后一个流的流标识符同行。 "),n("code",[e._v("GOAWAY")]),e._v("帧包含一个错误代码，该错误代码指示为什么会终止连接。发送出现错误情况的"),n("code",[e._v("GOAWAY")]),e._v("帧后，端点必须关闭TCP连接。")]),e._v(" "),n("p",[e._v("接收端点可能无法可靠地接收"),n("code",[e._v("GOAWAY")]),e._v("（[RFC7230]，第6.6节描述了立即连接关闭如何导致数据丢失）。如果发生连接错误，"),n("code",[e._v("GOAWAY")]),e._v("只提供尽力尝试与对等方进行通信，说明终止连接的原因。")]),e._v(" "),n("p",[e._v("端点可以随时终止连接。特别是，端点可以选择将流错误视为连接错误。端点应在结束连接时发送"),n("code",[e._v("GOAWAY")]),e._v("帧，前提是情况允许。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.4.1.  Connection Error Handling")]),e._v("\n"),n("p",[e._v("A connection error is any error that prevents further processing of\nthe frame layer or corrupts any connection state.")]),e._v("\n"),n("p",[e._v("An endpoint that encounters a connection error SHOULD first send a\nGOAWAY frame (Section 6.8) with the stream identifier of the last\nstream that it successfully received from its peer.  The GOAWAY frame\nincludes an error code that indicates why the connection is\nterminating.  After sending the GOAWAY frame for an error condition,\nthe endpoint MUST close the TCP connection.")]),e._v("\n"),n("p",[e._v("It is possible that the GOAWAY will not be reliably received by the\nreceiving endpoint ([RFC7230], Section 6.6 describes how an immediate\nconnection close can result in data loss).  In the event of a\nconnection error, GOAWAY only provides a best-effort attempt to\ncommunicate with the peer about why the connection is being\nterminated.")]),e._v("\n"),n("p",[e._v("An endpoint can end a connection at any time.  In particular, an\nendpoint MAY choose to treat a stream error as a connection error.\nEndpoints SHOULD send a GOAWAY frame when ending a connection,\nproviding that circumstances permit it.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-4-2-流错误处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-2-流错误处理"}},[e._v("#")]),e._v(" 5.4.2 流错误处理")]),e._v(" "),n("p",[e._v("流错误是与不影响其他流处理的特定流相关的错误。")]),e._v(" "),n("p",[e._v("检测到流错误的端点发送"),n("code",[e._v("RST_STREAM")]),e._v("帧（第6.4节），该帧包含发生错误的流的流标识符。 "),n("code",[e._v("RST_STREAM")]),e._v("帧包含指示错误类型的错误代码。")]),e._v(" "),n("p",[n("code",[e._v("RST_STREAM")]),e._v("是端点可以在流上发送的最后一个帧。发送RST_STREAM帧的对等端必须准备好接收任何已发送或排队等待发送的帧。这些帧可以被忽略，除非它们修改了连接状态（例如为报头压缩（第4.3节）或流控制而维护的状态）。")]),e._v(" "),n("p",[e._v("通常，端点不应为任何流发送多个"),n("code",[e._v("RST_STREAM")]),e._v("帧。但是，如果端点在超过行程时间之后收到封闭流上的帧，则端点可以发送其他"),n("code",[e._v("RST_STREAM")]),e._v("帧。允许这种行为处理行为错误的实现。")]),e._v(" "),n("p",[e._v("为避免循环，端点不得发送"),n("code",[e._v("RST_STREAM")]),e._v("来响应"),n("code",[e._v("RST_STREAM")]),e._v("帧。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.4.2.  Stream Error Handling")]),e._v("\n"),n("p",[e._v("A stream error is an error related to a specific stream that does not\naffect processing of other streams.")]),e._v("\n"),n("p",[e._v("An endpoint that detects a stream error sends a RST_STREAM frame\n(Section 6.4) that contains the stream identifier of the stream where\nthe error occurred.  The RST_STREAM frame includes an error code that\nindicates the type of error.")]),e._v("\n"),n("p",[e._v("A RST_STREAM is the last frame that an endpoint can send on a stream.\nThe peer that sends the RST_STREAM frame MUST be prepared to receive\nany frames that were sent or enqueued for sending by the remote peer.\nThese frames can be ignored, except where they modify connection\nstate (such as the state maintained for header compression\n(Section 4.3) or flow control).")]),e._v("\n"),n("p",[e._v("Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame\nfor any stream.  However, an endpoint MAY send additional RST_STREAM\nframes if it receives frames on a closed stream after more than a\nround-trip time.  This behavior is permitted to deal with misbehaving\nimplementations.")]),e._v("\n"),n("p",[e._v("To avoid looping, an endpoint MUST NOT send a RST_STREAM in response\nto a RST_STREAM frame.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_5-4-3-连接终止"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-3-连接终止"}},[e._v("#")]),e._v(" 5.4.3 连接终止")]),e._v(" "),n("p",[e._v("如果在流保持"),n("code",[e._v("open")]),e._v("或"),n("code",[e._v("half-closed")]),e._v("状态的同时关闭或重置TCP连接，则无法自动重试受影响的流（有关详细信息，请参阅第8.1.4节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.4.3.  Connection Termination")]),e._v("\n"),n("p",[e._v('If the TCP connection is closed or reset while streams remain in\n"open" or "half-closed" state, then the affected streams cannot be\nautomatically retried (see Section 8.1.4 for details).')]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_5-5-扩展http-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-扩展http-2"}},[e._v("#")]),e._v(" 5.5 扩展HTTP/2")]),e._v(" "),n("p",[e._v("HTTP/2允许扩展协议。在本节描述的限制内，协议扩展可用于提供其他服务或更改协议的任何方面。扩展仅在单个HTTP/2连接的范围内有效。")]),e._v(" "),n("p",[e._v("这适用于本文档中定义的协议元素。这不会影响扩展HTTP的现有选项，例如定义新方法，状态代码或标头字段。")]),e._v(" "),n("p",[e._v("扩展名允许使用新的帧类型（第4.1节），新设置（第6.5.2节）或新的错误代码（第7节）。建立用于管理这些扩展点的注册表：帧类型（第11.2节），设置（第11.3节）和错误代码（第11.4节）。")]),e._v(" "),n("p",[e._v("实现必须忽略所有可扩展协议元素中未知或不受支持的值。实现必须丢弃类型未知或不受支持的帧。这意味着这些扩展点中的任何一个都可以被扩展安全地使用，而无需事先安排或协商。但是，不允许出现在标头块中间的扩展帧（第4.3节）。这些必须被视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("可能会更改现有协议组件语义的扩展必须在使用前进行协商。例如，无法更改"),n("code",[e._v("HEADERS")]),e._v("帧布局的扩展名，直到对等端发出肯定的信号表明可以接受为止。在这种情况下，可能还需要在建议的布局生效时进行协调。请注意，将除"),n("code",[e._v("DATA")]),e._v("帧以外的任何帧视为流控制是这种语义变化，只能通过协商来完成。")]),e._v(" "),n("p",[e._v("本文档未强制要求使用扩展名进行协商的特定方法，但请注意设置（第6.5.2节）可以用于该目的。如果两个对等方都设置了表示愿意使用该扩展名的值，则可以使用该扩展名。")]),e._v(" "),n("p",[e._v("如果将设置用于扩展协商，则必须以初始禁用扩展的方式定义初始值。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("5.5.  Extending HTTP/2")]),e._v("\n"),n("p",[e._v("HTTP/2 permits extension of the protocol.  Within the limitations\ndescribed in this section, protocol extensions can be used to provide\nadditional services or alter any aspect of the protocol.  Extensions\nare effective only within the scope of a single HTTP/2 connection.")]),e._v("\n"),n("p",[e._v("This applies to the protocol elements defined in this document.  This\ndoes not affect the existing options for extending HTTP, such as\ndefining new methods, status codes, or header fields.")]),e._v("\n"),n("p",[e._v("Extensions are permitted to use new frame types (Section 4.1), new\nsettings (Section 6.5.2), or new error codes (Section 7).  Registries\nare established for managing these extension points: frame types\n(Section 11.2), settings (Section 11.3), and error codes\n(Section 11.4).")]),e._v("\n"),n("p",[e._v("Implementations MUST ignore unknown or unsupported values in all\nextensible protocol elements.  Implementations MUST discard frames\nthat have unknown or unsupported types.  This means that any of these\nextension points can be safely used by extensions without prior\narrangement or negotiation.  However, extension frames that appear in\nthe middle of a header block (Section 4.3) are not permitted; these\nMUST be treated as a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.")]),e._v("\n"),n("p",[e._v("Extensions that could change the semantics of existing protocol\ncomponents MUST be negotiated before being used.  For example, an\nextension that changes the layout of the HEADERS frame cannot be used\nuntil the peer has given a positive signal that this is acceptable.\nIn this case, it could also be necessary to coordinate when the\nrevised layout comes into effect.  Note that treating any frames\nother than DATA frames as flow controlled is such a change in\nsemantics and can only be done through negotiation.")]),e._v("\n"),n("p",[e._v("This document doesn't mandate a specific method for negotiating the\nuse of an extension but notes that a setting (Section 6.5.2) could be\nused for that purpose.  If both peers set a value that indicates\nwillingness to use the extension, then the extension can be used.  If")]),e._v("\n"),n("p",[e._v("a setting is used for extension negotiation, the initial value MUST\nbe defined in such a fashion that the extension is initially\ndisabled.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h2",{attrs:{id:"_6-帧定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-帧定义"}},[e._v("#")]),e._v(" 6. 帧定义")]),e._v(" "),n("p",[e._v("本规范定义了许多帧类型，每种类型均由唯一的8位类型代码标识。每种帧类型在整个连接或单个流的建立和管理中都有不同的用途。")]),e._v(" "),n("p",[e._v("特定帧类型的传输可以更改连接的状态。如果端点无法维持连接状态的同步视图，则将无法再成功进行连接内的通信。因此，重要的一点是，端点必须对状态如何受到给定帧的使用产生共同的理解。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"6"}},[e._v("\n"),n("li",[e._v("Frame Definitions")]),e._v("\n")]),e._v("\n"),n("p",[e._v("This specification defines a number of frame types, each identified\nby a unique 8-bit type code.  Each frame type serves a distinct\npurpose in the establishment and management either of the connection\nas a whole or of individual streams.")]),e._v("\n"),n("p",[e._v("The transmission of specific frame types can alter the state of a\nconnection.  If endpoints fail to maintain a synchronized view of the\nconnection state, successful communication within the connection will\nno longer be possible.  Therefore, it is important that endpoints\nhave a shared comprehension of how the state is affected by the use\nany given frame.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_6-1-data"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-data"}},[e._v("#")]),e._v(" 6.1 DATA")]),e._v(" "),n("p",[e._v("DATA帧（类型=0x0）传达与流相关的任意可变长度的八位字节序列。例如，一个或多个DATA帧用于承载HTTP请求或响应有效负载。")]),e._v(" "),n("p",[e._v("DATA帧还可以包含填充。可以将填充添加到DATA帧中以掩盖消息的大小。填充是一种安全功能；参见10.7节。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +---------------+\n    |Pad Length? (8)|\n    +---------------+-----------------------------------------------+\n    |                            Data (*)                         ...\n    +---------------------------------------------------------------+\n    |                           Padding (*)                       ...\n    +---------------------------------------------------------------+\n\n                       Figure 6: DATA Frame Payload\n")])])]),n("p",[e._v("DATA帧包含以下字段：")]),e._v(" "),n("ul",[n("li",[e._v("填充长度(Pad Length)：8位字段，包含以八位字节为单位的帧填充的长度。该字段是有条件的（在图中用"),n("code",[e._v("?")]),e._v("表示），仅当设置了"),n("code",[e._v("PADDED")]),e._v("标志时才存在。")]),e._v(" "),n("li",[e._v("数据(Data)：应用程序数据。数据量是减去存在的其他字段的长度后剩余的帧有效负载。")]),e._v(" "),n("li",[e._v("填充(Padding)：不包含应用程序语义值的填充八位字节。发送时，填充八位字节必须设置为零。接收者没有义务验证填充，但是可以将非零填充视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")])]),e._v(" "),n("p",[e._v("DATA帧定义以下标志：")]),e._v(" "),n("ul",[n("li",[e._v("END_STREAM (0x1): 置位时，位0指示该帧是端点将向所标识的流发送的最后一个帧。设置该标志会使流进入"),n("code",[e._v("half-closed")]),e._v("或"),n("code",[e._v("closed")]),e._v("状态（第5.1节）- PADDED (0x8): 设置后，位3指示“填充长度”字段及其描述的任何填充都存在。")])]),e._v(" "),n("p",[e._v("DATA帧必须与流关联。如果接收到一个其流标识符字段为0x0的DATA帧，则接收者必须以"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）进行响应。")]),e._v(" "),n("p",[e._v("数据帧受流量控制，并且仅在流处于"),n("code",[e._v("open")]),e._v("或"),n("code",[e._v("half-closed (remote)")]),e._v("状态时才能发送。整个DATA帧有效负载都包含在流控制中，包括"),n("code",[e._v("Pad Length")]),e._v("和"),n("code",[e._v("Padding")]),e._v("字段（如果存在）。如果接收到的DATA帧的流不处于"),n("code",[e._v("open")]),e._v("或"),n("code",[e._v("half-closed (local)")]),e._v("状态，则接收方务必以"),n("code",[e._v("STREAM_CLOSED")]),e._v("类型的流错误（第5.4.2节）做出响应。")]),e._v(" "),n("p",[e._v("填充字节的总数由"),n("code",[e._v("Pad Length")]),e._v("字段的值确定。如果填充的长度是帧有效载荷的长度或更大，则接收者必须将此视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（5.4.1节）。")]),e._v(" "),n("p",[e._v("注意：通过包含值为零的"),n("code",[e._v("Pad Length")]),e._v("字段，可以将帧的大小增加一个八位位组。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.1.  DATA")]),e._v("\n"),n("p",[e._v("DATA frames (type=0x0) convey arbitrary, variable-length sequences of\noctets associated with a stream.  One or more DATA frames are used,\nfor instance, to carry HTTP request or response payloads.")]),e._v("\n"),n("p",[e._v("DATA frames MAY also contain padding.  Padding can be added to DATA\nframes to obscure the size of messages.  Padding is a security\nfeature; see Section 10.7.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+---------------+\n|Pad Length? (8)|\n+---------------+-----------------------------------------------+\n|                            Data (*)                         ...\n+---------------------------------------------------------------+\n|                           Padding (*)                       ...\n+---------------------------------------------------------------+\n\n                   Figure 6: DATA Frame Payload\n")])])]),n("p",[e._v("The DATA frame contains the following fields:")]),e._v(" "),n("p",[e._v('Pad Length:  An 8-bit field containing the length of the frame\npadding in units of octets.  This field is conditional (as\nsignified by a "?" in the diagram) and is only present if the\nPADDED flag is set.')]),e._v(" "),n("p",[e._v("Data:  Application data.  The amount of data is the remainder of the\nframe payload after subtracting the length of the other fields\nthat are present.")]),e._v(" "),n("p",[e._v("Padding:  Padding octets that contain no application semantic value.\nPadding octets MUST be set to zero when sending.  A receiver is\nnot obligated to verify padding but MAY treat non-zero padding as\na connection error (Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v("The DATA frame defines the following flags:")]),e._v(" "),n("p",[e._v('END_STREAM (0x1):  When set, bit 0 indicates that this frame is the\nlast that the endpoint will send for the identified stream.\nSetting this flag causes the stream to enter one of the "half-\nclosed" states or the "closed" state (Section 5.1).')]),e._v(" "),n("p",[e._v("PADDED (0x8):  When set, bit 3 indicates that the Pad Length field\nand any padding that it describes are present.")]),e._v(" "),n("p",[e._v("DATA frames MUST be associated with a stream.  If a DATA frame is\nreceived whose stream identifier field is 0x0, the recipient MUST\nrespond with a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v('DATA frames are subject to flow control and can only be sent when a\nstream is in the "open" or "half-closed (remote)" state.  The entire\nDATA frame payload is included in flow control, including the Pad\nLength and Padding fields if present.  If a DATA frame is received\nwhose stream is not in "open" or "half-closed (local)" state, the\nrecipient MUST respond with a stream error (Section 5.4.2) of type\nSTREAM_CLOSED.')]),e._v(" "),n("p",[e._v("The total number of padding octets is determined by the value of the\nPad Length field.  If the length of the padding is the length of the\nframe payload or greater, the recipient MUST treat this as a\nconnection error (Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  Note: A frame can be increased in size by one octet by including a\n  Pad Length field with a value of zero.\n")])])])])])]),e._v(" "),n("h3",{attrs:{id:"_6-2-headers"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-headers"}},[e._v("#")]),e._v(" 6.2 HEADERS")]),e._v(" "),n("p",[e._v("HEADERS帧（类型=0x1）用于打开流（第5.1节），并附加一个header块片段。可以在"),n("code",[e._v("idle")]),e._v("、"),n("code",[e._v("reserved(local)")]),e._v("、"),n("code",[e._v("open")]),e._v("或"),n("code",[e._v("half-closed(remot)")]),e._v("状态下在流上发送HEADERS帧。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +---------------+\n    |Pad Length? (8)|\n    +-+-------------+-----------------------------------------------+\n    |E|                 Stream Dependency? (31)                     |\n    +-+-------------+-----------------------------------------------+\n    |  Weight? (8)  |\n    +-+-------------+-----------------------------------------------+\n    |                   Header Block Fragment (*)                 ...\n    +---------------------------------------------------------------+\n    |                           Padding (*)                       ...\n    +---------------------------------------------------------------+\n\n                      Figure 7: HEADERS Frame Payload\n")])])]),n("p",[e._v("HEADERS帧有效载荷具有以下字段：")]),e._v(" "),n("ul",[n("li",[e._v("Pad Length：一个8位字段，包含以八位字节为单位的帧填充长度。仅当设置了"),n("code",[e._v("PADDED")]),e._v("标志时，此字段才存在。")]),e._v(" "),n("li",[e._v("E：一位标志，指示流依赖性是排他性的（请参阅第5.3节）。仅当设置了"),n("code",[e._v("PRIORITY")]),e._v("标志时，此字段才存在。")]),e._v(" "),n("li",[e._v("Stream Dependency：此流所依赖的流的31位流标识符（请参阅第5.3节）。仅当设置了"),n("code",[e._v("PRIORITY")]),e._v("标志时，此字段才存在。")]),e._v(" "),n("li",[e._v("Weight：表示流优先级权重的无符号8位整数（请参阅第5.3节）。将值加1以获得介于1和256之间的权重。仅当设置了"),n("code",[e._v("PRIORITY")]),e._v("标志时，才显示此字段。")]),e._v(" "),n("li",[e._v("Header Block Fragment：标头块片段（第4.3节）。")]),e._v(" "),n("li",[e._v("Padding：填充八位字节。")])]),e._v(" "),n("p",[e._v("HEADERS帧定义以下标志：")]),e._v(" "),n("ul",[n("li",[e._v("END_STREAM（0x1）：设置后，位0指示标头块（第4.3节）是端点将向标识流发送的最后一个块。\nHEADERS帧带有"),n("code",[e._v("END_STREAM")]),e._v("标志，该标志指示流的结尾。但是，设置了"),n("code",[e._v("END_STREAM")]),e._v("标志的HEADERS帧之后可以是同一流上的CONTINUATION帧。从逻辑上讲，CONTINUATION帧是HEADERS帧的一部分。")]),e._v(" "),n("li",[e._v("END_HEADERS（0x4）：置位时，位2指示该帧包含整个标题块（第4.3节），并且之后没有任何CONTINUATION帧。\n没有设置"),n("code",[e._v("END_HEADERS")]),e._v("标志的HEADERS帧之后必须是同一流的CONTINUATION帧。接收者必须将接收到的任何其他类型的帧或不同流上的帧视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）")]),e._v(" "),n("li",[e._v("PADDED（0x8）：置位时，第3位指示"),n("code",[e._v("Pad Length")]),e._v("字段以及任何存在它描述的填充。")]),e._v(" "),n("li",[e._v("PRIORITY（0x20）：置位时，位5表示存在独占标志（E），流相关性和权重字段；参见第5.3节。")])]),e._v(" "),n("p",[e._v("HEADERS帧的有效载荷包含一个头块片段（第4.3节）。不适合HEADERS框架的标题块在CONTINUATION框架中继续（第6.10节）。")]),e._v(" "),n("p",[e._v("HEADERS帧必须与流关联。如果收到的HEADERS帧的流标识符字段为0x0，则接收者务必以"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）进行响应。")]),e._v(" "),n("p",[e._v("HEADERS帧如第4.3节所述更改连接状态。")]),e._v(" "),n("p",[e._v("HEADERS框架可以包含填充。填充字段和标志与为DATA帧定义的填充字段和标志相同（第6.1节）。超出标题块片段剩余大小的填充必须被视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("。")]),e._v(" "),n("p",[e._v("HEADERS帧中的优先级信息在逻辑上等效于单独的PRIORITY帧，但是包含在HEADERS中避免了在创建新流时流优先级流失的可能性。在第一个流之后的HEADERS帧中的优先级字段将对流进行优先级排序（第5.3.3节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.2.  HEADERS")]),e._v("\n"),n("p",[e._v('The HEADERS frame (type=0x1) is used to open a stream (Section 5.1),\nand additionally carries a header block fragment.  HEADERS frames can\nbe sent on a stream in the "idle", "reserved (local)", "open", or\n"half-closed (remote)" state.')]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+---------------+\n|Pad Length? (8)|\n+-+-------------+-----------------------------------------------+\n|E|                 Stream Dependency? (31)                     |\n+-+-------------+-----------------------------------------------+\n|  Weight? (8)  |\n+-+-------------+-----------------------------------------------+\n|                   Header Block Fragment (*)                 ...\n+---------------------------------------------------------------+\n|                           Padding (*)                       ...\n+---------------------------------------------------------------+\n\n                  Figure 7: HEADERS Frame Payload\n")])])]),n("p",[e._v("The HEADERS frame payload has the following fields:")]),e._v(" "),n("p",[e._v("Pad Length:  An 8-bit field containing the length of the frame\npadding in units of octets.  This field is only present if the\nPADDED flag is set.")]),e._v(" "),n("p",[e._v("E: A single-bit flag indicating that the stream dependency is\nexclusive (see Section 5.3).  This field is only present if the\nPRIORITY flag is set.")]),e._v(" "),n("p",[e._v("Stream Dependency:  A 31-bit stream identifier for the stream that\nthis stream depends on (see Section 5.3).  This field is only\npresent if the PRIORITY flag is set.")]),e._v(" "),n("p",[e._v("Weight:  An unsigned 8-bit integer representing a priority weight for\nthe stream (see Section 5.3).  Add one to the value to obtain a\nweight between 1 and 256.  This field is only present if the\nPRIORITY flag is set.")]),e._v(" "),n("p",[e._v("Header Block Fragment:  A header block fragment (Section 4.3).")]),e._v(" "),n("p",[e._v("Padding:  Padding octets.")]),e._v(" "),n("p",[e._v("The HEADERS frame defines the following flags:")]),e._v(" "),n("p",[e._v("END_STREAM (0x1):  When set, bit 0 indicates that the header block\n(Section 4.3) is the last that the endpoint will send for the\nidentified stream.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  A HEADERS frame carries the END_STREAM flag that signals the end\n  of a stream.  However, a HEADERS frame with the END_STREAM flag\n  set can be followed by CONTINUATION frames on the same stream.\n  Logically, the CONTINUATION frames are part of the HEADERS frame.\n")])])]),n("p",[e._v("END_HEADERS (0x4):  When set, bit 2 indicates that this frame\ncontains an entire header block (Section 4.3) and is not followed\nby any CONTINUATION frames.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  A HEADERS frame without the END_HEADERS flag set MUST be followed\n  by a CONTINUATION frame for the same stream.  A receiver MUST\n  treat the receipt of any other type of frame or a frame on a\n  different stream as a connection error (Section 5.4.1) of type\n  PROTOCOL_ERROR.\n")])])]),n("p",[e._v("PADDED (0x8):  When set, bit 3 indicates that the Pad Length field\nand any padding that it describes are present.")]),e._v(" "),n("p",[e._v("PRIORITY (0x20):  When set, bit 5 indicates that the Exclusive Flag\n(E), Stream Dependency, and Weight fields are present; see\nSection 5.3.")]),e._v(" "),n("p",[e._v("The payload of a HEADERS frame contains a header block fragment\n(Section 4.3).  A header block that does not fit within a HEADERS\nframe is continued in a CONTINUATION frame (Section 6.10).")]),e._v(" "),n("p",[e._v("HEADERS frames MUST be associated with a stream.  If a HEADERS frame\nis received whose stream identifier field is 0x0, the recipient MUST\nrespond with a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v("The HEADERS frame changes the connection state as described in\nSection 4.3.")]),e._v(" "),n("p",[e._v("The HEADERS frame can include padding.  Padding fields and flags are\nidentical to those defined for DATA frames (Section 6.1).  Padding\nthat exceeds the size remaining for the header block fragment MUST be\ntreated as a PROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v("Prioritization information in a HEADERS frame is logically equivalent\nto a separate PRIORITY frame, but inclusion in HEADERS avoids the\npotential for churn in stream prioritization when new streams are\ncreated.  Prioritization fields in HEADERS frames subsequent to the\nfirst on a stream reprioritize the stream (Section 5.3.3).")])])])]),e._v(" "),n("h3",{attrs:{id:"_6-3-priority"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-priority"}},[e._v("#")]),e._v(" 6.3 PRIORITY")]),e._v(" "),n("p",[e._v("PRIORITY帧（类型=0x2）指定发送方建议的流优先级（第5.3节）。它可以以任何流状态发送，包括"),n("code",[e._v("idle")]),e._v("或"),n("code",[e._v("closed")]),e._v("的流。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +-+-------------------------------------------------------------+\n    |E|                  Stream Dependency (31)                     |\n    +-+-------------+-----------------------------------------------+\n    |   Weight (8)  |\n    +-+-------------+\n\n                     Figure 8: PRIORITY Frame Payload\n\n")])])]),n("p",[e._v("PRIORITY帧的有效负载包含以下字段：")]),e._v(" "),n("ul",[n("li",[e._v("E：一位标志，指示流依赖性是非排他性的（请参阅第5.3节）。")]),e._v(" "),n("li",[e._v("Stream Dependency: 此流所依赖的流的31位流标识符（请参阅第5.3节）。")]),e._v(" "),n("li",[e._v("Weight: 表示流优先级权重的无符号8位整数（请参阅第5.3节）。将值加1可获得1到256之间的权重。")])]),e._v(" "),n("p",[e._v("PRIORITY帧未定义任何标志。")]),e._v(" "),n("p",[e._v("PRIORITY帧始终标识流。如果收到一个流标识符为0x0的PRIORITY帧，则接收者务必以"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）进行响应。")]),e._v(" "),n("p",[e._v("尽管不能在包含单头块的连续帧之间发送PRIORITY帧，但它可以在任何状态下在流上发送（第4.3节）。请注意，该帧可能在处理后或到达帧发送完成后到达，这将导致它对标识的流没有影响。对于处于"),n("code",[e._v("half-closed(remote)")]),e._v("或"),n("code",[e._v("closed")]),e._v("状态的流，此帧只能影响所标识的流及其从属流的处理；它不会影响该流上的帧传输。")]),e._v(" "),n("p",[e._v("可以为处于"),n("code",[e._v("idle")]),e._v("或"),n("code",[e._v("closed")]),e._v("状态的流发送优先级帧。这允许通过更改未使用或关闭的父流的优先级来重新设置一组依赖流的优先级。")]),e._v(" "),n("p",[e._v("长度非5个八位位组的PRIORITY帧必须被视为"),n("code",[e._v("FRAME_SIZE_ERROR")]),e._v("类型的流错误（第5.4.2节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.3.  PRIORITY")]),e._v("\n"),n("p",[e._v("The PRIORITY frame (type=0x2) specifies the sender-advised priority\nof a stream (Section 5.3).  It can be sent in any stream state,\nincluding idle or closed streams.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+-+-------------------------------------------------------------+\n|E|                  Stream Dependency (31)                     |\n+-+-------------+-----------------------------------------------+\n|   Weight (8)  |\n+-+-------------+\n\n                 Figure 8: PRIORITY Frame Payload\n")])])]),n("p",[e._v("The payload of a PRIORITY frame contains the following fields:")]),e._v(" "),n("p",[e._v("E: A single-bit flag indicating that the stream dependency is\nexclusive (see Section 5.3).")]),e._v(" "),n("p",[e._v("Stream Dependency:  A 31-bit stream identifier for the stream that\nthis stream depends on (see Section 5.3).")]),e._v(" "),n("p",[e._v("Weight:  An unsigned 8-bit integer representing a priority weight for\nthe stream (see Section 5.3).  Add one to the value to obtain a\nweight between 1 and 256.")]),e._v(" "),n("p",[e._v("The PRIORITY frame does not define any flags.")]),e._v(" "),n("p",[e._v("The PRIORITY frame always identifies a stream.  If a PRIORITY frame\nis received with a stream identifier of 0x0, the recipient MUST\nrespond with a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v('The PRIORITY frame can be sent on a stream in any state, though it\ncannot be sent between consecutive frames that comprise a single\nheader block (Section 4.3).  Note that this frame could arrive after\nprocessing or frame sending has completed, which would cause it to\nhave no effect on the identified stream.  For a stream that is in the\n"half-closed (remote)" or "closed" state, this frame can only affect\nprocessing of the identified stream and its dependent streams; it\ndoes not affect frame transmission on that stream.')]),e._v(" "),n("p",[e._v('The PRIORITY frame can be sent for a stream in the "idle" or "closed"\nstate.  This allows for the reprioritization of a group of dependent\nstreams by altering the priority of an unused or closed parent\nstream.')]),e._v(" "),n("p",[e._v("A PRIORITY frame with a length other than 5 octets MUST be treated as\na stream error (Section 5.4.2) of type FRAME_SIZE_ERROR.")])])])]),e._v(" "),n("h3",{attrs:{id:"_6-4-rst-stream"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-rst-stream"}},[e._v("#")]),e._v(" 6.4 RST_STREAM")]),e._v(" "),n("p",[e._v("RST_STREAM帧（类型=0x3）允许立即终止流。发送RST_STREAM以请求取消流或指示发生了错误情况。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +---------------------------------------------------------------+\n    |                        Error Code (32)                        |\n    +---------------------------------------------------------------+\n\n                    Figure 9: RST_STREAM Frame Payload\n")])])]),n("p",[e._v("RST_STREAM帧包含一个唯一的无符号32位整数，用于标识错误代码（第7节）。错误代码指示为什么终止流。")]),e._v(" "),n("p",[e._v("RST_STREAM帧未定义任何标志。 RST_STREAM帧完全终止引用的流，并使其进入"),n("code",[e._v("closed")]),e._v("状态。流在接收到RST_STREAM之后，接收者必须不发送该流的其他帧，但"),n("code",[e._v("PRIORITY")]),e._v("帧除外。但是，在发送了RST_STREAM之后，发送端点必须准备好接收和处理在流上发送的其他帧，这些帧可能是在RST_STREAM到达之前由对等方发送的。")]),e._v(" "),n("p",[e._v("RST_STREAM帧必须与流关联。如果接收到流标识符为0x0的RST_STREAM帧，则接收者必须将其视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("RST_STREAM帧不得以"),n("code",[e._v("idle")]),e._v("状态发送给流。如果接收到标识空闲流的RST_STREAM帧，则接收方必须将此视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("长度非4个八位位组的RST_STREAM帧必须被视为"),n("code",[e._v("FRAME_SIZE_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.4.  RST_STREAM")]),e._v("\n"),n("p",[e._v("The RST_STREAM frame (type=0x3) allows for immediate termination of a\nstream.  RST_STREAM is sent to request cancellation of a stream or to\nindicate that an error condition has occurred.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+---------------------------------------------------------------+\n|                        Error Code (32)                        |\n+---------------------------------------------------------------+\n\n                Figure 9: RST_STREAM Frame Payload\n")])])]),n("p",[e._v("The RST_STREAM frame contains a single unsigned, 32-bit integer\nidentifying the error code (Section 7).  The error code indicates why\nthe stream is being terminated.")]),e._v(" "),n("p",[e._v("The RST_STREAM frame does not define any flags.")]),e._v(" "),n("p",[e._v('The RST_STREAM frame fully terminates the referenced stream and\ncauses it to enter the "closed" state.  After receiving a RST_STREAM\non a stream, the receiver MUST NOT send additional frames for that\nstream, with the exception of PRIORITY.  However, after sending the\nRST_STREAM, the sending endpoint MUST be prepared to receive and\nprocess additional frames sent on the stream that might have been\nsent by the peer prior to the arrival of the RST_STREAM.')]),e._v(" "),n("p",[e._v("RST_STREAM frames MUST be associated with a stream.  If a RST_STREAM\nframe is received with a stream identifier of 0x0, the recipient MUST\ntreat this as a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v('RST_STREAM frames MUST NOT be sent for a stream in the "idle" state.\nIf a RST_STREAM frame identifying an idle stream is received, the\nrecipient MUST treat this as a connection error (Section 5.4.1) of\ntype PROTOCOL_ERROR.')]),e._v(" "),n("p",[e._v("A RST_STREAM frame with a length other than 4 octets MUST be treated\nas a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.")])])])]),e._v(" "),n("h3",{attrs:{id:"_6-5-settings"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-settings"}},[e._v("#")]),e._v(" 6.5 SETTINGS")]),e._v(" "),n("p",[e._v("SETTINGS帧（类型=0x4）传达影响端点通信方式的配置参数，例如，对等方行为的偏好和约束。 SETTINGS帧也用于确认那些参数的接收。单独地，SETTINGS参数也可以称为"),n("code",[e._v("setting")]),e._v("。")]),e._v(" "),n("p",[e._v("它们描述了发送方的特征，接收方使用这些特征。每个对等体可以通告相同参数的不同值。例如，客户端可能会设置较高的初始流控制窗口，而服务器可能会设置较低的值以节省资源。")]),e._v(" "),n("p",[e._v("SETTINGS帧必须在连接开始时由两个端点发送，并且可以在任何其他时间由任一端点发送连接的整个生命周期内的端点。实现必须支持该规范定义的所有参数。")]),e._v(" "),n("p",[e._v("SETTINGS帧中的每个参数都将替换该参数的任何现有值。参数按照它们出现的顺序进行处理，并且SETTINGS帧的接收者不需要维护其参数当前值以外的任何状态。因此，SETTINGS参数的值是areceiver看到的最后一个值。")]),e._v(" "),n("p",[e._v("SETTINGS参数被接收对等方确认。要启用此功能，SETTINGS帧定义以下标志：")]),e._v(" "),n("ul",[n("li",[e._v("ACK（0x1）：设置后，位0指示此帧确认对等方SETTINGS帧的接收和应用。设置此位后，SETTINGS帧的有效载荷必须为空。接收到设置了ACK标志且长度字段值不为0的SETTINGS帧，必须将其视为FRAME_SIZE_ERROR类型的连接错误（第5.4.1节）。有关更多信息，请参见第6.5.3节（“设置同步”）。")])]),e._v(" "),n("p",[e._v("SETTINGS帧始终应用于连接，而不是单个流。SETTINGS帧的流标识符必须为零（0x0）。如果端点接收到流标识符字段不是0x0的SETTINGS帧，则端点必须以"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）进行响应。")]),e._v(" "),n("p",[e._v("SETTINGS帧影响连接状态。格式错误或不完整的SETTINGS帧必须视为"),n("code",[e._v("PROTOCOL_ERROR")]),e._v("类型的连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("长度除6个八位位组的倍数以外的SETTINGS帧必须视为"),n("code",[e._v("FRAME_SIZE_ERROR")]),e._v("类型的连接错误（5.4.1节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.5.  SETTINGS")]),e._v("\n"),n("p",[e._v('The SETTINGS frame (type=0x4) conveys configuration parameters that\naffect how endpoints communicate, such as preferences and constraints\non peer behavior.  The SETTINGS frame is also used to acknowledge the\nreceipt of those parameters.  Individually, a SETTINGS parameter can\nalso be referred to as a "setting".')]),e._v("\n"),n("p",[e._v("SETTINGS parameters are not negotiated; they describe characteristics\nof the sending peer, which are used by the receiving peer.  Different\nvalues for the same parameter can be advertised by each peer.  For\nexample, a client might set a high initial flow-control window,\nwhereas a server might set a lower value to conserve resources.")]),e._v("\n"),n("p",[e._v("A SETTINGS frame MUST be sent by both endpoints at the start of a\nconnection and MAY be sent at any other time by either endpoint over\nthe lifetime of the connection.  Implementations MUST support all of\nthe parameters defined by this specification.")]),e._v("\n"),n("p",[e._v("Each parameter in a SETTINGS frame replaces any existing value for\nthat parameter.  Parameters are processed in the order in which they\nappear, and a receiver of a SETTINGS frame does not need to maintain\nany state other than the current value of its parameters.  Therefore,\nthe value of a SETTINGS parameter is the last value that is seen by a\nreceiver.")]),e._v("\n"),n("p",[e._v("SETTINGS parameters are acknowledged by the receiving peer.  To\nenable this, the SETTINGS frame defines the following flag:")]),e._v("\n"),n("p",[e._v('ACK (0x1):  When set, bit 0 indicates that this frame acknowledges\nreceipt and application of the peer\'s SETTINGS frame.  When this\nbit is set, the payload of the SETTINGS frame MUST be empty.\nReceipt of a SETTINGS frame with the ACK flag set and a length\nfield value other than 0 MUST be treated as a connection error\n(Section 5.4.1) of type FRAME_SIZE_ERROR.  For more information,\nsee Section 6.5.3 ("Settings Synchronization").')]),e._v("\n"),n("p",[e._v("SETTINGS frames always apply to a connection, never a single stream.\nThe stream identifier for a SETTINGS frame MUST be zero (0x0).  If an\nendpoint receives a SETTINGS frame whose stream identifier field is\nanything other than 0x0, the endpoint MUST respond with a connection\nerror (Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v("\n"),n("p",[e._v("The SETTINGS frame affects connection state.  A badly formed or\nincomplete SETTINGS frame MUST be treated as a connection error\n(Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v("\n"),n("p",[e._v("A SETTINGS frame with a length other than a multiple of 6 octets MUST\nbe treated as a connection error (Section 5.4.1) of type\nFRAME_SIZE_ERROR.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_6-5-1-settings格式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-1-settings格式"}},[e._v("#")]),e._v(" 6.5.1 SETTINGS格式")]),e._v(" "),n("p",[e._v("SETTINGS帧的有效载荷由零个或多个参数组成，每个参数由一个无符号的16位设置标识符和一个无符号的32位值组成。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +-------------------------------+\n    |       Identifier (16)         |\n    +-------------------------------+-------------------------------+\n    |                        Value (32)                             |\n    +---------------------------------------------------------------+\n\n                         Figure 10: Setting Format\n")])])]),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.5.1.  SETTINGS Format")]),e._v("\n"),n("p",[e._v("The payload of a SETTINGS frame consists of zero or more parameters,\neach consisting of an unsigned 16-bit setting identifier and an\nunsigned 32-bit value.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+-------------------------------+\n|       Identifier (16)         |\n+-------------------------------+-------------------------------+\n|                        Value (32)                             |\n+---------------------------------------------------------------+\n\n                     Figure 10: Setting Format\n")])])])])])]),e._v(" "),n("h4",{attrs:{id:"_6-5-2-定义settings参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-2-定义settings参数"}},[e._v("#")]),e._v(" 6.5.2 定义SETTINGS参数")]),e._v(" "),n("p",[e._v("定义了以下参数：")]),e._v(" "),n("ul",[n("li",[e._v("SETTINGS_HEADER_TABLE_SIZE（0x1）：允许发送方以字节为单位，通知远程端点用于解码标头块的标头压缩表的最大大小。编码器可以通过使用特定于前端块内标头压缩格式的信号来选择等于或小于此值的任何大小（请参阅[COMPRESSION]）。初始值为4,096个八位位组。")]),e._v(" "),n("li",[e._v("SETTINGS_ENABLE_PUSH（0x2）：此设置可用于禁用服务器推送（第8.2节）。如果端点接收到此参数设置为0，则不得发送PUSH_PROMISE帧。既已将此参数都设置为0且已被确认的端点必须将PUSH_PROMISE帧的接收视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。\n初始值为1，表示允许服务器推送。除0或1以外的任何值都必须被视为类型为PROTOCOL_ERROR。")]),e._v(" "),n("li",[e._v("SETTINGS_MAX_CONCURRENT_STREAMS（0x3）的连接错误（第5.4.1节）：指示发送方允许的最大并发流数。此限制是有方向的：它适用于发送方允许接收方创建的流的数量。最初，此值没有限制。建议该值不小于100，以免不必要地限制并行度。端点不应将SETTINGS_MAX_CONCURRENT_STREAMS的0值视为特殊值。零值的确会阻止创建新的流。但是，对于活动流耗尽的任何限制也可能发生这种情况。服务器应仅在短时间内设置零值；如果服务器不希望接受请求，则更合适的方法是关闭连接。")]),e._v(" "),n("li",[e._v("SETTINGS_INITIAL_WINDOW_SIZE（0x4）：指示发送方的初始窗口大小（以八位字节为单位），用于流级别的流控制。初始值为2^16-1（65,535）个八位位组。此设置影响所有流的窗口大小（请参见6.9.2节）。大于最大流控制窗口大小2^31-1的值必须视为FLOW_CONTROL_ERROR类型的连接错误（第5.4.1节）。")]),e._v(" "),n("li",[e._v("SETTINGS_MAX_FRAME_SIZE（0x5）：指示发送方愿意的最大帧有效负载的大小以八位位组接收。初始值为2^14（16,384）个八位位组。端点通告的值必须在此初始值和允许的最大帧大小（2 ^ 24-1或16,777,215个八位位组）之间（包括此值）。超出此范围的值必须视为类型为PROTOCOL_ERROR的连接错误（第5.4.1节）。")]),e._v(" "),n("li",[e._v("SETTINGS_MAX_HEADER_LIST_SIZE（0x6）：此建议设置通知发送方准备接受的报头列表的最大大小（八位字节）。该值基于标题字段的未压缩大小，包括名称的长度和以八位字节为单位的值，以及每个标题字段的32个八位字节的开销。\n对于任何给定的请求，可以强制执行比所公布的更低的限制。此设置的初始值是无限的。")])]),e._v(" "),n("p",[e._v("接收到带有任何未知或不受支持的标识符的SETTINGS帧的端点必须忽略该设置。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.5.2.  Defined SETTINGS Parameters")]),e._v("\n"),n("p",[e._v("The following parameters are defined:")]),e._v("\n"),n("p",[e._v("SETTINGS_HEADER_TABLE_SIZE (0x1):  Allows the sender to inform the\nremote endpoint of the maximum size of the header compression\ntable used to decode header blocks, in octets.  The encoder can\nselect any size equal to or less than this value by using\nsignaling specific to the header compression format inside a\nheader block (see [COMPRESSION]).  The initial value is 4,096\noctets.")]),e._v("\n"),n("p",[e._v("SETTINGS_ENABLE_PUSH (0x2):  This setting can be used to disable\nserver push (Section 8.2).  An endpoint MUST NOT send a\nPUSH_PROMISE frame if it receives this parameter set to a value of\n0.  An endpoint that has both set this parameter to 0 and had it\nacknowledged MUST treat the receipt of a PUSH_PROMISE frame as a\nconnection error (Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  The initial value is 1, which indicates that server push is\n  permitted.  Any value other than 0 or 1 MUST be treated as a\n  connection error (Section 5.4.1) of type PROTOCOL_ERROR.\n")])])]),n("p",[e._v("SETTINGS_MAX_CONCURRENT_STREAMS (0x3):  Indicates the maximum number\nof concurrent streams that the sender will allow.  This limit is\ndirectional: it applies to the number of streams that the sender\npermits the receiver to create.  Initially, there is no limit to\nthis value.  It is recommended that this value be no smaller than\n100, so as to not unnecessarily limit parallelism.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be\n  treated as special by endpoints.  A zero value does prevent the\n  creation of new streams; however, this can also happen for any\n  limit that is exhausted with active streams.  Servers SHOULD only\n  set a zero value for short durations; if a server does not wish to\n  accept requests, closing the connection is more appropriate.\n")])])]),n("p",[e._v("SETTINGS_INITIAL_WINDOW_SIZE (0x4):  Indicates the sender's initial\nwindow size (in octets) for stream-level flow control.  The\ninitial value is 2^16-1 (65,535) octets.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  This setting affects the window size of all streams (see\n  Section 6.9.2).\n\n  Values above the maximum flow-control window size of 2^31-1 MUST\n  be treated as a connection error (Section 5.4.1) of type\n  FLOW_CONTROL_ERROR.\n")])])]),n("p",[e._v("SETTINGS_MAX_FRAME_SIZE (0x5):  Indicates the size of the largest\nframe payload that the sender is willing to receive, in octets.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  The initial value is 2^14 (16,384) octets.  The value advertised\n  by an endpoint MUST be between this initial value and the maximum\n  allowed frame size (2^24-1 or 16,777,215 octets), inclusive.\n  Values outside this range MUST be treated as a connection error\n  (Section 5.4.1) of type PROTOCOL_ERROR.\n")])])]),n("p",[e._v("SETTINGS_MAX_HEADER_LIST_SIZE (0x6):  This advisory setting informs a\npeer of the maximum size of header list that the sender is\nprepared to accept, in octets.  The value is based on the\nuncompressed size of header fields, including the length of the\nname and value in octets plus an overhead of 32 octets for each\nheader field.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  For any given request, a lower limit than what is advertised MAY\n  be enforced.  The initial value of this setting is unlimited.\n")])])]),n("p",[e._v("An endpoint that receives a SETTINGS frame with any unknown or\nunsupported identifier MUST ignore that setting.")])])])]),e._v(" "),n("h4",{attrs:{id:"_6-5-3-设置同步"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-3-设置同步"}},[e._v("#")]),e._v(" 6.5.3 设置同步")]),e._v(" "),n("p",[e._v("SETTINGS中的大多数值受益于或需要了解对等方何时接收并应用更改后的参数值。为了提供此类同步时间点，未设置ACK标志的SETTINGS帧的接收者必须尽快应用更新的参数。")]),e._v(" "),n("p",[e._v("SETTINGS帧中的值必须按照它们出现的顺序进行处理，而各值之间不得进行其他帧处理。不支持的参数必须被忽略。一旦处理完所有值，接收方必须立即发出带有ACK标志集的SETTINGS帧。收到设置了ACK标志的SETTINGS帧后，更改的参数的发送者可以依赖于已应用的设置。")]),e._v(" "),n("p",[e._v("如果SETTINGS帧的发送者在合理的时间内未收到确认，则可能会发出连接错误（本节5.4.1）类型的SETTINGS_TIMEOUT。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.5.3.  Settings Synchronization")]),e._v("\n"),n("p",[e._v("Most values in SETTINGS benefit from or require an understanding of\nwhen the peer has received and applied the changed parameter values.\nIn order to provide such synchronization timepoints, the recipient of\na SETTINGS frame in which the ACK flag is not set MUST apply the\nupdated parameters as soon as possible upon receipt.")]),e._v("\n"),n("p",[e._v("The values in the SETTINGS frame MUST be processed in the order they\nappear, with no other frame processing between values.  Unsupported\nparameters MUST be ignored.  Once all values have been processed, the\nrecipient MUST immediately emit a SETTINGS frame with the ACK flag\nset.  Upon receiving a SETTINGS frame with the ACK flag set, the\nsender of the altered parameters can rely on the setting having been\napplied.")]),e._v("\n"),n("p",[e._v("If the sender of a SETTINGS frame does not receive an acknowledgement\nwithin a reasonable amount of time, it MAY issue a connection error\n(Section 5.4.1) of type SETTINGS_TIMEOUT.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_6-6-push-promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-push-promise"}},[e._v("#")]),e._v(" 6.6 PUSH_PROMISE")]),e._v(" "),n("p",[e._v("PUSH_PROMISE帧（类型=0x5）用于在发送方打算初始化的流之前提前通知对等终结点。 PUSH_PROMISE帧包括端点计划创建的流的无符号31位标识符，以及为流提供其他上下文的一组报头。 8.2节详细介绍了PUSH_PROMISE帧的使用。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +---------------+\n    |Pad Length? (8)|\n    +-+-------------+-----------------------------------------------+\n    |R|                  Promised Stream ID (31)                    |\n    +-+-----------------------------+-------------------------------+\n    |                   Header Block Fragment (*)                 ...\n    +---------------------------------------------------------------+\n    |                           Padding (*)                       ...\n    +---------------------------------------------------------------+\n\n                  Figure 11: PUSH_PROMISE Payload Format\n")])])]),n("p",[e._v("PUSH_PROMISE帧有效载荷具有以下字段：")]),e._v(" "),n("ul",[n("li",[e._v("Pad Length：一个8位字段，包含以八位字节为单位的帧填充长度。仅当设置了PADDED标志时，此字段才存在。")]),e._v(" "),n("li",[e._v("R：单个保留位。")]),e._v(" "),n("li",[e._v("Promised Stream ID: 一个无符号的31位整数，用于标识PUSH_PROMISE保留的流。承诺的流标识符必须是发送方发送的下一个流的有效选择（请参阅第5.1.1节中的“新流标识符”）。")]),e._v(" "),n("li",[e._v("Header Block Fragment：包含请求标头字段的标头块片段（第4.3节）。")]),e._v(" "),n("li",[e._v("Padding：填充八位字节。")])]),e._v(" "),n("p",[e._v("PUSH_PROMISE帧定义以下标志：")]),e._v(" "),n("ul",[n("li",[e._v("END_HEADERS（0x4）：置位时，位2指示该帧包含整个标题块（第4.3节），并且之后没有任何CONTINUATION帧。没有设置END_HEADERS标志的PUSH_PROMISE帧之后必须是同一流的CONTINUATION帧。接收者必须将接收到的任何其他类型的帧或不同流上的帧视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）")]),e._v(" "),n("li",[e._v("PADDED（0x8）：置位时，第3位指示Pad Length字段以及任何存在它描述的填充。")])]),e._v(" "),n("p",[e._v("PUSH_PROMISE帧只能在处于"),n("code",[e._v("open")]),e._v("或"),n("code",[e._v("half-close(remote)")]),e._v("状态的对等方发起的流上发送。 PUSH_PROMISE帧的流标识符指示与其关联的流。如果流标识符字段指定值为0x0，则接收者务必以PROTOCOL_ERROR类型的连接错误（第5.4.1节）进行响应。")]),e._v(" "),n("p",[e._v("不需要按承诺的顺序使用承诺的流。 PUSH_PROMISE仅保留流标识符供以后使用。如果对等端点的SETTINGS_ENABLE_PUSH设置设为0，则不得发送PUSH_PROMISE。已设置此设置并已收到确认的端点必须将PUSH_PROMISE帧的接收视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("PUSH_PROMISE帧的接收者可以选择返回RST_STREAM，将RST的流标识符返回给PUSH_PROMISE的发送者，从而拒绝承诺的流。")]),e._v(" "),n("p",[e._v("PUSH_PROMISE帧以两种方式修改连接状态。首先，包含头块（第4.3节）可能会修改为头压缩而维护的状态。其次，PUSH_PROMISE还保留了一个流供以后使用，从而使承诺的流进入"),n("code",[e._v("reserved")]),e._v("状态。发送者不得在流上发送PUSH_PROMISE，除非该流是"),n("code",[e._v("open")]),e._v("或"),n("code",[e._v("half-closed (remote)")]),e._v("；发送方必须确保承诺流是新流标识符的有效选择（第5.1.1节）（也就是说，承诺流必须处于“空闲”状态）。")]),e._v(" "),n("p",[e._v("由于PUSH_PROMISE保留流，因此忽略PUSH_PROMISE帧会导致流状态变得不确定。接收者必须处理既不是“开放”也不是“半封闭（本地）”的流上的PUSH_PROMISE接收，作为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。但是，在相关流上发送了RST_STREAM的端点必须处理在接收和处理RST_STREAM帧之前可能已经创建的PUSH_PROMISE帧。")]),e._v(" "),n("p",[e._v("接收者必须将收到的PUSH_PROMISE视为允诺将非法流标识符（第5.1.1节）视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。注意，非法的流标识符是当前不处于“空闲”状态的流的标识符。")]),e._v(" "),n("p",[e._v("PUSH_PROMISE帧可以包含填充。填充字段和标志与为DATA帧定义的填充字段和标志相同（第6.1节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.6.  PUSH_PROMISE")]),e._v("\n"),n("p",[e._v("The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint\nin advance of streams the sender intends to initiate.  The\nPUSH_PROMISE frame includes the unsigned 31-bit identifier of the\nstream the endpoint plans to create along with a set of headers that\nprovide additional context for the stream.  Section 8.2 contains a\nthorough description of the use of PUSH_PROMISE frames.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+---------------+\n|Pad Length? (8)|\n+-+-------------+-----------------------------------------------+\n|R|                  Promised Stream ID (31)                    |\n+-+-----------------------------+-------------------------------+\n|                   Header Block Fragment (*)                 ...\n+---------------------------------------------------------------+\n|                           Padding (*)                       ...\n+---------------------------------------------------------------+\n\n              Figure 11: PUSH_PROMISE Payload Format\n")])])]),n("p",[e._v("The PUSH_PROMISE frame payload has the following fields:")]),e._v(" "),n("p",[e._v("Pad Length:  An 8-bit field containing the length of the frame\npadding in units of octets.  This field is only present if the\nPADDED flag is set.")]),e._v(" "),n("p",[e._v("R: A single reserved bit.")]),e._v(" "),n("p",[e._v('Promised Stream ID:  An unsigned 31-bit integer that identifies the\nstream that is reserved by the PUSH_PROMISE.  The promised stream\nidentifier MUST be a valid choice for the next stream sent by the\nsender (see "new stream identifier" in Section 5.1.1).')]),e._v(" "),n("p",[e._v("Header Block Fragment:  A header block fragment (Section 4.3)\ncontaining request header fields.")]),e._v(" "),n("p",[e._v("Padding:  Padding octets.")]),e._v(" "),n("p",[e._v("The PUSH_PROMISE frame defines the following flags:")]),e._v(" "),n("p",[e._v("END_HEADERS (0x4):  When set, bit 2 indicates that this frame\ncontains an entire header block (Section 4.3) and is not followed\nby any CONTINUATION frames.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  A PUSH_PROMISE frame without the END_HEADERS flag set MUST be\n  followed by a CONTINUATION frame for the same stream.  A receiver\n  MUST treat the receipt of any other type of frame or a frame on a\n  different stream as a connection error (Section 5.4.1) of type\n  PROTOCOL_ERROR.\n")])])]),n("p",[e._v("PADDED (0x8):  When set, bit 3 indicates that the Pad Length field\nand any padding that it describes are present.")]),e._v(" "),n("p",[e._v('PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that\nis in either the "open" or "half-closed (remote)" state.  The stream\nidentifier of a PUSH_PROMISE frame indicates the stream it is\nassociated with.  If the stream identifier field specifies the value\n0x0, a recipient MUST respond with a connection error (Section 5.4.1)\nof type PROTOCOL_ERROR.')]),e._v(" "),n("p",[e._v("Promised streams are not required to be used in the order they are\npromised.  The PUSH_PROMISE only reserves stream identifiers for\nlater use.")]),e._v(" "),n("p",[e._v("PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of\nthe peer endpoint is set to 0.  An endpoint that has set this setting\nand has received acknowledgement MUST treat the receipt of a\nPUSH_PROMISE frame as a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v("Recipients of PUSH_PROMISE frames can choose to reject promised\nstreams by returning a RST_STREAM referencing the promised stream\nidentifier back to the sender of the PUSH_PROMISE.")]),e._v(" "),n("p",[e._v('A PUSH_PROMISE frame modifies the connection state in two ways.\nFirst, the inclusion of a header block (Section 4.3) potentially\nmodifies the state maintained for header compression.  Second,\nPUSH_PROMISE also reserves a stream for later use, causing the\npromised stream to enter the "reserved" state.  A sender MUST NOT\nsend a PUSH_PROMISE on a stream unless that stream is either "open"\nor "half-closed (remote)"; the sender MUST ensure that the promised\nstream is a valid choice for a new stream identifier (Section 5.1.1)\n(that is, the promised stream MUST be in the "idle" state).')]),e._v(" "),n("p",[e._v('Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame\ncauses the stream state to become indeterminate.  A receiver MUST\ntreat the receipt of a PUSH_PROMISE on a stream that is neither\n"open" nor "half-closed (local)" as a connection error\n(Section 5.4.1) of type PROTOCOL_ERROR.  However, an endpoint that\nhas sent RST_STREAM on the associated stream MUST handle PUSH_PROMISE\nframes that might have been created before the RST_STREAM frame is\nreceived and processed.')]),e._v(" "),n("p",[e._v('A receiver MUST treat the receipt of a PUSH_PROMISE that promises an\nillegal stream identifier (Section 5.1.1) as a connection error\n(Section 5.4.1) of type PROTOCOL_ERROR.  Note that an illegal stream\nidentifier is an identifier for a stream that is not currently in the\n"idle" state.')]),e._v(" "),n("p",[e._v("The PUSH_PROMISE frame can include padding.  Padding fields and flags\nare identical to those defined for DATA frames (Section 6.1).")])])])]),e._v(" "),n("h3",{attrs:{id:"_6-7-ping"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-ping"}},[e._v("#")]),e._v(" 6.7 PING")]),e._v(" "),n("p",[e._v("PING帧（类型=0x6）是一种机制，用于测量来自发送方的最短往返时间，并确定是否仍能正常进行连接。可以从任何端点发送PING帧。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +---------------------------------------------------------------+\n    |                                                               |\n    |                      Opaque Data (64)                         |\n    |                                                               |\n    +---------------------------------------------------------------+\n\n                      Figure 12: PING Payload Format\n")])])]),n("p",[e._v("除帧头外，PING帧还必须在有效载荷中包含8个八位字节的不透明数据。发送者可以选择任何值，并以任何方式使用这些八位位组。")]),e._v(" "),n("p",[e._v("不包含ACK标志的PING帧的接收者必须发送一个ACK标志作为响应而设置的PING帧，并具有相同的有效载荷。与其他任何帧相比，应该给PING响应更高的优先级。")]),e._v(" "),n("p",[e._v("PING帧定义以下标志：")]),e._v(" "),n("ul",[n("li",[e._v("ACK（0x1）：置1时，位0指示此PING帧是PING响应。端点必须在PING响应中设置该标志。端点不得响应包含此标志的PING帧。")])]),e._v(" "),n("p",[e._v("PING帧不与任何单独的流相关联。如果收到的PINGframe的流标识符字段值不是0x0，则接收者务必以PROTOCOL_ERROR类型的连接错误（第5.4.1节）做出响应。")]),e._v(" "),n("p",[e._v("收到长度字段值为8以外的PING帧时，必须将其视为FRAME_SIZE_ERROR类型的连接错误（第5.4.1节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.7.  PING")]),e._v("\n"),n("p",[e._v("The PING frame (type=0x6) is a mechanism for measuring a minimal\nround-trip time from the sender, as well as determining whether an\nidle connection is still functional.  PING frames can be sent from\nany endpoint.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+---------------------------------------------------------------+\n|                                                               |\n|                      Opaque Data (64)                         |\n|                                                               |\n+---------------------------------------------------------------+\n\n                  Figure 12: PING Payload Format\n")])])]),n("p",[e._v("In addition to the frame header, PING frames MUST contain 8 octets of\nopaque data in the payload.  A sender can include any value it\nchooses and use those octets in any fashion.")]),e._v(" "),n("p",[e._v("Receivers of a PING frame that does not include an ACK flag MUST send\na PING frame with the ACK flag set in response, with an identical\npayload.  PING responses SHOULD be given higher priority than any\nother frame.")]),e._v(" "),n("p",[e._v("The PING frame defines the following flags:")]),e._v(" "),n("p",[e._v("ACK (0x1):  When set, bit 0 indicates that this PING frame is a PING\nresponse.  An endpoint MUST set this flag in PING responses.  An\nendpoint MUST NOT respond to PING frames containing this flag.")]),e._v(" "),n("p",[e._v("PING frames are not associated with any individual stream.  If a PING\nframe is received with a stream identifier field value other than\n0x0, the recipient MUST respond with a connection error\n(Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v("Receipt of a PING frame with a length field value other than 8 MUST\nbe treated as a connection error (Section 5.4.1) of type\nFRAME_SIZE_ERROR.")])])])]),e._v(" "),n("h3",{attrs:{id:"_6-8-goaway"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-goaway"}},[e._v("#")]),e._v(" 6.8 GOAWAY")]),e._v(" "),n("p",[e._v("GOAWAY帧（类型=0x7）用于启动连接的关闭或发出严重的错误情况信号。 GOAWAY允许端点优雅地停止接受新的流，同时仍然完成对先前建立的流的处理。这样就可以执行诸如服务器维护之类的管理操作。")]),e._v(" "),n("p",[e._v("在端点之间，存在一个固有的竞争条件，即启动新数据流的端点与远程发送GOAWAY帧的端点之间。为了处理这种情况，GOAWAY包含该连接的发送端上已经或可能处理的最后一个对等端发起的流的流标识符。例如，如果服务器发送GOAWAY帧，则标识的流是客户端启动的编号最高的流。")]),e._v(" "),n("p",[e._v("发送后，如果流的标识符高于所包含的最后一个流标识符，则发送方将忽略在接收方发起的流上发送的帧。尽管可以为新的流建立新的连接，但GOAWAY帧的接收方一定不能在连接上打开其他流。")]),e._v(" "),n("p",[e._v("如果GOAWAY的接收方已在流标识符高于GOAWAY帧指示的流上发送数据，则这些流不会或将不会被处理。 GOAWAY帧的接收方可以将这些流视为从未创建过的流，从而允许这些流稍后在新的连接上重试。")]),e._v(" "),n("p",[e._v("端点应始终在关闭连接之前发送GOAWAY帧，以便远程对等方可以知道流是否已部分处理。例如，如果HTTP客户端在服务器关闭连接的同时发送POST，则如果服务器未发送GOAWAY帧来指示其可能作用的流，则客户端无法知道服务器是否开始处理该POST请求。")]),e._v(" "),n("p",[e._v("端点可能选择关闭连接，而不发送用于对等端行为不佳的GOAWAY。")]),e._v(" "),n("p",[e._v("GOAWAY帧可能不会立即关闭连接；不再使用该连接的GOAWAY的接收方在终止连接之前仍应发送GOAWAY帧。")]),e._v(" "),n("p",[e._v("···\n+-+-------------------------------------------------------------+\n|R|                  Last-Stream-ID (31)                        |\n+-+-------------------------------------------------------------+\n|                      Error Code (32)                          |\n+---------------------------------------------------------------+\n|                  Additional Debug Data (*)                    |\n+---------------------------------------------------------------+")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("             Figure 13: GOAWAY Payload Format\n")])])]),n("p",[e._v("···")]),e._v(" "),n("p",[e._v("GOAWAY帧未定义任何标志。")]),e._v(" "),n("p",[e._v("GOAWAY帧适用于连接，而不是特定的流。端点必须将流标识符非0x0的GOAWAY帧视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("GOAWAY帧中的最后一个流标识符包含编号最高的流标识符，对于该标识符，GOAWAY帧的发送者可能已对其采取了某些措施或可能尚未采取措施。直至并包括已标识流的所有流都可能已经过某种处理。如果未处理任何流，则最后一个流标识符可以设置为0。")]),e._v(" "),n("p",[e._v("注意：在这种情况下，“已处理”是指流中的某些数据被传递到了可能会采取某些措施的较高软件层。")]),e._v(" "),n("p",[e._v("如果连接终止而没有GOAWAY帧，则最后一个流标识符实际上是最高的可能的流标识符。")]),e._v(" "),n("p",[e._v("在具有较低编号或相等编号的标识符的流（在关闭连接之前未完全关闭）上，无法重新尝试请求，事务或任何协议活动，但幂等操作（例如HTTP GET，PUT或DELETE）除外。可以使用新连接安全地重试使用编号更高的流的任何协议活动。")]),e._v(" "),n("p",[e._v("编号小于或等于最后一个streamidentifier的流上的活动仍可能成功完成。 GOAWAY帧的发送方可以通过发送GOAWAY帧来正常关闭连接，将连接保持在“打开”状态，直到所有进行中的流完成为止。")]),e._v(" "),n("p",[e._v("如果情况发生变化，端点可能会发送多个GOAWAY帧。例如，在正常关机期间发送NO_ERROR的GOAWAY端点可能随后遇到需要立即终止连接的情况。从最后收到的GOAWAY帧中收到的最后一个流标识符表示哪些流可能已经作用了。端点不得增加它们在最后一个流标识符中发送的值，因为对等点可能已经在另一个连接上重试了未处理的请求。")]),e._v(" "),n("p",[e._v("当服务器关闭连接时，无法重试请求的客户端将丢失所有正在处理的请求。对于可能不使用HTTP/2为客户端提供服务的中介而言，尤其如此。试图正常关闭连接的服务器应发送初始GOAWAY帧，最后一个流标识符设置为2^31-1，并提供NO_ERROR代码。这向客户端发出信号，即将关闭，并且禁止发起进一步的请求。在为任何进行中的流式传输留出时间（至少一个往返时间）之后，服务器可以发送具有更新的最后一个流标识符的另一个GOAWAY帧。这确保了可以干净地关闭连接而不会丢失请求。")]),e._v(" "),n("p",[e._v("发送GOAWAY帧后，发送方可以丢弃接收方发起的流的帧，其标识符要比所标识的最后一个流高。但是，任何更改连接状态的框架都不能完全忽略。例如，必须最少处理HEADERS，PUSH_PROMISE和CONTINUATION帧，以确保为报头压缩保持的状态是一致的（请参见第4.3节）；类似地，数据帧必须计入连接流控制窗口。无法处理这些帧会导致流控制或报头压缩状态变得不同步。")]),e._v(" "),n("p",[e._v("GOAWAY框架还包含一个32位错误代码（第7节），其中包含关闭连接的原因。")]),e._v(" "),n("p",[e._v("端点可以将不透明数据附加到任何GOAWAY帧的有效载荷上。其他调试数据仅用于诊断目的，不带语义值。调试信息可能包含对安全性或隐私敏感的数据。已记录或以其他方式持久存储的调试数据必须具有足够的防护措施，以防止未经授权的访问。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.8.  GOAWAY")]),e._v("\n"),n("p",[e._v("The GOAWAY frame (type=0x7) is used to initiate shutdown of a\nconnection or to signal serious error conditions.  GOAWAY allows an\nendpoint to gracefully stop accepting new streams while still\nfinishing processing of previously established streams.  This enables\nadministrative actions, like server maintenance.")]),e._v("\n"),n("p",[e._v("There is an inherent race condition between an endpoint starting new\nstreams and the remote sending a GOAWAY frame.  To deal with this\ncase, the GOAWAY contains the stream identifier of the last peer-\ninitiated stream that was or might be processed on the sending\nendpoint in this connection.  For instance, if the server sends a\nGOAWAY frame, the identified stream is the highest-numbered stream\ninitiated by the client.")]),e._v("\n"),n("p",[e._v("Once sent, the sender will ignore frames sent on streams initiated by\nthe receiver if the stream has an identifier higher than the included\nlast stream identifier.  Receivers of a GOAWAY frame MUST NOT open\nadditional streams on the connection, although a new connection can\nbe established for new streams.")]),e._v("\n"),n("p",[e._v("If the receiver of the GOAWAY has sent data on streams with a higher\nstream identifier than what is indicated in the GOAWAY frame, those\nstreams are not or will not be processed.  The receiver of the GOAWAY\nframe can treat the streams as though they had never been created at\nall, thereby allowing those streams to be retried later on a new\nconnection.")]),e._v("\n"),n("p",[e._v("Endpoints SHOULD always send a GOAWAY frame before closing a\nconnection so that the remote peer can know whether a stream has been\npartially processed or not.  For example, if an HTTP client sends a\nPOST at the same time that a server closes a connection, the client\ncannot know if the server started to process that POST request if the\nserver does not send a GOAWAY frame to indicate what streams it might\nhave acted on.")]),e._v("\n"),n("p",[e._v("An endpoint might choose to close a connection without sending a\nGOAWAY for misbehaving peers.")]),e._v("\n"),n("p",[e._v("A GOAWAY frame might not immediately precede closing of the\nconnection; a receiver of a GOAWAY that has no more use for the\nconnection SHOULD still send a GOAWAY frame before terminating the\nconnection.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+-+-------------------------------------------------------------+\n|R|                  Last-Stream-ID (31)                        |\n+-+-------------------------------------------------------------+\n|                      Error Code (32)                          |\n+---------------------------------------------------------------+\n|                  Additional Debug Data (*)                    |\n+---------------------------------------------------------------+\n\n                 Figure 13: GOAWAY Payload Format\n")])])]),n("p",[e._v("The GOAWAY frame does not define any flags.")]),e._v(" "),n("p",[e._v("The GOAWAY frame applies to the connection, not a specific stream.\nAn endpoint MUST treat a GOAWAY frame with a stream identifier other\nthan 0x0 as a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v("The last stream identifier in the GOAWAY frame contains the highest-\nnumbered stream identifier for which the sender of the GOAWAY frame\nmight have taken some action on or might yet take action on.  All\nstreams up to and including the identified stream might have been\nprocessed in some way.  The last stream identifier can be set to 0 if\nno streams were processed.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('  Note: In this context, "processed" means that some data from the\n  stream was passed to some higher layer of software that might have\n  taken some action as a result.\n')])])]),n("p",[e._v("If a connection terminates without a GOAWAY frame, the last stream\nidentifier is effectively the highest possible stream identifier.")]),e._v(" "),n("p",[e._v("On streams with lower- or equal-numbered identifiers that were not\nclosed completely prior to the connection being closed, reattempting\nrequests, transactions, or any protocol activity is not possible,\nwith the exception of idempotent actions like HTTP GET, PUT, or\nDELETE.  Any protocol activity that uses higher-numbered streams can\nbe safely retried using a new connection.")]),e._v(" "),n("p",[e._v('Activity on streams numbered lower or equal to the last stream\nidentifier might still complete successfully.  The sender of a GOAWAY\nframe might gracefully shut down a connection by sending a GOAWAY\nframe, maintaining the connection in an "open" state until all in-\nprogress streams complete.')]),e._v(" "),n("p",[e._v("An endpoint MAY send multiple GOAWAY frames if circumstances change.\nFor instance, an endpoint that sends GOAWAY with NO_ERROR during\ngraceful shutdown could subsequently encounter a condition that\nrequires immediate termination of the connection.  The last stream\nidentifier from the last GOAWAY frame received indicates which\nstreams could have been acted upon.  Endpoints MUST NOT increase the\nvalue they send in the last stream identifier, since the peers might\nalready have retried unprocessed requests on another connection.")]),e._v(" "),n("p",[e._v("A client that is unable to retry requests loses all requests that are\nin flight when the server closes the connection.  This is especially\ntrue for intermediaries that might not be serving clients using\nHTTP/2.  A server that is attempting to gracefully shut down a\nconnection SHOULD send an initial GOAWAY frame with the last stream\nidentifier set to 2^31-1 and a NO_ERROR code.  This signals to the\nclient that a shutdown is imminent and that initiating further\nrequests is prohibited.  After allowing time for any in-flight stream\ncreation (at least one round-trip time), the server can send another\nGOAWAY frame with an updated last stream identifier.  This ensures\nthat a connection can be cleanly shut down without losing requests.")]),e._v(" "),n("p",[e._v("After sending a GOAWAY frame, the sender can discard frames for\nstreams initiated by the receiver with identifiers higher than the\nidentified last stream.  However, any frames that alter connection\nstate cannot be completely ignored.  For instance, HEADERS,\nPUSH_PROMISE, and CONTINUATION frames MUST be minimally processed to\nensure the state maintained for header compression is consistent (see\nSection 4.3); similarly, DATA frames MUST be counted toward the\nconnection flow-control window.  Failure to process these frames can\ncause flow control or header compression state to become\nunsynchronized.")]),e._v(" "),n("p",[e._v("The GOAWAY frame also contains a 32-bit error code (Section 7) that\ncontains the reason for closing the connection.")]),e._v(" "),n("p",[e._v("Endpoints MAY append opaque data to the payload of any GOAWAY frame.\nAdditional debug data is intended for diagnostic purposes only and\ncarries no semantic value.  Debug information could contain security-\nor privacy-sensitive data.  Logged or otherwise persistently stored\ndebug data MUST have adequate safeguards to prevent unauthorized\naccess.")])])])]),e._v(" "),n("h3",{attrs:{id:"_6-9-window-update"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-window-update"}},[e._v("#")]),e._v(" 6.9 WINDOW_UPDATE")]),e._v(" "),n("p",[e._v("WINDOW_UPDATE帧（类型= 0x8）用于实现流控制;有关概述，请参见5.2节。")]),e._v(" "),n("p",[e._v("流控制在两个级别上运行：在每个单独的流和整个连接上。")]),e._v(" "),n("p",[e._v("两种流控制类型都是逐跳的，即，仅在两个端点之间。中介程序不会在依赖的连接之间转发WINDOW_UPDATE帧。但是，任何接收者进行的数据传输节制都会间接导致流控制信息向原始发送者传播。")]),e._v(" "),n("p",[e._v("流控制仅适用于被标识为受流控制的帧。在本文档中定义的帧类型中，这仅包括DATA帧。除非接收者无法分配资源来处理帧，否则必须接受和处理免于流控制的帧。如果接收器无法接受帧，则可能会以FLOW_CONTROL_ERROR类型的流错误（第5.4.2节）或连接错误（第5.4.1节）进行响应。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +-+-------------------------------------------------------------+\n    |R|              Window Size Increment (31)                     |\n    +-+-------------------------------------------------------------+\n\n                  Figure 14: WINDOW_UPDATE Payload Format\n")])])]),n("p",[e._v("WINDOW_UPDATE帧的有效载荷是一个保留位加上一个无符号的31位整数，指示发送者的八位字节数除了现有的流控制窗口外，还可以传输。流控制窗口增量的合法范围是1到2^31-1（2,147,483,647）个八位位组。")]),e._v(" "),n("p",[e._v("WINDOW_UPDATE框架未定义任何标志。")]),e._v(" "),n("p",[e._v("WINDOW_UPDATE帧可以特定于流或整个连接。在前一种情况下，帧的流标识符指示受影响的流；在后者中，值“ 0”指示整个连接是框架的主题。接收方必须将收到的WINDOW_UPDATE帧（其流控制窗口的增量为0）视为PROTOCOL_ERROR类型的流错误（见第5.4.2节）；连接流控制窗口上的错误必须视为连接错误（第5.4.1节）。")]),e._v(" "),n("p",[e._v("对等方可以发送WINDOW_UPDATE，该对等方已发送带有END_STREAM标志的帧。这意味着接收方可以在“半闭路（远程）”或“闭路”流上接收WINDOW_UPDATE帧。接收方不得将此视为错误（请参阅第5.1节）。")]),e._v(" "),n("p",[e._v("接收到流控制帧的接收者必须始终对连接流控制窗口做出贡献，除非接收者将其视为连接错误（第5.4.1节）。即使帧出错，这也是必要的。发送方将帧计数到流控制窗口，但是如果接收方没有，则发送方和接收方的流控制窗口可能会不同。")]),e._v(" "),n("p",[e._v("必须将长度不是4个八位位组的WINDOW_UPDATE帧视为类型为FRAME_SIZE_ERROR的连接错误（第5.4.1节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.9.  WINDOW_UPDATE")]),e._v("\n"),n("p",[e._v("The WINDOW_UPDATE frame (type=0x8) is used to implement flow control;\nsee Section 5.2 for an overview.")]),e._v("\n"),n("p",[e._v("Flow control operates at two levels: on each individual stream and on\nthe entire connection.")]),e._v("\n"),n("p",[e._v("Both types of flow control are hop by hop, that is, only between the\ntwo endpoints.  Intermediaries do not forward WINDOW_UPDATE frames\nbetween dependent connections.  However, throttling of data transfer\nby any receiver can indirectly cause the propagation of flow-control\ninformation toward the original sender.")]),e._v("\n"),n("p",[e._v("Flow control only applies to frames that are identified as being\nsubject to flow control.  Of the frame types defined in this\ndocument, this includes only DATA frames.  Frames that are exempt\nfrom flow control MUST be accepted and processed, unless the receiver\nis unable to assign resources to handling the frame.  A receiver MAY\nrespond with a stream error (Section 5.4.2) or connection error\n(Section 5.4.1) of type FLOW_CONTROL_ERROR if it is unable to accept\na frame.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+-+-------------------------------------------------------------+\n|R|              Window Size Increment (31)                     |\n+-+-------------------------------------------------------------+\n\n              Figure 14: WINDOW_UPDATE Payload Format\n")])])]),n("p",[e._v("The payload of a WINDOW_UPDATE frame is one reserved bit plus an\nunsigned 31-bit integer indicating the number of octets that the\nsender can transmit in addition to the existing flow-control window.\nThe legal range for the increment to the flow-control window is 1 to\n2^31-1 (2,147,483,647) octets.")]),e._v(" "),n("p",[e._v("The WINDOW_UPDATE frame does not define any flags.")]),e._v(" "),n("p",[e._v('The WINDOW_UPDATE frame can be specific to a stream or to the entire\nconnection.  In the former case, the frame\'s stream identifier\nindicates the affected stream; in the latter, the value "0" indicates\nthat the entire connection is the subject of the frame.')]),e._v(" "),n("p",[e._v("A receiver MUST treat the receipt of a WINDOW_UPDATE frame with an\nflow-control window increment of 0 as a stream error (Section 5.4.2)\nof type PROTOCOL_ERROR; errors on the connection flow-control window\nMUST be treated as a connection error (Section 5.4.1).")]),e._v(" "),n("p",[e._v('WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the\nEND_STREAM flag.  This means that a receiver could receive a\nWINDOW_UPDATE frame on a "half-closed (remote)" or "closed" stream.\nA receiver MUST NOT treat this as an error (see Section 5.1).')]),e._v(" "),n("p",[e._v("A receiver that receives a flow-controlled frame MUST always account\nfor its contribution against the connection flow-control window,\nunless the receiver treats this as a connection error\n(Section 5.4.1).  This is necessary even if the frame is in error.\nThe sender counts the frame toward the flow-control window, but if\nthe receiver does not, the flow-control window at the sender and\nreceiver can become different.")]),e._v(" "),n("p",[e._v("A WINDOW_UPDATE frame with a length other than 4 octets MUST be\ntreated as a connection error (Section 5.4.1) of type\nFRAME_SIZE_ERROR.")])])])]),e._v(" "),n("h4",{attrs:{id:"_6-9-1-flow-control-window"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-1-flow-control-window"}},[e._v("#")]),e._v(" 6.9.1 Flow-Control Window")]),e._v(" "),n("p",[e._v("HTTP/2中的流控制是使用每个发送者在每个流上保留的窗口来实现的。流量控制窗口是一个简单的整数值，指示允许发送方传输多少个八位位组的数据；因此，它的大小可以衡量接收器的缓冲能力。")]),e._v(" "),n("p",[e._v("两个流控制窗口都适用：流流控制窗口和连接流控制窗口。发送方不得发送长度超过接收方通告的任何一个流控制窗口中可用空间的流控制帧。如果两个流控制窗口中都没有可用空间，则可以发送设置了END_STREAM标志的长度为零的帧（即空的DATA帧）。")]),e._v(" "),n("p",[e._v("对于流控制计算，不计9个字节的帧头。")]),e._v(" "),n("p",[e._v("流控制的帧，发送方通过传输的帧的长度减少两个窗口中的可用空间。")]),e._v(" "),n("p",[e._v("帧的接收方发送WINDOW_UPDATE帧，因为它消耗数据并释放流控制窗口中的空间。为流和连接级别的流控制窗口发送单独的WINDOW_UPDATE帧。")]),e._v(" "),n("p",[e._v("接收WINDOW_UPDATE帧的发送者以帧中指定的数量更新相应的窗口。")]),e._v(" "),n("p",[e._v("发送者务必不允许流控制窗口超过2^31-1个八位位组。如果发送方收到WINDOW_UPDATE导致流量控制窗口超过此最大值，则发送方必须视情况终止流或连接。对于流，发送方以错误代码FLOW_CONTROL_ERROR发送RST_STREAM；对于连接，将发送一个错误代码为FLOW_CONTROL_ERROR的GOAWAY帧。")]),e._v(" "),n("p",[e._v("来自发送方的流控制帧和来自接收方的WINDOW_UPDATE帧彼此完全异步。此属性允许接收方积极地将发送方保留的窗口大小更新为防止溪流停滞。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.9.1.  The Flow-Control Window")]),e._v("\n"),n("p",[e._v("Flow control in HTTP/2 is implemented using a window kept by each\nsender on every stream.  The flow-control window is a simple integer\nvalue that indicates how many octets of data the sender is permitted\nto transmit; as such, its size is a measure of the buffering capacity\nof the receiver.")]),e._v("\n"),n("p",[e._v("Two flow-control windows are applicable: the stream flow-control\nwindow and the connection flow-control window.  The sender MUST NOT\nsend a flow-controlled frame with a length that exceeds the space\navailable in either of the flow-control windows advertised by the\nreceiver.  Frames with zero length with the END_STREAM flag set (that\nis, an empty DATA frame) MAY be sent if there is no available space\nin either flow-control window.")]),e._v("\n"),n("p",[e._v("For flow-control calculations, the 9-octet frame header is not\ncounted.")]),e._v("\n"),n("p",[e._v("After sending a flow-controlled frame, the sender reduces the space\navailable in both windows by the length of the transmitted frame.")]),e._v("\n"),n("p",[e._v("The receiver of a frame sends a WINDOW_UPDATE frame as it consumes\ndata and frees up space in flow-control windows.  Separate\nWINDOW_UPDATE frames are sent for the stream- and connection-level\nflow-control windows.")]),e._v("\n"),n("p",[e._v("A sender that receives a WINDOW_UPDATE frame updates the\ncorresponding window by the amount specified in the frame.")]),e._v("\n"),n("p",[e._v("A sender MUST NOT allow a flow-control window to exceed 2^31-1\noctets.  If a sender receives a WINDOW_UPDATE that causes a flow-\ncontrol window to exceed this maximum, it MUST terminate either the\nstream or the connection, as appropriate.  For streams, the sender\nsends a RST_STREAM with an error code of FLOW_CONTROL_ERROR; for the\nconnection, a GOAWAY frame with an error code of FLOW_CONTROL_ERROR\nis sent.")]),e._v("\n"),n("p",[e._v("Flow-controlled frames from the sender and WINDOW_UPDATE frames from\nthe receiver are completely asynchronous with respect to each other.\nThis property allows a receiver to aggressively update the window\nsize kept by the sender to prevent streams from stalling.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_6-9-2-初始流控制窗口大小"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-2-初始流控制窗口大小"}},[e._v("#")]),e._v(" 6.9.2 初始流控制窗口大小")]),e._v(" "),n("p",[e._v("首次建立HTTP/2连接时，将创建初始流控制窗口大小为65,535个八位位组的新流。连接流控制窗口也为65,535个八位位组。两个端点都可以通过在构成连接前言一部分的SETTINGS帧中包含SETTINGS_INITIAL_WINDOW_SIZE的值来调整新流的初始窗口大小。只能使用WINDOW_UPDATE帧来更改连接流控制窗口。")]),e._v(" "),n("p",[e._v("在接收设置为SETTINGS_INITIAL_WINDOW_SIZE设置值的SETTINGS帧之前，端点在发送流控制的框架时只能使用默认的初始窗口大小。同样，将连接流控制窗口设置为默认的初始窗口大小，直到接收到WINDOW_UPDATE帧为止。")]),e._v(" "),n("p",[e._v("除了更改尚未激活的流的流控制窗口外，SETTINGS帧还可以更改以下各项的初始流控制窗口大小：具有活动流控制窗口的流（即处于“打开”或“半关闭（远程）”状态的流）。当SETTINGS_INITIAL_WINDOW_SIZE的值更改时，接收方必须通过新值和旧值之间的差异来调整其所维护的所有流流控制窗口的大小。")]),e._v(" "),n("p",[e._v("对SETTINGS_INITIAL_WINDOW_SIZE的更改可能导致流控制窗口中的可用空间变为负数。发送方必须跟踪否定的流控制窗口，并且在接收到导致流控制窗口变为正数的WINDOW_UPDATE帧之前，不得发送新的流控制帧。")]),e._v(" "),n("p",[e._v("例如，如果客户端在连接建立后立即发送60 KB，并且服务器设置了初始窗口大小为16KB，客户端将在收到SETTINGS帧后将可用的流控制窗口重新计算为-44 KB。在WINDOW_UPDATE帧将窗口恢复为正值之前，客户端将保留负的流控制窗口，此后客户端可以继续发送。")]),e._v(" "),n("p",[e._v("SETTINGS帧不能更改连接流控制窗口。")]),e._v(" "),n("p",[e._v("端点必须处理对SETTINGS_INITIAL_WINDOW_SIZE的更改，这会导致任何流控制窗口超过最大大小，这是类型为FLOW_CONTROL_ERROR的连接错误（第5.4.1节）。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.9.2.  Initial Flow-Control Window Size")]),e._v("\n"),n("p",[e._v("When an HTTP/2 connection is first established, new streams are\ncreated with an initial flow-control window size of 65,535 octets.\nThe connection flow-control window is also 65,535 octets.  Both\nendpoints can adjust the initial window size for new streams by\nincluding a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS\nframe that forms part of the connection preface.  The connection\nflow-control window can only be changed using WINDOW_UPDATE frames.")]),e._v("\n"),n("p",[e._v("Prior to receiving a SETTINGS frame that sets a value for\nSETTINGS_INITIAL_WINDOW_SIZE, an endpoint can only use the default\ninitial window size when sending flow-controlled frames.  Similarly,\nthe connection flow-control window is set to the default initial\nwindow size until a WINDOW_UPDATE frame is received.")]),e._v("\n"),n("p",[e._v('In addition to changing the flow-control window for streams that are\nnot yet active, a SETTINGS frame can alter the initial flow-control\nwindow size for streams with active flow-control windows (that is,\nstreams in the "open" or "half-closed (remote)" state).  When the\nvalue of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust\nthe size of all stream flow-control windows that it maintains by the\ndifference between the new value and the old value.')]),e._v("\n"),n("p",[e._v("A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available\nspace in a flow-control window to become negative.  A sender MUST\ntrack the negative flow-control window and MUST NOT send new flow-\ncontrolled frames until it receives WINDOW_UPDATE frames that cause\nthe flow-control window to become positive.")]),e._v("\n"),n("p",[e._v("For example, if the client sends 60 KB immediately on connection\nestablishment and the server sets the initial window size to be 16\nKB, the client will recalculate the available flow-control window to\nbe -44 KB on receipt of the SETTINGS frame.  The client retains a\nnegative flow-control window until WINDOW_UPDATE frames restore the\nwindow to being positive, after which the client can resume sending.")]),e._v("\n"),n("p",[e._v("A SETTINGS frame cannot alter the connection flow-control window.")]),e._v("\n"),n("p",[e._v("An endpoint MUST treat a change to SETTINGS_INITIAL_WINDOW_SIZE that\ncauses any flow-control window to exceed the maximum size as a\nconnection error (Section 5.4.1) of type FLOW_CONTROL_ERROR.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h4",{attrs:{id:"_6-9-3-减小流窗口大小"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-3-减小流窗口大小"}},[e._v("#")]),e._v(" 6.9.3 减小流窗口大小")]),e._v(" "),n("p",[e._v("希望使用比当前大小小的流控制窗口的接收器可以发送新的SETTINGS帧。但是，接收者必须准备好接收超过该窗口大小的数据，因为发送者可能在处理SETTINGS帧之前发送了超出下限的数据。")]),e._v(" "),n("p",[e._v("发送设置帧以减小初始流控制窗口大小之后，接收者可以继续超过流量控制限制的处理流。允许流继续运行不会使接收方立即减少其为流控制窗口保留的空间。这些流上的进度也可能会停止，因为需要WINDOW_UPDATE帧来允许发送方继续发送。接收者可以向受影响的流发送RST_STREAM，错误代码为FLOW_CONTROL_ERROR。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.9.3.  Reducing the Stream Window Size")]),e._v("\n"),n("p",[e._v("A receiver that wishes to use a smaller flow-control window than the\ncurrent size can send a new SETTINGS frame.  However, the receiver\nMUST be prepared to receive data that exceeds this window size, since\nthe sender might send data that exceeds the lower limit prior to\nprocessing the SETTINGS frame.")]),e._v("\n"),n("p",[e._v("After sending a SETTINGS frame that reduces the initial flow-control\nwindow size, a receiver MAY continue to process streams that exceed\nflow-control limits.  Allowing streams to continue does not allow the\nreceiver to immediately reduce the space it reserves for flow-control\nwindows.  Progress on these streams can also stall, since\nWINDOW_UPDATE frames are needed to allow the sender to resume\nsending.  The receiver MAY instead send a RST_STREAM with an error\ncode of FLOW_CONTROL_ERROR for the affected streams.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("h3",{attrs:{id:"_6-10-continuation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-10-continuation"}},[e._v("#")]),e._v(" 6.10 CONTINUATION")]),e._v(" "),n("p",[e._v("CONTINUATION帧（类型=0x9）用于继续一系列标题块片段（第4.3节）。只要前一帧在同一流上并且是没有设置END_HEADERS标志的HEADERS，PUSH_PROMISE或CONTINUATION帧，就可以发送任意数量的CONTINUATION帧。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    +---------------------------------------------------------------+\n    |                   Header Block Fragment (*)                 ...\n    +---------------------------------------------------------------+\n\n                   Figure 15: CONTINUATION Frame Payload\n")])])]),n("p",[e._v("CONTINUATION帧有效载荷包含一个头块片段（第4.3节）。")]),e._v(" "),n("p",[e._v("CONTINUATION帧定义了以下标志：")]),e._v(" "),n("ul",[n("li",[e._v("END_HEADERS（0x4）：置位时，位2指示该帧结束在前面的块（第4.3节）。\n如果未设置END_HEADERS位，则此帧后必须跟另一个CONTINUATION帧。接收方必须将接收到的任何其他类型的帧或不同流上的帧视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。")])]),e._v(" "),n("p",[e._v("CONTINUATION帧会按照第4.3节中的定义更改连接状态。")]),e._v(" "),n("p",[e._v("CONTINUATION帧必须与流关联。如果接收到流标识符字段为0x0的CONTINUATION帧，则接收者务必以PROTOCOL_ERROR类型的连接错误（第5.4.1节）")]),e._v(" "),n("p",[e._v("没有设置END_HEADERS标志的HEADERS，PUSH_PROMISE或CONTINUATION帧必须在CONTINUATION帧之前。观察到违反此规则的收件人必须以PROTOCOL_ERROR类型的连接错误（第5.4.1节）进行响应。")]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("6.10.  CONTINUATION")]),e._v("\n"),n("p",[e._v("The CONTINUATION frame (type=0x9) is used to continue a sequence of\nheader block fragments (Section 4.3).  Any number of CONTINUATION\nframes can be sent, as long as the preceding frame is on the same\nstream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without\nthe END_HEADERS flag set.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("+---------------------------------------------------------------+\n|                   Header Block Fragment (*)                 ...\n+---------------------------------------------------------------+\n\n               Figure 15: CONTINUATION Frame Payload\n")])])]),n("p",[e._v("The CONTINUATION frame payload contains a header block fragment\n(Section 4.3).")]),e._v(" "),n("p",[e._v("The CONTINUATION frame defines the following flag:")]),e._v(" "),n("p",[e._v("END_HEADERS (0x4):  When set, bit 2 indicates that this frame ends a\nheader block (Section 4.3).")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  If the END_HEADERS bit is not set, this frame MUST be followed by\n  another CONTINUATION frame.  A receiver MUST treat the receipt of\n  any other type of frame or a frame on a different stream as a\n  connection error (Section 5.4.1) of type PROTOCOL_ERROR.\n")])])]),n("p",[e._v("The CONTINUATION frame changes the connection state as defined in\nSection 4.3.")]),e._v(" "),n("p",[e._v("CONTINUATION frames MUST be associated with a stream.  If a\nCONTINUATION frame is received whose stream identifier field is 0x0,\nthe recipient MUST respond with a connection error (Section 5.4.1) of\ntype PROTOCOL_ERROR.")]),e._v(" "),n("p",[e._v("A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or\nCONTINUATION frame without the END_HEADERS flag set.  A recipient\nthat observes violation of this rule MUST respond with a connection\nerror (Section 5.4.1) of type PROTOCOL_ERROR.")])])])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"7"}},[e._v("\n"),n("li",[e._v("Error Codes")]),e._v("\n")]),e._v("\n"),n("p",[e._v("Error codes are 32-bit fields that are used in RST_STREAM and GOAWAY\nframes to convey the reasons for the stream or connection error.")]),e._v("\n"),n("p",[e._v("Error codes share a common code space.  Some error codes apply only\nto either streams or the entire connection and have no defined\nsemantics in the other context.")]),e._v("\n"),n("p",[e._v("The following error codes are defined:")]),e._v("\n"),n("p",[e._v("NO_ERROR (0x0):  The associated condition is not a result of an\nerror.  For example, a GOAWAY might include this code to indicate\ngraceful shutdown of a connection.")]),e._v("\n"),n("p",[e._v("PROTOCOL_ERROR (0x1):  The endpoint detected an unspecific protocol\nerror.  This error is for use when a more specific error code is\nnot available.")]),e._v("\n"),n("p",[e._v("INTERNAL_ERROR (0x2):  The endpoint encountered an unexpected\ninternal error.")]),e._v("\n"),n("p",[e._v("FLOW_CONTROL_ERROR (0x3):  The endpoint detected that its peer\nviolated the flow-control protocol.")]),e._v("\n"),n("p",[e._v('SETTINGS_TIMEOUT (0x4):  The endpoint sent a SETTINGS frame but did\nnot receive a response in a timely manner.  See Section 6.5.3\n("Settings Synchronization").')]),e._v("\n"),n("p",[e._v("STREAM_CLOSED (0x5):  The endpoint received a frame after a stream\nwas half-closed.")]),e._v("\n"),n("p",[e._v("FRAME_SIZE_ERROR (0x6):  The endpoint received a frame with an\ninvalid size.")]),e._v("\n"),n("p",[e._v("REFUSED_STREAM (0x7):  The endpoint refused the stream prior to\nperforming any application processing (see Section 8.1.4 for\ndetails).")]),e._v("\n"),n("p",[e._v("CANCEL (0x8):  Used by the endpoint to indicate that the stream is no\nlonger needed.")]),e._v("\n"),n("p",[e._v("COMPRESSION_ERROR (0x9):  The endpoint is unable to maintain the\nheader compression context for the connection.")]),e._v("\n"),n("p",[e._v("CONNECT_ERROR (0xa):  The connection established in response to a\nCONNECT request (Section 8.3) was reset or abnormally closed.")]),e._v("\n"),n("p",[e._v("ENHANCE_YOUR_CALM (0xb):  The endpoint detected that its peer is\nexhibiting a behavior that might be generating excessive load.")]),e._v("\n"),n("p",[e._v("INADEQUATE_SECURITY (0xc):  The underlying transport has properties\nthat do not meet minimum security requirements (see Section 9.2).")]),e._v("\n"),n("p",[e._v("HTTP_1_1_REQUIRED (0xd):  The endpoint requires that HTTP/1.1 be used\ninstead of HTTP/2.")]),e._v("\n"),n("p",[e._v("Unknown or unsupported error codes MUST NOT trigger any special\nbehavior.  These MAY be treated by an implementation as being\nequivalent to INTERNAL_ERROR.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"8"}},[e._v("\n"),n("li",[e._v("HTTP Message Exchanges")]),e._v("\n")]),e._v("\n"),n("p",[e._v("HTTP/2 is intended to be as compatible as possible with current uses\nof HTTP.  This means that, from the application perspective, the\nfeatures of the protocol are largely unchanged.  To achieve this, all\nrequest and response semantics are preserved, although the syntax of\nconveying those semantics has changed.")]),e._v("\n"),n("p",[e._v("Thus, the specification and requirements of HTTP/1.1 Semantics and\nContent [RFC7231], Conditional Requests [RFC7232], Range Requests\n[RFC7233], Caching [RFC7234], and Authentication [RFC7235] are\napplicable to HTTP/2.  Selected portions of HTTP/1.1 Message Syntax\nand Routing [RFC7230], such as the HTTP and HTTPS URI schemes, are\nalso applicable in HTTP/2, but the expression of those semantics for\nthis protocol are defined in the sections below.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.  HTTP Request/Response Exchange")]),e._v("\n"),n("p",[e._v("A client sends an HTTP request on a new stream, using a previously\nunused stream identifier (Section 5.1.1).  A server sends an HTTP\nresponse on the same stream as the request.")]),e._v("\n"),n("p",[e._v("An HTTP message (request or response) consists of:")]),e._v("\n"),n("ol",[e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("for a response only, zero or more HEADERS frames (each followed\nby zero or more CONTINUATION frames) containing the message\nheaders of informational (1xx) HTTP responses (see [RFC7230],\nSection 3.2 and [RFC7231], Section 6.2),")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("one HEADERS frame (followed by zero or more CONTINUATION frames)\ncontaining the message headers (see [RFC7230], Section 3.2),")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("zero or more DATA frames containing the payload body (see\n[RFC7230], Section 3.3), and")]),e._v("\n")]),e._v("\n"),n("li",[e._v("\n"),n("p",[e._v("optionally, one HEADERS frame, followed by zero or more\nCONTINUATION frames containing the trailer-part, if present (see\n[RFC7230], Section 4.1.2).")]),e._v("\n")]),e._v("\n")]),e._v("\n"),n("p",[e._v("The last frame in the sequence bears an END_STREAM flag, noting that\na HEADERS frame bearing the END_STREAM flag can be followed by\nCONTINUATION frames that carry any remaining portions of the header\nblock.")]),e._v("\n"),n("p",[e._v("Other frames (from any stream) MUST NOT occur between the HEADERS\nframe and any CONTINUATION frames that might follow.")]),e._v("\n"),n("p",[e._v('HTTP/2 uses DATA frames to carry message payloads.  The "chunked"\ntransfer encoding defined in Section 4.1 of [RFC7230] MUST NOT be\nused in HTTP/2.')]),e._v("\n"),n("p",[e._v("Trailing header fields are carried in a header block that also\nterminates the stream.  Such a header block is a sequence starting\nwith a HEADERS frame, followed by zero or more CONTINUATION frames,\nwhere the HEADERS frame bears an END_STREAM flag.  Header blocks\nafter the first that do not terminate the stream are not part of an\nHTTP request or response.")]),e._v("\n"),n("p",[e._v("A HEADERS frame (and associated CONTINUATION frames) can only appear\nat the start or end of a stream.  An endpoint that receives a HEADERS\nframe without the END_STREAM flag set after receiving a final (non-\ninformational) status code MUST treat the corresponding request or\nresponse as malformed (Section 8.1.2.6).")]),e._v("\n"),n("p",[e._v('An HTTP request/response exchange fully consumes a single stream.  A\nrequest starts with the HEADERS frame that puts the stream into an\n"open" state.  The request ends with a frame bearing END_STREAM,\nwhich causes the stream to become "half-closed (local)" for the\nclient and "half-closed (remote)" for the server.  A response starts\nwith a HEADERS frame and ends with a frame bearing END_STREAM, which\nplaces the stream in the "closed" state.')]),e._v("\n"),n("p",[e._v("An HTTP response is complete after the server sends -- or the client\nreceives -- a frame with the END_STREAM flag set (including any\nCONTINUATION frames needed to complete a header block).  A server can\nsend a complete response prior to the client sending an entire\nrequest if the response does not depend on any portion of the request\nthat has not been sent and received.  When this is true, a server MAY\nrequest that the client abort transmission of a request without error\nby sending a RST_STREAM with an error code of NO_ERROR after sending\na complete response (i.e., a frame with the END_STREAM flag).\nClients MUST NOT discard responses as a result of receiving such a\nRST_STREAM, though clients can always discard responses at their\ndiscretion for other reasons.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.1.  Upgrading from HTTP/2")]),e._v("\n"),n("p",[e._v("HTTP/2 removes support for the 101 (Switching Protocols)\ninformational status code ([RFC7231], Section 6.2.2).")]),e._v("\n"),n("p",[e._v("The semantics of 101 (Switching Protocols) aren't applicable to a\nmultiplexed protocol.  Alternative protocols are able to use the same\nmechanisms that HTTP/2 uses to negotiate their use (see Section 3).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.2.  HTTP Header Fields")]),e._v("\n"),n("p",[e._v('HTTP header fields carry information as a series of key-value pairs.\nFor a listing of registered HTTP headers, see the "Message Header\nField" registry maintained at <https://www.iana.org/assignments/\nmessage-headers>.')]),e._v("\n"),n("p",[e._v("Just as in HTTP/1.x, header field names are strings of ASCII\ncharacters that are compared in a case-insensitive fashion.  However,\nheader field names MUST be converted to lowercase prior to their\nencoding in HTTP/2.  A request or response containing uppercase\nheader field names MUST be treated as malformed (Section 8.1.2.6).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.2.1.  Pseudo-Header Fields")]),e._v("\n"),n("p",[e._v("While HTTP/1.x used the message start-line (see [RFC7230],\nSection 3.1) to convey the target URI, the method of the request, and\nthe status code for the response, HTTP/2 uses special pseudo-header\nfields beginning with ':' character (ASCII 0x3a) for this purpose.")]),e._v("\n"),n("p",[e._v("Pseudo-header fields are not HTTP header fields.  Endpoints MUST NOT\ngenerate pseudo-header fields other than those defined in this\ndocument.")]),e._v("\n"),n("p",[e._v("Pseudo-header fields are only valid in the context in which they are\ndefined.  Pseudo-header fields defined for requests MUST NOT appear\nin responses; pseudo-header fields defined for responses MUST NOT\nappear in requests.  Pseudo-header fields MUST NOT appear in\ntrailers.  Endpoints MUST treat a request or response that contains\nundefined or invalid pseudo-header fields as malformed\n(Section 8.1.2.6).")]),e._v("\n"),n("p",[e._v("All pseudo-header fields MUST appear in the header block before\nregular header fields.  Any request or response that contains a\npseudo-header field that appears in a header block after a regular\nheader field MUST be treated as malformed (Section 8.1.2.6).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.2.2.  Connection-Specific Header Fields")]),e._v("\n"),n("p",[e._v("HTTP/2 does not use the Connection header field to indicate\nconnection-specific header fields; in this protocol, connection-\nspecific metadata is conveyed by other means.  An endpoint MUST NOT\ngenerate an HTTP/2 message containing connection-specific header\nfields; any message containing connection-specific header fields MUST\nbe treated as malformed (Section 8.1.2.6).")]),e._v("\n"),n("p",[e._v('The only exception to this is the TE header field, which MAY be\npresent in an HTTP/2 request; when it is, it MUST NOT contain any\nvalue other than "trailers".')]),e._v("\n"),n("p",[e._v("This means that an intermediary transforming an HTTP/1.x message to\nHTTP/2 will need to remove any header fields nominated by the\nConnection header field, along with the Connection header field\nitself.  Such intermediaries SHOULD also remove other connection-\nspecific header fields, such as Keep-Alive, Proxy-Connection,\nTransfer-Encoding, and Upgrade, even if they are not nominated by the\nConnection header field.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  Note: HTTP/2 purposefully does not support upgrade to another\n  protocol.  The handshake methods described in Section 3 are\n  believed sufficient to negotiate the use of alternative protocols.\n")])])])])])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.2.3.  Request Pseudo-Header Fields")]),e._v("\n"),n("p",[e._v("The following pseudo-header fields are defined for HTTP/2 requests:")]),e._v("\n"),n("p",[e._v('o  The ":method" pseudo-header field includes the HTTP method\n([RFC7231], Section 4).')]),e._v("\n"),n("p",[e._v('o  The ":scheme" pseudo-header field includes the scheme portion of\nthe target URI ([RFC3986], Section 3.1).')]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('  ":scheme" is not restricted to "http" and "https" schemed URIs.  A\n  proxy or gateway can translate requests for non-HTTP schemes,\n  enabling the use of HTTP to interact with non-HTTP services.\n')])])]),n("p",[e._v('o  The ":authority" pseudo-header field includes the authority\nportion of the target URI ([RFC3986], Section 3.2).  The authority\nMUST NOT include the deprecated "userinfo" subcomponent for "http"\nor "https" schemed URIs.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('  To ensure that the HTTP/1.1 request line can be reproduced\n  accurately, this pseudo-header field MUST be omitted when\n  translating from an HTTP/1.1 request that has a request target in\n  origin or asterisk form (see [RFC7230], Section 5.3).  Clients\n  that generate HTTP/2 requests directly SHOULD use the ":authority"\n  pseudo-header field instead of the Host header field.  An\n  intermediary that converts an HTTP/2 request to HTTP/1.1 MUST\n  create a Host header field if one is not present in a request by\n  copying the value of the ":authority" pseudo-header field.\n')])])]),n("p",[e._v('o  The ":path" pseudo-header field includes the path and query parts\nof the target URI (the "path-absolute" production and optionally a\n\'?\' character followed by the "query" production (see Sections 3.3\nand 3.4 of [RFC3986]).  A request in asterisk form includes the\nvalue \'*\' for the ":path" pseudo-header field.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('  This pseudo-header field MUST NOT be empty for "http" or "https"\n  URIs; "http" or "https" URIs that do not contain a path component\n  MUST include a value of \'/\'.  The exception to this rule is an\n  OPTIONS request for an "http" or "https" URI that does not include\n  a path component; these MUST include a ":path" pseudo-header field\n  with a value of \'*\' (see [RFC7230], Section 5.3.4).\n')])])]),n("p",[e._v('All HTTP/2 requests MUST include exactly one valid value for the\n":method", ":scheme", and ":path" pseudo-header fields, unless it is\na CONNECT request (Section 8.3).  An HTTP request that omits\nmandatory pseudo-header fields is malformed (Section 8.1.2.6).')]),e._v(" "),n("p",[e._v("HTTP/2 does not define a way to carry the version identifier that is\nincluded in the HTTP/1.1 request line.")])])])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.2.4.  Response Pseudo-Header Fields")]),e._v("\n"),n("p",[e._v('For HTTP/2 responses, a single ":status" pseudo-header field is\ndefined that carries the HTTP status code field (see [RFC7231],\nSection 6).  This pseudo-header field MUST be included in all\nresponses; otherwise, the response is malformed (Section 8.1.2.6).')]),e._v("\n"),n("p",[e._v("HTTP/2 does not define a way to carry the version or reason phrase\nthat is included in an HTTP/1.1 status line.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.2.5.  Compressing the Cookie Header Field")]),e._v("\n"),n("p",[e._v('The Cookie header field [COOKIE] uses a semi-colon (";") to delimit\ncookie-pairs (or "crumbs").  This header field doesn\'t follow the\nlist construction rules in HTTP (see [RFC7230], Section 3.2.2), which\nprevents cookie-pairs from being separated into different name-value\npairs.  This can significantly reduce compression efficiency as\nindividual cookie-pairs are updated.')]),e._v("\n"),n("p",[e._v('To allow for better compression efficiency, the Cookie header field\nMAY be split into separate header fields, each with one or more\ncookie-pairs.  If there are multiple Cookie header fields after\ndecompression, these MUST be concatenated into a single octet string\nusing the two-octet delimiter of 0x3B, 0x20 (the ASCII string "; ")\nbefore being passed into a non-HTTP/2 context, such as an HTTP/1.1\nconnection, or a generic HTTP server application.')]),e._v("\n"),n("p",[e._v("Therefore, the following two lists of Cookie header fields are\nsemantically equivalent.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" cookie: a=b; c=d; e=f\n\n cookie: a=b\n cookie: c=d\n cookie: e=f\n")])])])])])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.2.6.  Malformed Requests and Responses")]),e._v("\n"),n("p",[e._v("A malformed request or response is one that is an otherwise valid\nsequence of HTTP/2 frames but is invalid due to the presence of\nextraneous frames, prohibited header fields, the absence of mandatory\nheader fields, or the inclusion of uppercase header field names.")]),e._v("\n"),n("p",[e._v("A request or response that includes a payload body can include a\ncontent-length header field.  A request or response is also malformed\nif the value of a content-length header field does not equal the sum\nof the DATA frame payload lengths that form the body.  A response\nthat is defined to have no payload, as described in [RFC7230],\nSection 3.3.2, can have a non-zero content-length header field, even\nthough no content is included in DATA frames.")]),e._v("\n"),n("p",[e._v("Intermediaries that process HTTP requests or responses (i.e., any\nintermediary not acting as a tunnel) MUST NOT forward a malformed\nrequest or response.  Malformed requests or responses that are\ndetected MUST be treated as a stream error (Section 5.4.2) of type\nPROTOCOL_ERROR.")]),e._v("\n"),n("p",[e._v("For malformed requests, a server MAY send an HTTP response prior to\nclosing or resetting the stream.  Clients MUST NOT accept a malformed\nresponse.  Note that these requirements are intended to protect\nagainst several types of common attacks against HTTP; they are\ndeliberately strict because being permissive can expose\nimplementations to these vulnerabilities.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.3.  Examples")]),e._v("\n"),n("p",[e._v("This section shows HTTP/1.1 requests and responses, with\nillustrations of equivalent HTTP/2 requests and responses.")]),e._v("\n"),n("p",[e._v("An HTTP GET request includes request header fields and no payload\nbody and is therefore transmitted as a single HEADERS frame, followed\nby zero or more CONTINUATION frames containing the serialized block\nof request header fields.  The HEADERS frame in the following has\nboth the END_HEADERS and END_STREAM flags set; no CONTINUATION frames\nare sent.")]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" GET /resource HTTP/1.1           HEADERS\n Host: example.org          ==>     + END_STREAM\n Accept: image/jpeg                 + END_HEADERS\n                                      :method = GET\n                                      :scheme = https\n                                      :path = /resource\n                                      host = example.org\n                                      accept = image/jpeg\n")])])]),n("p",[e._v("Similarly, a response that includes only response header fields is\ntransmitted as a HEADERS frame (again, followed by zero or more\nCONTINUATION frames) containing the serialized block of response\nheader fields.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(' HTTP/1.1 304 Not Modified        HEADERS\n ETag: "xyzzy"              ==>     + END_STREAM\n Expires: Thu, 23 Jan ...           + END_HEADERS\n                                      :status = 304\n                                      etag = "xyzzy"\n                                      expires = Thu, 23 Jan ...\n')])])]),n("p",[e._v("An HTTP POST request that includes request header fields and payload\ndata is transmitted as one HEADERS frame, followed by zero or more\nCONTINUATION frames containing the request header fields, followed by\none or more DATA frames, with the last CONTINUATION (or HEADERS)\nframe having the END_HEADERS flag set and the final DATA frame having\nthe END_STREAM flag set:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" POST /resource HTTP/1.1          HEADERS\n Host: example.org          ==>     - END_STREAM\n Content-Type: image/jpeg           - END_HEADERS\n Content-Length: 123                  :method = POST\n                                      :path = /resource\n {binary data}                        :scheme = https\n\n                                  CONTINUATION\n                                    + END_HEADERS\n                                      content-type = image/jpeg\n                                      host = example.org\n                                      content-length = 123\n\n                                  DATA\n                                    + END_STREAM\n                                  {binary data}\n")])])]),n("p",[e._v("Note that data contributing to any given header field could be spread\nbetween header block fragments.  The allocation of header fields to\nframes in this example is illustrative only.")]),e._v(" "),n("p",[e._v("A response that includes header fields and payload data is\ntransmitted as a HEADERS frame, followed by zero or more CONTINUATION\nframes, followed by one or more DATA frames, with the last DATA frame\nin the sequence having the END_STREAM flag set:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" HTTP/1.1 200 OK                  HEADERS\n Content-Type: image/jpeg   ==>     - END_STREAM\n Content-Length: 123                + END_HEADERS\n                                      :status = 200\n {binary data}                        content-type = image/jpeg\n                                      content-length = 123\n\n                                  DATA\n                                    + END_STREAM\n                                  {binary data}\n")])])]),n("p",[e._v("An informational response using a 1xx status code other than 101 is\ntransmitted as a HEADERS frame, followed by zero or more CONTINUATION\nframes.")]),e._v(" "),n("p",[e._v("Trailing header fields are sent as a header block after both the\nrequest or response header block and all the DATA frames have been\nsent.  The HEADERS frame starting the trailers header block has the\nEND_STREAM flag set.")]),e._v(" "),n("p",[e._v('The following example includes both a 100 (Continue) status code,\nwhich is sent in response to a request containing a "100-continue"\ntoken in the Expect header field, and trailing header fields:')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" HTTP/1.1 100 Continue            HEADERS\n Extension-Field: bar       ==>     - END_STREAM\n                                    + END_HEADERS\n                                      :status = 100\n                                      extension-field = bar\n\n HTTP/1.1 200 OK                  HEADERS\n Content-Type: image/jpeg   ==>     - END_STREAM\n Transfer-Encoding: chunked         + END_HEADERS\n Trailer: Foo                         :status = 200\n                                      content-length = 123\n 123                                  content-type = image/jpeg\n {binary data}                        trailer = Foo\n 0\n Foo: bar                         DATA\n                                    - END_STREAM\n                                  {binary data}\n\n                                  HEADERS\n                                    + END_STREAM\n                                    + END_HEADERS\n                                      foo = bar\n")])])])])])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.1.4.  Request Reliability Mechanisms in HTTP/2")]),e._v("\n"),n("p",[e._v("In HTTP/1.1, an HTTP client is unable to retry a non-idempotent\nrequest when an error occurs because there is no means to determine\nthe nature of the error.  It is possible that some server processing\noccurred prior to the error, which could result in undesirable\neffects if the request were reattempted.")]),e._v("\n"),n("p",[e._v("HTTP/2 provides two mechanisms for providing a guarantee to a client\nthat a request has not been processed:")]),e._v("\n"),n("p",[e._v("o  The GOAWAY frame indicates the highest stream number that might\nhave been processed.  Requests on streams with higher numbers are\ntherefore guaranteed to be safe to retry.")]),e._v("\n"),n("p",[e._v("o  The REFUSED_STREAM error code can be included in a RST_STREAM\nframe to indicate that the stream is being closed prior to any\nprocessing having occurred.  Any request that was sent on the\nreset stream can be safely retried.")]),e._v("\n"),n("p",[e._v("Requests that have not been processed have not failed; clients MAY\nautomatically retry them, even those with non-idempotent methods.")]),e._v("\n"),n("p",[e._v("A server MUST NOT indicate that a stream has not been processed\nunless it can guarantee that fact.  If frames that are on a stream\nare passed to the application layer for any stream, then\nREFUSED_STREAM MUST NOT be used for that stream, and a GOAWAY frame\nMUST include a stream identifier that is greater than or equal to the\ngiven stream identifier.")]),e._v("\n"),n("p",[e._v("In addition to these mechanisms, the PING frame provides a way for a\nclient to easily test a connection.  Connections that remain idle can\nbecome broken as some middleboxes (for instance, network address\ntranslators or load balancers) silently discard connection bindings.\nThe PING frame allows a client to safely test whether a connection is\nstill active without sending a request.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.2.  Server Push")]),e._v("\n"),n("p",[e._v('HTTP/2 allows a server to pre-emptively send (or "push") responses\n(along with corresponding "promised" requests) to a client in\nassociation with a previous client-initiated request.  This can be\nuseful when the server knows the client will need to have those\nresponses available in order to fully process the response to the\noriginal request.')]),e._v("\n"),n("p",[e._v("A client can request that server push be disabled, though this is\nnegotiated for each hop independently.  The SETTINGS_ENABLE_PUSH\nsetting can be set to 0 to indicate that server push is disabled.")]),e._v("\n"),n("p",[e._v("Promised requests MUST be cacheable (see [RFC7231], Section 4.2.3),\nMUST be safe (see [RFC7231], Section 4.2.1), and MUST NOT include a\nrequest body.  Clients that receive a promised request that is not\ncacheable, that is not known to be safe, or that indicates the\npresence of a request body MUST reset the promised stream with a\nstream error (Section 5.4.2) of type PROTOCOL_ERROR.  Note this could\nresult in the promised stream being reset if the client does not\nrecognize a newly defined method as being safe.")]),e._v("\n"),n("p",[e._v('Pushed responses that are cacheable (see [RFC7234], Section 3) can be\nstored by the client, if it implements an HTTP cache.  Pushed\nresponses are considered successfully validated on the origin server\n(e.g., if the "no-cache" cache response directive is present\n([RFC7234], Section 5.2.2)) while the stream identified by the\npromised stream ID is still open.')]),e._v("\n"),n("p",[e._v("Pushed responses that are not cacheable MUST NOT be stored by any\nHTTP cache.  They MAY be made available to the application\nseparately.")]),e._v("\n"),n("p",[e._v('The server MUST include a value in the ":authority" pseudo-header\nfield for which the server is authoritative (see Section 10.1).  A\nclient MUST treat a PUSH_PROMISE for which the server is not\nauthoritative as a stream error (Section 5.4.2) of type\nPROTOCOL_ERROR.')]),e._v("\n"),n("p",[e._v("An intermediary can receive pushes from the server and choose not to\nforward them on to the client.  In other words, how to make use of\nthe pushed information is up to that intermediary.  Equally, the\nintermediary might choose to make additional pushes to the client,\nwithout any action taken by the server.")]),e._v("\n"),n("p",[e._v("A client cannot push.  Thus, servers MUST treat the receipt of a\nPUSH_PROMISE frame as a connection error (Section 5.4.1) of type\nPROTOCOL_ERROR.  Clients MUST reject any attempt to change the\nSETTINGS_ENABLE_PUSH setting to a value other than 0 by treating the\nmessage as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.2.1.  Push Requests")]),e._v("\n"),n("p",[e._v("Server push is semantically equivalent to a server responding to a\nrequest; however, in this case, that request is also sent by the\nserver, as a PUSH_PROMISE frame.")]),e._v("\n"),n("p",[e._v("The PUSH_PROMISE frame includes a header block that contains a\ncomplete set of request header fields that the server attributes to\nthe request.  It is not possible to push a response to a request that\nincludes a request body.")]),e._v("\n"),n("p",[e._v("Pushed responses are always associated with an explicit request from\nthe client.  The PUSH_PROMISE frames sent by the server are sent on\nthat explicit request's stream.  The PUSH_PROMISE frame also includes\na promised stream identifier, chosen from the stream identifiers\navailable to the server (see Section 5.1.1).")]),e._v("\n"),n("p",[e._v('The header fields in PUSH_PROMISE and any subsequent CONTINUATION\nframes MUST be a valid and complete set of request header fields\n(Section 8.1.2.3).  The server MUST include a method in the ":method"\npseudo-header field that is safe and cacheable.  If a client receives\na PUSH_PROMISE that does not include a complete and valid set of\nheader fields or the ":method" pseudo-header field identifies a\nmethod that is not safe, it MUST respond with a stream error\n(Section 5.4.2) of type PROTOCOL_ERROR.')]),e._v("\n"),n("p",[e._v("The server SHOULD send PUSH_PROMISE (Section 6.6) frames prior to\nsending any frames that reference the promised responses.  This\navoids a race where clients issue requests prior to receiving any\nPUSH_PROMISE frames.")]),e._v("\n"),n("p",[e._v("For example, if the server receives a request for a document\ncontaining embedded links to multiple image files and the server\nchooses to push those additional images to the client, sending\nPUSH_PROMISE frames before the DATA frames that contain the image\nlinks ensures that the client is able to see that a resource will be\npushed before discovering embedded links.  Similarly, if the server\npushes responses referenced by the header block (for instance, in\nLink header fields), sending a PUSH_PROMISE before sending the header\nblock ensures that clients do not request those resources.")]),e._v("\n"),n("p",[e._v("PUSH_PROMISE frames MUST NOT be sent by the client.")]),e._v("\n"),n("p",[e._v('PUSH_PROMISE frames can be sent by the server in response to any\nclient-initiated stream, but the stream MUST be in either the "open"\nor "half-closed (remote)" state with respect to the server.\nPUSH_PROMISE frames are interspersed with the frames that comprise a\nresponse, though they cannot be interspersed with HEADERS and\nCONTINUATION frames that comprise a single header block.')]),e._v("\n"),n("p",[e._v('Sending a PUSH_PROMISE frame creates a new stream and puts the stream\ninto the "reserved (local)" state for the server and the "reserved\n(remote)" state for the client.')]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.2.2.  Push Responses")]),e._v("\n"),n("p",[e._v('After sending the PUSH_PROMISE frame, the server can begin delivering\nthe pushed response as a response (Section 8.1.2.4) on a server-\ninitiated stream that uses the promised stream identifier.  The\nserver uses this stream to transmit an HTTP response, using the same\nsequence of frames as defined in Section 8.1.  This stream becomes\n"half-closed" to the client (Section 5.1) after the initial HEADERS\nframe is sent.')]),e._v("\n"),n("p",[e._v("Once a client receives a PUSH_PROMISE frame and chooses to accept the\npushed response, the client SHOULD NOT issue any requests for the\npromised response until after the promised stream has closed.")]),e._v("\n"),n("p",[e._v("If the client determines, for any reason, that it does not wish to\nreceive the pushed response from the server or if the server takes\ntoo long to begin sending the promised response, the client can send\na RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code\nand referencing the pushed stream's identifier.")]),e._v("\n"),n("p",[e._v("A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit\nthe number of responses that can be concurrently pushed by a server.\nAdvertising a SETTINGS_MAX_CONCURRENT_STREAMS value of zero disables\nserver push by preventing the server from creating the necessary\nstreams.  This does not prohibit a server from sending PUSH_PROMISE\nframes; clients need to reset any promised streams that are not\nwanted.")]),e._v("\n"),n("p",[e._v('Clients receiving a pushed response MUST validate that either the\nserver is authoritative (see Section 10.1) or the proxy that provided\nthe pushed response is configured for the corresponding request.  For\nexample, a server that offers a certificate for only the\n"example.com" DNS-ID or Common Name is not permitted to push a\nresponse for "https://www.example.org/doc".')]),e._v("\n"),n("p",[e._v('The response for a PUSH_PROMISE stream begins with a HEADERS frame,\nwhich immediately puts the stream into the "half-closed (remote)"\nstate for the server and "half-closed (local)" state for the client,\nand ends with a frame bearing END_STREAM, which places the stream in\nthe "closed" state.')]),e._v("\n"),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  Note: The client never sends a frame with the END_STREAM flag for\n  a server push.\n")])])])])])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("8.3.  The CONNECT Method")]),e._v("\n"),n("p",[e._v('In HTTP/1.x, the pseudo-method CONNECT ([RFC7231], Section 4.3.6) is\nused to convert an HTTP connection into a tunnel to a remote host.\nCONNECT is primarily used with HTTP proxies to establish a TLS\nsession with an origin server for the purposes of interacting with\n"https" resources.')]),e._v("\n"),n("p",[e._v('In HTTP/2, the CONNECT method is used to establish a tunnel over a\nsingle HTTP/2 stream to a remote host for similar purposes.  The HTTP\nheader field mapping works as defined in Section 8.1.2.3 ("Request\nPseudo-Header Fields"), with a few differences.  Specifically:')]),e._v("\n"),n("p",[e._v('o  The ":method" pseudo-header field is set to "CONNECT".')]),e._v("\n"),n("p",[e._v('o  The ":scheme" and ":path" pseudo-header fields MUST be omitted.')]),e._v("\n"),n("p",[e._v('o  The ":authority" pseudo-header field contains the host and port to\nconnect to (equivalent to the authority-form of the request-target\nof CONNECT requests (see [RFC7230], Section 5.3)).')]),e._v("\n"),n("p",[e._v("A CONNECT request that does not conform to these restrictions is\nmalformed (Section 8.1.2.6).")]),e._v("\n"),n("p",[e._v('A proxy that supports CONNECT establishes a TCP connection [TCP] to\nthe server identified in the ":authority" pseudo-header field.  Once\nthis connection is successfully established, the proxy sends a\nHEADERS frame containing a 2xx series status code to the client, as\ndefined in [RFC7231], Section 4.3.6.')]),e._v("\n"),n("p",[e._v("After the initial HEADERS frame sent by each peer, all subsequent\nDATA frames correspond to data sent on the TCP connection.  The\npayload of any DATA frames sent by the client is transmitted by the\nproxy to the TCP server; data received from the TCP server is\nassembled into DATA frames by the proxy.  Frame types other than DATA\nor stream management frames (RST_STREAM, WINDOW_UPDATE, and PRIORITY)\nMUST NOT be sent on a connected stream and MUST be treated as a\nstream error (Section 5.4.2) if received.")]),e._v("\n"),n("p",[e._v("The TCP connection can be closed by either peer.  The END_STREAM flag\non a DATA frame is treated as being equivalent to the TCP FIN bit.  A\nclient is expected to send a DATA frame with the END_STREAM flag set\nafter receiving a frame bearing the END_STREAM flag.  A proxy that\nreceives a DATA frame with the END_STREAM flag set sends the attached\ndata with the FIN bit set on the last TCP segment.  A proxy that\nreceives a TCP segment with the FIN bit set sends a DATA frame with\nthe END_STREAM flag set.  Note that the final TCP segment or DATA\nframe could be empty.")]),e._v("\n"),n("p",[e._v("A TCP connection error is signaled with RST_STREAM.  A proxy treats\nany error in the TCP connection, which includes receiving a TCP\nsegment with the RST bit set, as a stream error (Section 5.4.2) of\ntype CONNECT_ERROR.  Correspondingly, a proxy MUST send a TCP segment\nwith the RST bit set if it detects an error with the stream or the\nHTTP/2 connection.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"9"}},[e._v("\n"),n("li",[e._v("Additional HTTP Requirements/Considerations")]),e._v("\n")]),e._v("\n"),n("p",[e._v("This section outlines attributes of the HTTP protocol that improve\ninteroperability, reduce exposure to known security vulnerabilities,\nor reduce the potential for implementation variation.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("9.1.  Connection Management")]),e._v("\n"),n("p",[e._v("HTTP/2 connections are persistent.  For best performance, it is\nexpected that clients will not close connections until it is\ndetermined that no further communication with a server is necessary\n(for example, when a user navigates away from a particular web page)\nor until the server closes the connection.")]),e._v("\n"),n("p",[e._v("Clients SHOULD NOT open more than one HTTP/2 connection to a given\nhost and port pair, where the host is derived from a URI, a selected\nalternative service [ALT-SVC], or a configured proxy.")]),e._v("\n"),n("p",[e._v("A client can create additional connections as replacements, either to\nreplace connections that are near to exhausting the available stream\nidentifier space (Section 5.1.1), to refresh the keying material for\na TLS connection, or to replace connections that have encountered\nerrors (Section 5.4.1).")]),e._v("\n"),n("p",[e._v("A client MAY open multiple connections to the same IP address and TCP\nport using different Server Name Indication [TLS-EXT] values or to\nprovide different TLS client certificates but SHOULD avoid creating\nmultiple connections with the same configuration.")]),e._v("\n"),n("p",[e._v("Servers are encouraged to maintain open connections for as long as\npossible but are permitted to terminate idle connections if\nnecessary.  When either endpoint chooses to close the transport-layer\nTCP connection, the terminating endpoint SHOULD first send a GOAWAY\n(Section 6.8) frame so that both endpoints can reliably determine\nwhether previously sent frames have been processed and gracefully\ncomplete or terminate any necessary remaining tasks.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("9.1.1.  Connection Reuse")]),e._v("\n"),n("p",[e._v("Connections that are made to an origin server, either directly or\nthrough a tunnel created using the CONNECT method (Section 8.3), MAY\nbe reused for requests with multiple different URI authority\ncomponents.  A connection can be reused as long as the origin server\nis authoritative (Section 10.1).  For TCP connections without TLS,\nthis depends on the host having resolved to the same IP address.")]),e._v("\n"),n("p",[e._v('For "https" resources, connection reuse additionally depends on\nhaving a certificate that is valid for the host in the URI.  The\ncertificate presented by the server MUST satisfy any checks that the\nclient would perform when forming a new TLS connection for the host\nin the URI.')]),e._v("\n"),n("p",[e._v('An origin server might offer a certificate with multiple\n"subjectAltName" attributes or names with wildcards, one of which is\nvalid for the authority in the URI.  For example, a certificate with\na "subjectAltName" of "*.example.com" might permit the use of the\nsame connection for requests to URIs starting with\n"https://a.example.com/" and "https://b.example.com/".')]),e._v("\n"),n("p",[e._v("In some deployments, reusing a connection for multiple origins can\nresult in requests being directed to the wrong origin server.  For\nexample, TLS termination might be performed by a middlebox that uses\nthe TLS Server Name Indication (SNI) [TLS-EXT] extension to select an\norigin server.  This means that it is possible for clients to send\nconfidential information to servers that might not be the intended\ntarget for the request, even though the server is otherwise\nauthoritative.")]),e._v("\n"),n("p",[e._v("A server that does not wish clients to reuse connections can indicate\nthat it is not authoritative for a request by sending a 421\n(Misdirected Request) status code in response to the request (see\nSection 9.1.2).")]),e._v("\n"),n("p",[e._v("A client that is configured to use a proxy over HTTP/2 directs\nrequests to that proxy through a single connection.  That is, all\nrequests sent via a proxy reuse the connection to the proxy.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("9.1.2.  The 421 (Misdirected Request) Status Code")]),e._v("\n"),n("p",[e._v("The 421 (Misdirected Request) status code indicates that the request\nwas directed at a server that is not able to produce a response.\nThis can be sent by a server that is not configured to produce\nresponses for the combination of scheme and authority that are\nincluded in the request URI.")]),e._v("\n"),n("p",[e._v("Clients receiving a 421 (Misdirected Request) response from a server\nMAY retry the request -- whether the request method is idempotent or\nnot -- over a different connection.  This is possible if a connection\nis reused (Section 9.1.1) or if an alternative service is selected\n[ALT-SVC].")]),e._v("\n"),n("p",[e._v("This status code MUST NOT be generated by proxies.")]),e._v("\n"),n("p",[e._v("A 421 response is cacheable by default, i.e., unless otherwise\nindicated by the method definition or explicit cache controls (see\nSection 4.2.2 of [RFC7234]).")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("9.2.  Use of TLS Features")]),e._v("\n"),n("p",[e._v("Implementations of HTTP/2 MUST use TLS version 1.2 [TLS12] or higher\nfor HTTP/2 over TLS.  The general TLS usage guidance in [TLSBCP]\nSHOULD be followed, with some additional restrictions that are\nspecific to HTTP/2.")]),e._v("\n"),n("p",[e._v("The TLS implementation MUST support the Server Name Indication (SNI)\n[TLS-EXT] extension to TLS.  HTTP/2 clients MUST indicate the target\ndomain name when negotiating TLS.")]),e._v("\n"),n("p",[e._v("Deployments of HTTP/2 that negotiate TLS 1.3 or higher need only\nsupport and use the SNI extension; deployments of TLS 1.2 are subject\nto the requirements in the following sections.  Implementations are\nencouraged to provide defaults that comply, but it is recognized that\ndeployments are ultimately responsible for compliance.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("9.2.1.  TLS 1.2 Features")]),e._v("\n"),n("p",[e._v("This section describes restrictions on the TLS 1.2 feature set that\ncan be used with HTTP/2.  Due to deployment limitations, it might not\nbe possible to fail TLS negotiation when these restrictions are not\nmet.  An endpoint MAY immediately terminate an HTTP/2 connection that\ndoes not meet these TLS requirements with a connection error\n(Section 5.4.1) of type INADEQUATE_SECURITY.")]),e._v("\n"),n("p",[e._v("A deployment of HTTP/2 over TLS 1.2 MUST disable compression.  TLS\ncompression can lead to the exposure of information that would not\notherwise be revealed [RFC3749].  Generic compression is unnecessary\nsince HTTP/2 provides compression features that are more aware of\ncontext and therefore likely to be more appropriate for use for\nperformance, security, or other reasons.")]),e._v("\n"),n("p",[e._v("A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation.  An\nendpoint MUST treat a TLS renegotiation as a connection error\n(Section 5.4.1) of type PROTOCOL_ERROR.  Note that disabling")]),e._v("\n"),n("p",[e._v("renegotiation can result in long-lived connections becoming unusable\ndue to limits on the number of messages the underlying cipher suite\ncan encipher.")]),e._v("\n"),n("p",[e._v("An endpoint MAY use renegotiation to provide confidentiality\nprotection for client credentials offered in the handshake, but any\nrenegotiation MUST occur prior to sending the connection preface.  A\nserver SHOULD request a client certificate if it sees a renegotiation\nrequest immediately after establishing a connection.")]),e._v("\n"),n("p",[e._v("This effectively prevents the use of renegotiation in response to a\nrequest for a specific protected resource.  A future specification\nmight provide a way to support this use case.  Alternatively, a\nserver might use an error (Section 5.4) of type HTTP_1_1_REQUIRED to\nrequest the client use a protocol that supports renegotiation.")]),e._v("\n"),n("p",[e._v("Implementations MUST support ephemeral key exchange sizes of at least\n2048 bits for cipher suites that use ephemeral finite field Diffie-\nHellman (DHE) [TLS12] and 224 bits for cipher suites that use\nephemeral elliptic curve Diffie-Hellman (ECDHE) [RFC4492].  Clients\nMUST accept DHE sizes of up to 4096 bits.  Endpoints MAY treat\nnegotiation of key sizes smaller than the lower limits as a\nconnection error (Section 5.4.1) of type INADEQUATE_SECURITY.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("9.2.2.  TLS 1.2 Cipher Suites")]),e._v("\n"),n("p",[e._v("A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the cipher\nsuites that are listed in the cipher suite black list (Appendix A).")]),e._v("\n"),n("p",[e._v("Endpoints MAY choose to generate a connection error (Section 5.4.1)\nof type INADEQUATE_SECURITY if one of the cipher suites from the\nblack list is negotiated.  A deployment that chooses to use a black-\nlisted cipher suite risks triggering a connection error unless the\nset of potential peers is known to accept that cipher suite.")]),e._v("\n"),n("p",[e._v("Implementations MUST NOT generate this error in reaction to the\nnegotiation of a cipher suite that is not on the black list.\nConsequently, when clients offer a cipher suite that is not on the\nblack list, they have to be prepared to use that cipher suite with\nHTTP/2.")]),e._v("\n"),n("p",[e._v("The black list includes the cipher suite that TLS 1.2 makes\nmandatory, which means that TLS 1.2 deployments could have non-\nintersecting sets of permitted cipher suites.  To avoid this problem\ncausing TLS handshake failures, deployments of HTTP/2 that use TLS\n1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE]\nwith the P-256 elliptic curve [FIPS186].")]),e._v("\n"),n("p",[e._v("Note that clients might advertise support of cipher suites that are\non the black list in order to allow for connection to servers that do\nnot support HTTP/2.  This allows servers to select HTTP/1.1 with a\ncipher suite that is on the HTTP/2 black list.  However, this can\nresult in HTTP/2 being negotiated with a black-listed cipher suite if\nthe application protocol and cipher suite are independently selected.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"10"}},[e._v("\n"),n("li",[e._v("Security Considerations")]),e._v("\n")]),e._v("\n"),n("p",[e._v("10.1.  Server Authority")]),e._v("\n"),n("p",[e._v('HTTP/2 relies on the HTTP/1.1 definition of authority for determining\nwhether a server is authoritative in providing a given response (see\n[RFC7230], Section 9.1).  This relies on local name resolution for\nthe "http" URI scheme and the authenticated server identity for the\n"https" scheme (see [RFC2818], Section 3).')]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.2.  Cross-Protocol Attacks")]),e._v("\n"),n("p",[e._v("In a cross-protocol attack, an attacker causes a client to initiate a\ntransaction in one protocol toward a server that understands a\ndifferent protocol.  An attacker might be able to cause the\ntransaction to appear as a valid transaction in the second protocol.\nIn combination with the capabilities of the web context, this can be\nused to interact with poorly protected servers in private networks.")]),e._v("\n"),n("p",[e._v("Completing a TLS handshake with an ALPN identifier for HTTP/2 can be\nconsidered sufficient protection against cross-protocol attacks.\nALPN provides a positive indication that a server is willing to\nproceed with HTTP/2, which prevents attacks on other TLS-based\nprotocols.")]),e._v("\n"),n("p",[e._v("The encryption in TLS makes it difficult for attackers to control the\ndata that could be used in a cross-protocol attack on a cleartext\nprotocol.")]),e._v("\n"),n("p",[e._v("The cleartext version of HTTP/2 has minimal protection against cross-\nprotocol attacks.  The connection preface (Section 3.5) contains a\nstring that is designed to confuse HTTP/1.1 servers, but no special\nprotection is offered for other protocols.  A server that is willing\nto ignore parts of an HTTP/1.1 request containing an Upgrade header\nfield in addition to the client connection preface could be exposed\nto a cross-protocol attack.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.3.  Intermediary Encapsulation Attacks")]),e._v("\n"),n("p",[e._v("The HTTP/2 header field encoding allows the expression of names that\nare not valid field names in the Internet Message Syntax used by\nHTTP/1.1.  Requests or responses containing invalid header field\nnames MUST be treated as malformed (Section 8.1.2.6).  An\nintermediary therefore cannot translate an HTTP/2 request or response\ncontaining an invalid field name into an HTTP/1.1 message.")]),e._v("\n"),n("p",[e._v('Similarly, HTTP/2 allows header field values that are not valid.\nWhile most of the values that can be encoded will not alter header\nfield parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII\n0xa), and the zero character (NUL, ASCII 0x0) might be exploited by\nan attacker if they are translated verbatim.  Any request or response\nthat contains a character not permitted in a header field value MUST\nbe treated as malformed (Section 8.1.2.6).  Valid characters are\ndefined by the "field-content" ABNF rule in Section 3.2 of [RFC7230].')]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.4.  Cacheability of Pushed Responses")]),e._v("\n"),n("p",[e._v("Pushed responses do not have an explicit request from the client; the\nrequest is provided by the server in the PUSH_PROMISE frame.")]),e._v("\n"),n("p",[e._v("Caching responses that are pushed is possible based on the guidance\nprovided by the origin server in the Cache-Control header field.\nHowever, this can cause issues if a single server hosts more than one\ntenant.  For example, a server might offer multiple users each a\nsmall portion of its URI space.")]),e._v("\n"),n("p",[e._v("Where multiple tenants share space on the same server, that server\nMUST ensure that tenants are not able to push representations of\nresources that they do not have authority over.  Failure to enforce\nthis would allow a tenant to provide a representation that would be\nserved out of cache, overriding the actual representation that the\nauthoritative tenant provides.")]),e._v("\n"),n("p",[e._v("Pushed responses for which an origin server is not authoritative (see\nSection 10.1) MUST NOT be used or cached.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.5.  Denial-of-Service Considerations")]),e._v("\n"),n("p",[e._v("An HTTP/2 connection can demand a greater commitment of resources to\noperate than an HTTP/1.1 connection.  The use of header compression\nand flow control depend on a commitment of resources for storing a\ngreater amount of state.  Settings for these features ensure that\nmemory commitments for these features are strictly bounded.")]),e._v("\n"),n("p",[e._v('The number of PUSH_PROMISE frames is not constrained in the same\nfashion.  A client that accepts server push SHOULD limit the number\nof streams it allows to be in the "reserved (remote)" state.  An\nexcessive number of server push streams can be treated as a stream\nerror (Section 5.4.2) of type ENHANCE_YOUR_CALM.')]),e._v("\n"),n("p",[e._v("Processing capacity cannot be guarded as effectively as state\ncapacity.")]),e._v("\n"),n("p",[e._v("The SETTINGS frame can be abused to cause a peer to expend additional\nprocessing time.  This might be done by pointlessly changing SETTINGS\nparameters, setting multiple undefined parameters, or changing the\nsame setting multiple times in the same frame.  WINDOW_UPDATE or\nPRIORITY frames can be abused to cause an unnecessary waste of\nresources.")]),e._v("\n"),n("p",[e._v("Large numbers of small or empty frames can be abused to cause a peer\nto expend time processing frame headers.  Note, however, that some\nuses are entirely legitimate, such as the sending of an empty DATA or\nCONTINUATION frame at the end of a stream.")]),e._v("\n"),n("p",[e._v("Header compression also offers some opportunities to waste processing\nresources; see Section 7 of [COMPRESSION] for more details on\npotential abuses.")]),e._v("\n"),n("p",[e._v("Limits in SETTINGS parameters cannot be reduced instantaneously,\nwhich leaves an endpoint exposed to behavior from a peer that could\nexceed the new limits.  In particular, immediately after establishing\na connection, limits set by a server are not known to clients and\ncould be exceeded without being an obvious protocol violation.")]),e._v("\n"),n("p",[e._v("All these features -- i.e., SETTINGS changes, small frames, header\ncompression -- have legitimate uses.  These features become a burden\nonly when they are used unnecessarily or to excess.")]),e._v("\n"),n("p",[e._v("An endpoint that doesn't monitor this behavior exposes itself to a\nrisk of denial-of-service attack.  Implementations SHOULD track the\nuse of these features and set limits on their use.  An endpoint MAY\ntreat activity that is suspicious as a connection error\n(Section 5.4.1) of type ENHANCE_YOUR_CALM.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.5.1.  Limits on Header Block Size")]),e._v("\n"),n("p",[e._v("A large header block (Section 4.3) can cause an implementation to\ncommit a large amount of state.  Header fields that are critical for\nrouting can appear toward the end of a header block, which prevents\nstreaming of header fields to their ultimate destination.  This\nordering and other reasons, such as ensuring cache correctness, mean")]),e._v("\n"),n("p",[e._v("that an endpoint might need to buffer the entire header block.  Since\nthere is no hard limit to the size of a header block, some endpoints\ncould be forced to commit a large amount of available memory for\nheader fields.")]),e._v("\n"),n("p",[e._v("An endpoint can use the SETTINGS_MAX_HEADER_LIST_SIZE to advise peers\nof limits that might apply on the size of header blocks.  This\nsetting is only advisory, so endpoints MAY choose to send header\nblocks that exceed this limit and risk having the request or response\nbeing treated as malformed.  This setting is specific to a\nconnection, so any request or response could encounter a hop with a\nlower, unknown limit.  An intermediary can attempt to avoid this\nproblem by passing on values presented by different peers, but they\nare not obligated to do so.")]),e._v("\n"),n("p",[e._v("A server that receives a larger header block than it is willing to\nhandle can send an HTTP 431 (Request Header Fields Too Large) status\ncode [RFC6585].  A client can discard responses that it cannot\nprocess.  The header block MUST be processed to ensure a consistent\nconnection state, unless the connection is closed.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.5.2.  CONNECT Issues")]),e._v("\n"),n("p",[e._v("The CONNECT method can be used to create disproportionate load on an\nproxy, since stream creation is relatively inexpensive when compared\nto the creation and maintenance of a TCP connection.  A proxy might\nalso maintain some resources for a TCP connection beyond the closing\nof the stream that carries the CONNECT request, since the outgoing\nTCP connection remains in the TIME_WAIT state.  Therefore, a proxy\ncannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the\nresources consumed by CONNECT requests.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.6.  Use of Compression")]),e._v("\n"),n("p",[e._v("Compression can allow an attacker to recover secret data when it is\ncompressed in the same context as data under attacker control.\nHTTP/2 enables compression of header fields (Section 4.3); the\nfollowing concerns also apply to the use of HTTP compressed content-\ncodings ([RFC7231], Section 3.1.2.1).")]),e._v("\n"),n("p",[e._v("There are demonstrable attacks on compression that exploit the\ncharacteristics of the web (e.g., [BREACH]).  The attacker induces\nmultiple requests containing varying plaintext, observing the length\nof the resulting ciphertext in each, which reveals a shorter length\nwhen a guess about the secret is correct.")]),e._v("\n"),n("p",[e._v("Implementations communicating on a secure channel MUST NOT compress\ncontent that includes both confidential and attacker-controlled data\nunless separate compression dictionaries are used for each source of\ndata.  Compression MUST NOT be used if the source of data cannot be\nreliably determined.  Generic stream compression, such as that\nprovided by TLS, MUST NOT be used with HTTP/2 (see Section 9.2).")]),e._v("\n"),n("p",[e._v("Further considerations regarding the compression of header fields are\ndescribed in [COMPRESSION].")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.7.  Use of Padding")]),e._v("\n"),n("p",[e._v("Padding within HTTP/2 is not intended as a replacement for general\npurpose padding, such as might be provided by TLS [TLS12].  Redundant\npadding could even be counterproductive.  Correct application can\ndepend on having specific knowledge of the data that is being padded.")]),e._v("\n"),n("p",[e._v("To mitigate attacks that rely on compression, disabling or limiting\ncompression might be preferable to padding as a countermeasure.")]),e._v("\n"),n("p",[e._v("Padding can be used to obscure the exact size of frame content and is\nprovided to mitigate specific attacks within HTTP, for example,\nattacks where compressed content includes both attacker-controlled\nplaintext and secret data (e.g., [BREACH]).")]),e._v("\n"),n("p",[e._v("Use of padding can result in less protection than might seem\nimmediately obvious.  At best, padding only makes it more difficult\nfor an attacker to infer length information by increasing the number\nof frames an attacker has to observe.  Incorrectly implemented\npadding schemes can be easily defeated.  In particular, randomized\npadding with a predictable distribution provides very little\nprotection; similarly, padding payloads to a fixed size exposes\ninformation as payload sizes cross the fixed-sized boundary, which\ncould be possible if an attacker can control plaintext.")]),e._v("\n"),n("p",[e._v("Intermediaries SHOULD retain padding for DATA frames but MAY drop\npadding for HEADERS and PUSH_PROMISE frames.  A valid reason for an\nintermediary to change the amount of padding of frames is to improve\nthe protections that padding provides.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("10.8.  Privacy Considerations")]),e._v("\n"),n("p",[e._v("Several characteristics of HTTP/2 provide an observer an opportunity\nto correlate actions of a single client or server over time.  These\ninclude the value of settings, the manner in which flow-control\nwindows are managed, the way priorities are allocated to streams, the\ntiming of reactions to stimulus, and the handling of any features\nthat are controlled by settings.")]),e._v("\n"),n("p",[e._v("As far as these create observable differences in behavior, they could\nbe used as a basis for fingerprinting a specific client, as defined\nin Section 1.8 of [HTML5].")]),e._v("\n"),n("p",[e._v("HTTP/2's preference for using a single TCP connection allows\ncorrelation of a user's activity on a site.  Reusing connections for\ndifferent origins allows tracking across those origins.")]),e._v("\n"),n("p",[e._v("Because the PING and SETTINGS frames solicit immediate responses,\nthey can be used by an endpoint to measure latency to their peer.\nThis might have privacy implications in certain scenarios.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("ol",{attrs:{start:"11"}},[e._v("\n"),n("li",[e._v("IANA Considerations")]),e._v("\n")]),e._v("\n"),n("p",[e._v('A string for identifying HTTP/2 is entered into the "Application-\nLayer Protocol Negotiation (ALPN) Protocol IDs" registry established\nin [TLS-ALPN].')]),e._v("\n"),n("p",[e._v('This document establishes a registry for frame types, settings, and\nerror codes.  These new registries appear in the new "Hypertext\nTransfer Protocol version 2 (HTTP/2) Parameters" section.')]),e._v("\n"),n("p",[e._v("This document registers the HTTP2-Settings header field for use in\nHTTP; it also registers the 421 (Misdirected Request) status code.")]),e._v("\n"),n("p",[e._v('This document registers the "PRI" method for use in HTTP to avoid\ncollisions with the connection preface (Section 3.5).')]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.1.  Registration of HTTP/2 Identification Strings")]),e._v("\n"),n("p",[e._v('This document creates two registrations for the identification of\nHTTP/2 (see Section 3.3) in the "Application-Layer Protocol\nNegotiation (ALPN) Protocol IDs" registry established in [TLS-ALPN].')]),e._v("\n"),n("p",[e._v('The "h2" string identifies HTTP/2 when used over TLS:')]),e._v("\n"),n("p",[e._v("Protocol:  HTTP/2 over TLS")]),e._v("\n"),n("p",[e._v('Identification Sequence:  0x68 0x32 ("h2")')]),e._v("\n"),n("p",[e._v("Specification:  This document")]),e._v("\n"),n("p",[e._v('The "h2c" string identifies HTTP/2 when used over cleartext TCP:')]),e._v("\n"),n("p",[e._v("Protocol:  HTTP/2 over TCP")]),e._v("\n"),n("p",[e._v('Identification Sequence:  0x68 0x32 0x63 ("h2c")')]),e._v("\n"),n("p",[e._v("Specification:  This document")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.2.  Frame Type Registry")]),e._v("\n"),n("p",[e._v('This document establishes a registry for HTTP/2 frame type codes.\nThe "HTTP/2 Frame Type" registry manages an 8-bit space.  The "HTTP/2\nFrame Type" registry operates under either of the "IETF Review" or\n"IESG Approval" policies [RFC5226] for values between 0x00 and 0xef,\nwith values between 0xf0 and 0xff being reserved for Experimental\nUse.')]),e._v("\n"),n("p",[e._v("New entries in this registry require the following information:")]),e._v("\n"),n("p",[e._v("Frame Type:  A name or label for the frame type.")]),e._v("\n"),n("p",[e._v("Code:  The 8-bit code assigned to the frame type.")]),e._v("\n"),n("p",[e._v("Specification:  A reference to a specification that includes a\ndescription of the frame layout, its semantics, and flags that the\nframe type uses, including any parts of the frame that are\nconditionally present based on the value of flags.")]),e._v("\n"),n("p",[e._v("The entries in the following table are registered by this document.")]),e._v("\n"),n("p",[e._v("+---------------+------+--------------+\n| Frame Type    | Code | Section      |\n+---------------+------+--------------+\n| DATA          | 0x0  | Section 6.1  |\n| HEADERS       | 0x1  | Section 6.2  |\n| PRIORITY      | 0x2  | Section 6.3  |\n| RST_STREAM    | 0x3  | Section 6.4  |\n| SETTINGS      | 0x4  | Section 6.5  |\n| PUSH_PROMISE  | 0x5  | Section 6.6  |\n| PING          | 0x6  | Section 6.7  |\n| GOAWAY        | 0x7  | Section 6.8  |\n| WINDOW_UPDATE | 0x8  | Section 6.9  |\n| CONTINUATION  | 0x9  | Section 6.10 |\n+---------------+------+--------------+")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.3.  Settings Registry")]),e._v("\n"),n("p",[e._v('This document establishes a registry for HTTP/2 settings.  The\n"HTTP/2 Settings" registry manages a 16-bit space.  The "HTTP/2\nSettings" registry operates under the "Expert Review" policy\n[RFC5226] for values in the range from 0x0000 to 0xefff, with values\nbetween and 0xf000 and 0xffff being reserved for Experimental Use.')]),e._v("\n"),n("p",[e._v("New registrations are advised to provide the following information:")]),e._v("\n"),n("p",[e._v("Name:  A symbolic name for the setting.  Specifying a setting name is\noptional.")]),e._v("\n"),n("p",[e._v("Code:  The 16-bit code assigned to the setting.")]),e._v("\n"),n("p",[e._v("Initial Value:  An initial value for the setting.")]),e._v("\n"),n("p",[e._v("Specification:  An optional reference to a specification that\ndescribes the use of the setting.")]),e._v("\n"),n("p",[e._v("The entries in the following table are registered by this document.")]),e._v("\n"),n("p",[e._v("+------------------------+------+---------------+---------------+\n| Name                   | Code | Initial Value | Specification |\n+------------------------+------+---------------+---------------+\n| HEADER_TABLE_SIZE      | 0x1  | 4096          | Section 6.5.2 |\n| ENABLE_PUSH            | 0x2  | 1             | Section 6.5.2 |\n| MAX_CONCURRENT_STREAMS | 0x3  | (infinite)    | Section 6.5.2 |\n| INITIAL_WINDOW_SIZE    | 0x4  | 65535         | Section 6.5.2 |\n| MAX_FRAME_SIZE         | 0x5  | 16384         | Section 6.5.2 |\n| MAX_HEADER_LIST_SIZE   | 0x6  | (infinite)    | Section 6.5.2 |\n+------------------------+------+---------------+---------------+")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.4.  Error Code Registry")]),e._v("\n"),n("p",[e._v('This document establishes a registry for HTTP/2 error codes.  The\n"HTTP/2 Error Code" registry manages a 32-bit space.  The "HTTP/2\nError Code" registry operates under the "Expert Review" policy\n[RFC5226].')]),e._v("\n"),n("p",[e._v("Registrations for error codes are required to include a description\nof the error code.  An expert reviewer is advised to examine new\nregistrations for possible duplication with existing error codes.\nUse of existing registrations is to be encouraged, but not mandated.")]),e._v("\n"),n("p",[e._v("New registrations are advised to provide the following information:")]),e._v("\n"),n("p",[e._v("Name:  A name for the error code.  Specifying an error code name is\noptional.")]),e._v("\n"),n("p",[e._v("Code:  The 32-bit error code value.")]),e._v("\n"),n("p",[e._v("Description:  A brief description of the error code semantics, longer\nif no detailed specification is provided.")]),e._v("\n"),n("p",[e._v("Specification:  An optional reference for a specification that\ndefines the error code.")]),e._v("\n"),n("p",[e._v("The entries in the following table are registered by this document.")]),e._v("\n"),n("p",[e._v("+---------------------+------+----------------------+---------------+\n| Name                | Code | Description          | Specification |\n+---------------------+------+----------------------+---------------+\n| NO_ERROR            | 0x0  | Graceful shutdown    | Section 7     |\n| PROTOCOL_ERROR      | 0x1  | Protocol error       | Section 7     |\n|                     |      | detected             |               |\n| INTERNAL_ERROR      | 0x2  | Implementation fault | Section 7     |\n| FLOW_CONTROL_ERROR  | 0x3  | Flow-control limits  | Section 7     |\n|                     |      | exceeded             |               |\n| SETTINGS_TIMEOUT    | 0x4  | Settings not         | Section 7     |\n|                     |      | acknowledged         |               |\n| STREAM_CLOSED       | 0x5  | Frame received for   | Section 7     |\n|                     |      | closed stream        |               |\n| FRAME_SIZE_ERROR    | 0x6  | Frame size incorrect | Section 7     |\n| REFUSED_STREAM      | 0x7  | Stream not processed | Section 7     |\n| CANCEL              | 0x8  | Stream cancelled     | Section 7     |\n| COMPRESSION_ERROR   | 0x9  | Compression state    | Section 7     |\n|                     |      | not updated          |               |\n| CONNECT_ERROR       | 0xa  | TCP connection error | Section 7     |\n|                     |      | for CONNECT method   |               |\n| ENHANCE_YOUR_CALM   | 0xb  | Processing capacity  | Section 7     |\n|                     |      | exceeded             |               |\n| INADEQUATE_SECURITY | 0xc  | Negotiated TLS       | Section 7     |\n|                     |      | parameters not       |               |\n|                     |      | acceptable           |               |\n| HTTP_1_1_REQUIRED   | 0xd  | Use HTTP/1.1 for the | Section 7     |\n|                     |      | request              |               |\n+---------------------+------+----------------------+---------------+")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.5.  HTTP2-Settings Header Field Registration")]),e._v("\n"),n("p",[e._v('This section registers the HTTP2-Settings header field in the\n"Permanent Message Header Field Names" registry [BCP90].')]),e._v("\n"),n("p",[e._v("Header field name:  HTTP2-Settings")]),e._v("\n"),n("p",[e._v("Applicable protocol:  http")]),e._v("\n"),n("p",[e._v("Status:  standard")]),e._v("\n"),n("p",[e._v("Author/Change controller:  IETF")]),e._v("\n"),n("p",[e._v("Specification document(s):  Section 3.2.1 of this document")]),e._v("\n"),n("p",[e._v("Related information:  This header field is only used by an HTTP/2\nclient for Upgrade-based negotiation.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.6.  PRI Method Registration")]),e._v("\n"),n("p",[e._v('This section registers the "PRI" method in the "HTTP Method Registry"\n([RFC7231], Section 8.1).')]),e._v("\n"),n("p",[e._v("Method Name:  PRI")]),e._v("\n"),n("p",[e._v("Safe:  Yes")]),e._v("\n"),n("p",[e._v("Idempotent:  Yes")]),e._v("\n"),n("p",[e._v("Specification document(s):  Section 3.5 of this document")]),e._v("\n"),n("p",[e._v("Related information:  This method is never used by an actual client.\nThis method will appear to be used when an HTTP/1.1 server or\nintermediary attempts to parse an HTTP/2 connection preface.")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.7.  The 421 (Misdirected Request) HTTP Status Code")]),e._v("\n"),n("p",[e._v('This document registers the 421 (Misdirected Request) HTTP status\ncode in the "HTTP Status Codes" registry ([RFC7231], Section 8.2).')]),e._v("\n"),n("p",[e._v("Status Code:  421")]),e._v("\n"),n("p",[e._v("Short Description:  Misdirected Request")]),e._v("\n"),n("p",[e._v("Specification:  Section 9.1.2 of this document")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n"),n("p",[e._v("11.8.  The h2c Upgrade Token")]),e._v("\n"),n("p",[e._v('This document registers the "h2c" upgrade token in the "HTTP Upgrade\nTokens" registry ([RFC7230], Section 8.6).')]),e._v("\n"),n("p",[e._v("Value:  h2c")]),e._v("\n"),n("p",[e._v("Description:  Hypertext Transfer Protocol version 2 (HTTP/2)")]),e._v("\n"),n("p",[e._v("Expected Version Tokens:  None")]),e._v("\n"),n("p",[e._v("Reference:  Section 3.2 of this document")]),e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])]),e._v(" "),n("details",[n("summary",[e._v("原文")]),e._v(" "),n("pre",[n("code",[e._v("\n")]),e._v("\n")])])])}),[],!1,null,null,null);t.default=r.exports}}]);